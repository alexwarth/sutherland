<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <style>
        *,
        *::before,
        *::after {
          margin: 0;
          touch-action: none;
          -webkit-user-drag: none;
          -webkit-user-select: none;
          user-select: none;
        }

        html,
        body,
        canvas {
          position: absolute;
          top: 0;
          left: 0;
          width: 100%;
          height: 100vh;
          overflow: hidden;
        }
        @supports (height: 100dvh) {
          html,
          body,
          canvas {
            height: 100dvh;
          }
        }
        body {
          background-color: black;
        }
        canvas {
          cursor: none;
        }
    </style>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>TX2 Display Test</title>
  </head>
  <body>
    <canvas id="canvas"> </canvas>
    <script>(function(t) {
      typeof define == "function" && define.amd ? define(t) : t();
    })(function() {
      function t(s) {
        return s.startsWith("gl_") || s.startsWith("webgl_");
      }
      function e(s) {
        return !!s.texImage3D;
      }
      function n(s) {
        return s && s.buffer && s.buffer instanceof ArrayBuffer;
      }
      function r(s) {
        return Array.isArray(s) || s instanceof Float32Array || s instanceof Float64Array;
      }
      function o(s) {
        return s ? `"${s}"` : "";
      }
      const i = {};
      function c(s, h) {
        const E = [];
        if (h.length) {
          for (let v = 0; v < h.length; ++v)
            h.push(g(h[v]));
          return "[" + E.join(", ") + "]";
        }
        return E.toString();
      }
      function u(s) {
        return function(h, E) {
          let v = 0;
          const I = [];
          for (let U = 0; U < s.length; ++U) {
            const k = i[s[U]];
            E & k && (v |= k, I.push(g(k)));
          }
          return v === E ? I.join(" | ") : g(E);
        };
      }
      const m = /* @__PURE__ */ new Map();
      function b(s) {
        for (const h in s) {
          const E = s[h];
          typeof E == "number" && (m.has(E) || m.set(E, /* @__PURE__ */ new Set()), m.get(E).add(h));
        }
      }
      function g(s) {
        const h = m.get(s);
        return h ? [...h.keys()].map((E) => `${E}`).join(" | ") : `/*UNKNOWN WebGL ENUM*/ ${typeof s == "number" ? `0x${s.toString(16)}` : s}`;
      }
      const T = 5126, z = 35664, Q = 35665, L = 35666, D = 5124, j = 35667, q = 35668, ue = 35669, ce = 35670, Ee = 35671, le = 35672, Ve = 35673, Cn = 35674, nt = 35675, Ar = 35676, Ki = 35678, Ji = 35680, Qi = 35679, Zi = 35682, qi = 35685, es = 35686, ts = 35687, ns = 35688, rs = 35689, os = 35690, is = 36289, ss = 36292, as = 36293, Yt = 5125, Tr = 36294, vr = 36295, Sr = 36296, us = 36298, cs = 36299, fs = 36300, ls = 36303, ds = 36306, ms = 36307, _s = 36308, ps = 36311, hs = /* @__PURE__ */ new Map([
        [T, { size: 1, name: "float" }],
        [z, { size: 2, name: "vec2" }],
        [Q, { size: 3, name: "vec3" }],
        [L, { size: 4, name: "vec4" }],
        [D, { size: 1, name: "int" }],
        [j, { size: 2, name: "ivec2" }],
        [q, { size: 3, name: "ivec3" }],
        [ue, { size: 4, name: "ivec4" }],
        [Yt, { size: 1, name: "uint" }],
        [Tr, { size: 2, name: "uvec2" }],
        [vr, { size: 3, name: "uvec3" }],
        [Sr, { size: 4, name: "uvec4" }],
        [ce, { size: 1, name: "bool" }],
        [Ee, { size: 2, name: "bvec2" }],
        [le, { size: 3, name: "bvec3" }],
        [Ve, { size: 4, name: "bvec4" }],
        [Cn, { size: 4, name: "mat2" }],
        [nt, { size: 9, name: "mat3" }],
        [Ar, { size: 16, name: "mat4" }],
        [qi, { size: 6, name: "mat2x3" }],
        [es, { size: 8, name: "mat2x4" }],
        [ts, { size: 6, name: "mat3x2" }],
        [ns, { size: 12, name: "mat3x4" }],
        [rs, { size: 8, name: "mat4x2" }],
        [os, { size: 12, name: "mat4x3" }],
        [Ki, { size: 1, name: "sampler2D" }],
        [Ji, { size: 1, name: "samplerCube" }],
        [Qi, { size: 1, name: "sampler3D" }],
        [Zi, { size: 1, name: "sampler2DShadow" }],
        [is, { size: 1, name: "sampler2DArray" }],
        [ss, { size: 1, name: "sampler2DArrayShadow" }],
        [as, { size: 1, name: "samplerCubeShadow" }],
        [us, { size: 1, name: "isampler2D" }],
        [cs, { size: 1, name: "isampler3D" }],
        [fs, { size: 1, name: "isamplerCube" }],
        [ls, { size: 1, name: "isampler2DArray" }],
        [ds, { size: 1, name: "usampler2D" }],
        [ms, { size: 1, name: "usampler3D" }],
        [_s, { size: 1, name: "usamplerCube" }],
        [ps, { size: 1, name: "usampler2DArray" }]
      ]);
      function It(s) {
        return hs.get(s);
      }
      const bs = 32873, xs = 34068, ys = 32874, Es = 35869, gs = 34962, As = 34963, Ts = 34964, vs = 34965, Ss = 3553, Rs = 32879, ws = 35866, Fs = 34067, Is = 36160, Cs = 36161, Rr = 36006, Ns = 36007, Bs = 35982, Ds = 35983, Ps = 36009, Us = 36008, Ms = 36010, Os = 35345, Ls = 35368, ks = 36386, $s = 36389, zs = /* @__PURE__ */ new Map([
        [gs, Ts],
        [As, vs],
        [Ss, bs],
        [Fs, xs],
        [Rs, ys],
        [ws, Es],
        [Cs, Ns],
        [Is, Rr],
        [Ps, Rr],
        [Us, Ms],
        [Os, Ls],
        [Bs, Ds],
        [ks, $s]
      ]);
      function wr(s) {
        return zs.get(s);
      }
      const Vs = 5120, Gs = 5122, Fr = 5121, Ir = 5123, Hs = /* @__PURE__ */ new Map([
        [ce, 1],
        [Vs, 1],
        [Fr, 1],
        [Gs, 2],
        [Ir, 2],
        [D, 4],
        [Yt, 4],
        [T, 4]
      ]);
      function Cr(s) {
        return Hs.get(s) || 0;
      }
      const Xs = /* @__PURE__ */ new Map([
        [Fr, Uint8Array],
        [Ir, Uint16Array],
        [Yt, Uint32Array]
      ]);
      function Ys(s) {
        return Xs.get(s);
      }
      const Nr = {
        drawArrays(s, h, E) {
          return { startOffset: h, vertCount: E, instances: 1 };
        },
        drawElements(s, h, E, v) {
          return { startOffset: v, vertCount: h, instances: 1, indexType: E };
        },
        drawArraysInstanced(s, h, E, v) {
          return { startOffset: h, vertCount: E, instances: v };
        },
        drawElementsInstanced(s, h, E, v, I) {
          return { startOffset: v, vertCount: h, instances: I, indexType: E };
        },
        drawArraysInstancedANGLE(s, h, E, v) {
          return { startOffset: h, vertCount: E, instances: v };
        },
        drawElementsInstancedANGLE(s, h, E, v, I) {
          return { startOffset: v, vertCount: h, instances: I, indexType: E };
        },
        drawRangeElements(s, h, E, v, I, U) {
          return { startOffset: U, vertCount: v, instances: 1, indexType: I };
        }
      };
      function Br(s, h) {
        return Nr[s](...h);
      }
      function Nn(s) {
        return !!Nr[s];
      }
      const Ws = /* @__PURE__ */ new Map([
        [T, { size: 4 }],
        [z, { size: 8 }],
        [Q, { size: 12 }],
        [L, { size: 16 }],
        [D, { size: 4 }],
        [j, { size: 8 }],
        [q, { size: 12 }],
        [ue, { size: 16 }],
        [Yt, { size: 4 }],
        [Tr, { size: 8 }],
        [vr, { size: 12 }],
        [Sr, { size: 16 }],
        [ce, { size: 4 }],
        [Ee, { size: 8 }],
        [le, { size: 12 }],
        [Ve, { size: 16 }],
        [Cn, { size: 4, count: 2 }],
        [nt, { size: 9, count: 3 }],
        [Ar, { size: 16, count: 4 }]
      ]);
      function js(s) {
        return Ws.get(s);
      }
      const rt = (s) => s ? new WeakRef(s) : null, ot = (s, h) => {
        const E = s == null ? void 0 : s.deref();
        return !!E != !!h ? !1 : E ? E === h : !0;
      };
      function Dr(s, h) {
        return s === "undefined" ? h : s;
      }
      const Ks = 35070;
      function Js(s, h) {
        return s + h - 1;
      }
      function Qs(s, h, E, v, I, U, k, M, $) {
        const N = s.getParameter(s.ELEMENT_ARRAY_BUFFER_BINDING);
        if (!N) {
          $.push("No ELEMENT_ARRAY_BUFFER bound");
          return;
        }
        const H = Cr(U), ie = s.getBufferParameter(s.ELEMENT_ARRAY_BUFFER, s.BUFFER_SIZE), he = E + v * H;
        if (he > ie) {
          $.push(`offset: ${E} and count: ${v} with index type: ${g(U)} passed to ${h} are out of range for current ELEMENT_ARRAY_BUFFER.
    Those parameters require ${he} bytes but the current ELEMENT_ARRAY_BUFFER ${k(N)} only has ${ie} bytes`);
          return;
        }
        const Ae = M(N), be = Ys(U), Te = new be(Ae, E);
        let fe = Te[0];
        for (let et = 1; et < v; ++et)
          fe = Math.max(fe, Te[et]);
        return fe;
      }
      function Zs(s, h, E, v, I) {
        const { vertCount: U, startOffset: k, indexType: M, instances: $ } = Br(h, E);
        if (U <= 0 || $ <= 0)
          return [];
        const N = s.getParameter(s.CURRENT_PROGRAM), H = [], ie = M ? Qs(s, h, k, U, $, M, v, I, H) : Js(k, U);
        if (H.length)
          return H;
        const he = e(s) || s.getExtension("ANGLE_instanced_arrays"), Ae = s.getProgramParameter(N, s.ACTIVE_ATTRIBUTES), be = s.getParameter(s.ARRAY_BUFFER_BINDING);
        for (let Te = 0; Te < Ae; ++Te) {
          const { name: fe, type: et } = s.getActiveAttrib(N, Te);
          if (t(fe))
            continue;
          const je = s.getAttribLocation(N, fe), { count: bt } = { count: 1, ...js(et) };
          for (let K = 0; K < bt; ++K) {
            const se = je + K;
            if (!s.getVertexAttrib(se, s.VERTEX_ATTRIB_ARRAY_ENABLED))
              continue;
            const we = s.getVertexAttrib(se, s.VERTEX_ATTRIB_ARRAY_BUFFER_BINDING);
            if (!we) {
              H.push(`no buffer bound to attribute (${fe}) location: ${je}`);
              continue;
            }
            const P = s.getVertexAttrib(se, s.VERTEX_ATTRIB_ARRAY_SIZE), O = s.getVertexAttrib(se, s.VERTEX_ATTRIB_ARRAY_TYPE), w = Cr(O) * P, R = s.getVertexAttribOffset(se, s.VERTEX_ATTRIB_ARRAY_POINTER), B = s.getVertexAttrib(se, s.VERTEX_ATTRIB_ARRAY_STRIDE), X = B || w, V = he ? s.getVertexAttrib(se, Ks) : 0;
            s.bindBuffer(s.ARRAY_BUFFER, we);
            const te = s.getBufferParameter(s.ARRAY_BUFFER, s.BUFFER_SIZE), J = V > 0 ? (($ + V - 1) / V | 0) - 1 : ie, Z = R + J * X + w;
            Z > te && H.push(`${v(we)} assigned to attribute ${se} used as attribute '${fe}' in current program is too small for draw parameters.
    index of highest vertex accessed: ${J}
    attribute size: ${P}, type: ${g(O)}, stride: ${B}, offset: ${R}, divisor: ${V}
    needs ${Z} bytes for draw but buffer is only ${te} bytes`);
          }
        }
        return s.bindBuffer(s.ARRAY_BUFFER, be), H;
      }
      const Pr = 35678, Ur = 35680, Mr = 35679, Or = 35682, Lr = 36289, kr = 36292, $r = 36293, qs = 36298, ea = 36299, ta = 36300, na = 36303, ra = 36306, oa = 36307, ia = 36308, sa = 36311, Wt = /* @__PURE__ */ new Map([
        [Pr, { uniformType: "sampler2D", numberType: "float/normalized", bindPoint: "2D" }],
        [Ur, { uniformType: "samplerCube", numberType: "float/normalized", bindPoint: "CUBE" }],
        [Mr, { uniformType: "sampler3D", numberType: "float/normalized", bindPoint: "3D" }],
        [Or, { uniformType: "sampler2D", numberType: "float/normalized", bindPoint: "2D" }],
        [Lr, { uniformType: "sampler2DArray", numberType: "float/normalized", bindPoint: "2D_ARRAY" }],
        [kr, { uniformType: "sampler2DArray", numberType: "float/normalized", bindPoint: "2D_ARRAY" }],
        [$r, { uniformType: "samplerCube", numberType: "float/normalized", bindPoint: "CUBE" }],
        [qs, { uniformType: "isampler2D", numberType: "int", bindPoint: "2D" }],
        [ea, { uniformType: "isampler3D", numberType: "int", bindPoint: "3D" }],
        [ta, { uniformType: "isamplerCube", numberType: "int", bindPoint: "CUBE" }],
        [na, { uniformType: "isampler2DArray", numberType: "int", bindPoint: "2D_ARRAY" }],
        [ra, { uniformType: "usampler2D", numberType: "unsigned int", bindPoint: "2D" }],
        [oa, { uniformType: "usampler3D", numberType: "unsigned int", bindPoint: "3D" }],
        [ia, { uniformType: "usamplerCube", numberType: "unsigned int", bindPoint: "CUBE" }],
        [sa, { uniformType: "usampler2DArray", numberType: "unsigned int", bindPoint: "2D_ARRAY" }]
      ]);
      function aa(s) {
        return Wt.get(s).bindPoint;
      }
      function jt(s) {
        return Wt.has(s);
      }
      function ua(s) {
        return Wt.get(s).numberType;
      }
      function zr(s) {
        return Wt.get(s).uniformType;
      }
      const ca = 3553, fa = 32879, la = 35866, da = 34067, ma = 34069, _a = 34070, pa = 34071, ha = 34072, ba = 34073, xa = 34074, ya = /* @__PURE__ */ new Map([
        [ca, "2D"],
        [fa, "3D"],
        [da, "CUBE"],
        [ma, "CUBE"],
        [_a, "CUBE"],
        [pa, "CUBE"],
        [ha, "CUBE"],
        [ba, "CUBE"],
        [xa, "CUBE"],
        [la, "2D_ARRAY"]
      ]);
      function Vr(s) {
        return ya.get(s);
      }
      const Gr = 32873, Hr = 34068, Ea = 32874, Xr = 35869, ga = /* @__PURE__ */ new Map([
        [Pr, Gr],
        [Or, Gr],
        [Mr, Ea],
        [Lr, Xr],
        [kr, Xr],
        [Ur, Hr],
        [$r, Hr]
      ]);
      function Aa(s, h, E) {
        s.activeTexture(s.TEXTURE0 + h);
        const v = ga.get(E);
        return s.getParameter(v);
      }
      const Ta = 36063;
      function va(s) {
        return !e(s) && !s.getExtension("WEBGL_draw_buffers") ? 1 : s.getParameter(Ta);
      }
      function Kt(s, h, E) {
        if (s.getFramebufferAttachmentParameter(s.FRAMEBUFFER, h, s.FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE) === s.NONE)
          return;
        const I = s.getFramebufferAttachmentParameter(s.FRAMEBUFFER, h, s.FRAMEBUFFER_ATTACHMENT_OBJECT_NAME);
        I instanceof WebGLTexture && (E.has(I) || E.set(I, []), E.get(I).push(h));
      }
      function Sa(s, h) {
        const E = s.getParameter(s.FRAMEBUFFER_BINDING);
        if (!E)
          return [];
        const v = va(s), I = /* @__PURE__ */ new Map();
        for (let N = 0; N < v; ++N)
          Kt(s, s.COLOR_ATTACHMENT0 + N, I);
        Kt(s, s.DEPTH_ATTACHMENT, I), Kt(s, s.STENCIL_ATTACHMENT, I), e(s) || Kt(s, s.DEPTH_STENCIL_ATTACHMENT, I);
        const U = s.getParameter(s.ACTIVE_TEXTURE), k = s.getParameter(s.CURRENT_PROGRAM), M = s.getProgramParameter(k, s.ACTIVE_UNIFORMS), $ = [];
        for (let N = 0; N < M; ++N) {
          const { name: H, type: ie, size: he } = s.getActiveUniform(k, N);
          if (!(t(H) || !jt(ie)))
            if (he > 1) {
              const Ae = H.substr(-3) === "[0]" ? H.substr(0, H.length - 3) : H;
              for (let be = 0; be < he; ++be)
                $.push(...Yr(s, E, I, k, `${Ae}[${be}]`, ie, h));
            } else
              $.push(...Yr(s, E, I, k, H, ie, h));
        }
        return s.activeTexture(U), $;
      }
      function Yr(s, h, E, v, I, U, k) {
        const M = s.getUniformLocation(v, I), $ = s.getUniform(v, M), N = Aa(s, $, U), H = E.get(N);
        return H ? [`${k(N)} on uniform: ${I} bound to texture unit ${$} is also attached to ${k(h)} on attachment: ${H.map((ie) => g(ie)).join(", ")}`] : [];
      }
      function Ra() {
        const s = navigator.userAgent;
        let h = s.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];
        if (/trident/i.test(h[1]))
          return h = /\brv[ :]+(\d+)/g.exec(s) || [], {
            name: "IE",
            version: h[1]
          };
        if (h[1] === "Chrome") {
          const v = s.match(/\b(OPR|Edge)\/(\d+)/);
          if (v)
            return {
              name: v[1].replace("OPR", "Opera"),
              version: v[2]
            };
        }
        h = h[2] ? [h[1], h[2]] : [navigator.appName, navigator.appVersion, "-?"];
        const E = s.match(/version\/(\d+)/i);
        return E && h.splice(1, 1, E[1]), {
          name: h[0],
          version: h[1]
        };
      }
      const wa = function() {
        const s = Ra();
        let h, E;
        return /chrome|opera/i.test(s.name) ? (h = 3, E = function(v) {
          const I = /at ([^(]+)*\(*(.*?):(\d+):(\d+)/.exec(v);
          if (I) {
            let U = I[1], k = I[2];
            const M = parseInt(I[3]), $ = parseInt(I[4]);
            return k === "" && (k = U, U = ""), {
              url: k,
              lineNo: M,
              colNo: $,
              funcName: U
            };
          }
        }) : /firefox|safari/i.test(s.name) && (h = 2, E = function(v) {
          const I = /@(.*?):(\d+):(\d+)/.exec(v);
          if (I) {
            const U = I[1], k = parseInt(I[2]), M = parseInt(I[3]);
            return {
              url: U,
              lineNo: k,
              colNo: M
            };
          }
        }), function(I) {
          if (E)
            try {
              const U = I.split(`
    `);
              return E(U[h]);
            } catch {
            }
        };
      }();
      function Fa(s) {
        const h = [], E = s.getParameter(s.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
        for (let v = 0; v < E; ++v)
          h.push(/* @__PURE__ */ new Map());
        return h;
      }
      const Ia = 33984, Bn = 3553, Dn = 32879, it = 34067, Jt = 34069, Wr = 34070, jr = 34071, Kr = 34072, Jr = 34073, Qr = 34074, Zr = 10241, qr = 10240, Qt = 33084, eo = 33085, to = 10242, no = 10243, ro = 10497, oo = 35866, Zt = 33071, Pn = 9728, io = 9729, Ca = 9986, Na = /* @__PURE__ */ new Map([
        [9, function([s, h, E, v, I, , U, k]) {
          return { target: s, level: h, internalFormat: E, width: v, height: I, format: U, type: k };
        }],
        [6, function([s, h, E, v, I, U]) {
          return { target: s, level: h, internalFormat: E, width: U.width, height: U.height, format: v, type: I };
        }],
        [10, function([s, h, E, v, I, , U, k]) {
          return { target: s, level: h, internalFormat: E, width: v, height: I, format: U, type: k };
        }]
      ]), qt = 6406, Me = 6407, Oe = 6408, en = 6409, tn = 6410, Un = 6402, so = 34041, ao = /* @__PURE__ */ new Set([
        qt,
        en,
        tn,
        Me,
        Oe
      ]);
      function Ct(s, h) {
        return ao.has(s) ? `${g(s)}/${g(h)}` : g(s);
      }
      const uo = /* @__PURE__ */ new Map([
        [Bn, 0],
        [Dn, 0],
        [oo, 0],
        [it, 0],
        [Jt, 0],
        [Wr, 1],
        [jr, 2],
        [Kr, 3],
        [Jr, 4],
        [Qr, 5]
      ]);
      function Mn(s, h) {
        return h === it ? `(${g(Jt + s)})` : "";
      }
      const Ba = [
        Bn
      ], Da = [
        Jt,
        Wr,
        jr,
        Kr,
        Jr,
        Qr
      ], Pa = 33321, Ua = 36756, co = 33325, fo = 33326, Ma = 33330, Oa = 33329, La = 33338, ka = 33337, $a = 33340, za = 33339, Va = 33323, Ga = 36757, lo = 33327, mo = 33328, Ha = 33336, Xa = 33335, Ya = 33332, Wa = 33331, ja = 33334, Ka = 33333, Ja = 32849, Qa = 35905, Za = 36194, qa = 36758, eu = 35898, tu = 35901, _o = 34843, po = 34837, nu = 36221, ru = 36239, ou = 36215, iu = 36233, su = 36209, au = 36227, uu = 32856, cu = 35907, fu = 36759, lu = 32855, du = 32854, mu = 32857, ho = 34842, bo = 34836, _u = 36220, pu = 36238, hu = 36975, bu = 36214, xu = 36232, yu = 36226, Eu = 36208, gu = 33189, Au = 33190, Tu = 36012, vu = 36013, Su = 35056, st = 5120, ge = 5121, nn = 5122, Nt = 5123, rn = 5124, gt = 5125, Pe = 5126, xo = 32819, yo = 32820, Eo = 33635, at = 5131, go = 36193, On = 33640, Ru = 35899, wu = 35902, Fu = 36269, Iu = 34042, on = 33319, At = 33320, sn = 6403, Tt = 36244, vt = 36248, ht = 36249;
      function Cu() {
        const s = /* @__PURE__ */ new Map([
          // unsized formats
          [qt, { textureFormat: qt, colorRenderable: !0, textureFilterable: !0, bytesPerElement: [1, 2, 2, 4], type: [ge] }],
          [en, { textureFormat: en, colorRenderable: !0, textureFilterable: !0, bytesPerElement: [1, 2, 2, 4], type: [ge] }],
          [tn, { textureFormat: tn, colorRenderable: !0, textureFilterable: !0, bytesPerElement: [2, 4, 4, 8], type: [ge] }],
          [Me, { textureFormat: Me, colorRenderable: !0, textureFilterable: !0, bytesPerElement: [3, 6, 6, 12, 2], type: [ge, Eo] }],
          [Oe, { textureFormat: Oe, colorRenderable: !0, textureFilterable: !0, bytesPerElement: [4, 8, 8, 16, 2, 2], type: [ge, xo, yo] }],
          // sized formats
          [Pa, { textureFormat: sn, colorRenderable: !0, textureFilterable: !0, bytesPerElement: [1], type: [ge] }],
          [Ua, { textureFormat: sn, colorRenderable: !1, textureFilterable: !0, bytesPerElement: [1], type: [st] }],
          [co, { textureFormat: sn, colorRenderable: !1, textureFilterable: !0, bytesPerElement: [4, 2], type: [Pe, at] }],
          [fo, { textureFormat: sn, colorRenderable: !1, textureFilterable: !1, bytesPerElement: [4], type: [Pe] }],
          [Ma, { textureFormat: Tt, colorRenderable: !0, textureFilterable: !1, bytesPerElement: [1], type: [ge] }],
          [Oa, { textureFormat: Tt, colorRenderable: !0, textureFilterable: !1, bytesPerElement: [1], type: [st] }],
          [Ya, { textureFormat: Tt, colorRenderable: !0, textureFilterable: !1, bytesPerElement: [2], type: [Nt] }],
          [Wa, { textureFormat: Tt, colorRenderable: !0, textureFilterable: !1, bytesPerElement: [2], type: [nn] }],
          [ja, { textureFormat: Tt, colorRenderable: !0, textureFilterable: !1, bytesPerElement: [4], type: [gt] }],
          [Ka, { textureFormat: Tt, colorRenderable: !0, textureFilterable: !1, bytesPerElement: [4], type: [rn] }],
          [Va, { textureFormat: on, colorRenderable: !0, textureFilterable: !0, bytesPerElement: [2], type: [ge] }],
          [Ga, { textureFormat: on, colorRenderable: !1, textureFilterable: !0, bytesPerElement: [2], type: [st] }],
          [lo, { textureFormat: on, colorRenderable: !1, textureFilterable: !0, bytesPerElement: [8, 4], type: [Pe, at] }],
          [mo, { textureFormat: on, colorRenderable: !1, textureFilterable: !1, bytesPerElement: [8], type: [Pe] }],
          [Ha, { textureFormat: At, colorRenderable: !0, textureFilterable: !1, bytesPerElement: [2], type: [ge] }],
          [Xa, { textureFormat: At, colorRenderable: !0, textureFilterable: !1, bytesPerElement: [2], type: [st] }],
          [La, { textureFormat: At, colorRenderable: !0, textureFilterable: !1, bytesPerElement: [4], type: [Nt] }],
          [ka, { textureFormat: At, colorRenderable: !0, textureFilterable: !1, bytesPerElement: [4], type: [nn] }],
          [$a, { textureFormat: At, colorRenderable: !0, textureFilterable: !1, bytesPerElement: [8], type: [gt] }],
          [za, { textureFormat: At, colorRenderable: !0, textureFilterable: !1, bytesPerElement: [8], type: [rn] }],
          [Ja, { textureFormat: Me, colorRenderable: !0, textureFilterable: !0, bytesPerElement: [3], type: [ge] }],
          [Qa, { textureFormat: Me, colorRenderable: !1, textureFilterable: !0, bytesPerElement: [3], type: [ge] }],
          [Za, { textureFormat: Me, colorRenderable: !0, textureFilterable: !0, bytesPerElement: [3, 2], type: [ge, Eo] }],
          [qa, { textureFormat: Me, colorRenderable: !1, textureFilterable: !0, bytesPerElement: [3], type: [st] }],
          [eu, { textureFormat: Me, colorRenderable: !1, textureFilterable: !0, bytesPerElement: [12, 6, 4], type: [Pe, at, Ru] }],
          [tu, { textureFormat: Me, colorRenderable: !1, textureFilterable: !0, bytesPerElement: [12, 6, 4], type: [Pe, at, wu] }],
          [_o, { textureFormat: Me, colorRenderable: !1, textureFilterable: !0, bytesPerElement: [12, 6], type: [Pe, at] }],
          [po, { textureFormat: Me, colorRenderable: !1, textureFilterable: !1, bytesPerElement: [12], type: [Pe] }],
          [nu, { textureFormat: vt, colorRenderable: !1, textureFilterable: !1, bytesPerElement: [3], type: [ge] }],
          [ru, { textureFormat: vt, colorRenderable: !1, textureFilterable: !1, bytesPerElement: [3], type: [st] }],
          [ou, { textureFormat: vt, colorRenderable: !1, textureFilterable: !1, bytesPerElement: [6], type: [Nt] }],
          [iu, { textureFormat: vt, colorRenderable: !1, textureFilterable: !1, bytesPerElement: [6], type: [nn] }],
          [su, { textureFormat: vt, colorRenderable: !1, textureFilterable: !1, bytesPerElement: [12], type: [gt] }],
          [au, { textureFormat: vt, colorRenderable: !1, textureFilterable: !1, bytesPerElement: [12], type: [rn] }],
          [uu, { textureFormat: Oe, colorRenderable: !0, textureFilterable: !0, bytesPerElement: [4], type: [ge] }],
          [cu, { textureFormat: Oe, colorRenderable: !0, textureFilterable: !0, bytesPerElement: [4], type: [ge] }],
          [fu, { textureFormat: Oe, colorRenderable: !1, textureFilterable: !0, bytesPerElement: [4], type: [st] }],
          [lu, { textureFormat: Oe, colorRenderable: !0, textureFilterable: !0, bytesPerElement: [4, 2, 4], type: [ge, yo, On] }],
          [du, { textureFormat: Oe, colorRenderable: !0, textureFilterable: !0, bytesPerElement: [4, 2], type: [ge, xo] }],
          [mu, { textureFormat: Oe, colorRenderable: !0, textureFilterable: !0, bytesPerElement: [4], type: [On] }],
          [ho, { textureFormat: Oe, colorRenderable: !1, textureFilterable: !0, bytesPerElement: [16, 8], type: [Pe, at] }],
          [bo, { textureFormat: Oe, colorRenderable: !1, textureFilterable: !1, bytesPerElement: [16], type: [Pe] }],
          [_u, { textureFormat: ht, colorRenderable: !0, textureFilterable: !1, bytesPerElement: [4], type: [ge] }],
          [pu, { textureFormat: ht, colorRenderable: !0, textureFilterable: !1, bytesPerElement: [4], type: [st] }],
          [hu, { textureFormat: ht, colorRenderable: !0, textureFilterable: !1, bytesPerElement: [4], type: [On] }],
          [bu, { textureFormat: ht, colorRenderable: !0, textureFilterable: !1, bytesPerElement: [8], type: [Nt] }],
          [xu, { textureFormat: ht, colorRenderable: !0, textureFilterable: !1, bytesPerElement: [8], type: [nn] }],
          [yu, { textureFormat: ht, colorRenderable: !0, textureFilterable: !1, bytesPerElement: [16], type: [rn] }],
          [Eu, { textureFormat: ht, colorRenderable: !0, textureFilterable: !1, bytesPerElement: [16], type: [gt] }],
          // Sized Internal                                                                         these are marked as not filterable but for some reason they apparently are?
          [gu, { textureFormat: Un, colorRenderable: !0, textureFilterable: !0, bytesPerElement: [2, 4], type: [Nt, gt] }],
          [Au, { textureFormat: Un, colorRenderable: !0, textureFilterable: !0, bytesPerElement: [4], type: [gt] }],
          [Tu, { textureFormat: Un, colorRenderable: !0, textureFilterable: !0, bytesPerElement: [4], type: [Pe] }],
          [Su, { textureFormat: so, colorRenderable: !0, textureFilterable: !1, bytesPerElement: [4], type: [Iu] }],
          [vu, { textureFormat: so, colorRenderable: !0, textureFilterable: !1, bytesPerElement: [4], type: [Fu] }]
        ]);
        s.forEach((E) => {
          E.bytesPerElementMap = {}, E.bytesPerElement.forEach(function(v, I) {
            const U = E.type[I];
            E.bytesPerElementMap[U] = v;
          });
        });
        const h = /* @__PURE__ */ new Map();
        return s.forEach((E, v) => {
          ao.has(v) ? E.type.forEach((I) => {
            h.set(
              Ct(v, I),
              E
            );
          }) : h.set(
            Ct(v),
            E
          );
        }), {
          textureInternalFormatInfoMap: s,
          internalFormatStringToFormatInfoMap: h
        };
      }
      function an(s) {
        return (s & s - 1) === 0;
      }
      function Ln(s, h = 0, E = 0) {
        return (Math.log2(Math.max(s, h, E)) | 0) + 1;
      }
      function un(s, ...h) {
        return s ? h : [];
      }
      function Ao(s, h) {
        return [
          ...un(!an(s), `width(${s}) is not a power of 2`),
          ...un(!an(h), `height(${h}) is not a power of 2`)
        ].join(" and ");
      }
      function Nu(s, h) {
        return [
          ...un(s !== Zt, `TEXTURE_WRAP_S (${g(s)}) is not CLAMP_TO_EDGE`),
          ...un(h !== Zt, `TEXTURE_WRAP_T (${g(h)}) is not CLAMP_TO_EDGE`)
        ].join(" and ");
      }
      function Bu(s) {
        const h = g(s);
        return h.endsWith("UI") ? "unsigned int" : h.endsWith("I") ? "int" : "float/normalized";
      }
      function To(s, h, E, v) {
        return s === Bn || s === it ? `${h}x${E}` : `${h}x${E}x${v}`;
      }
      class Du {
        constructor(h, E) {
          this.redundantStateSetting = E;
          const v = e(h), I = !v, U = /* @__PURE__ */ new Set(), k = /* @__PURE__ */ new Map(), M = /* @__PURE__ */ new Map(), $ = Fa(h), N = Ln(h.getParameter(h.MAX_TEXTURE_SIZE)), { internalFormatStringToFormatInfoMap: H } = Cu();
          let ie = 0, he = $[0];
          this.numTextureUnits = $.length;
          function Ae(P) {
            P.notRenderable = Te(P, P.parameters);
          }
          function be() {
            k.forEach(Ae);
          }
          function Te(P, O) {
            const { type: w, mips: R } = P, B = O.get(Qt) || 0, X = Dr(O.get(eo), N);
            if (X < B)
              return `TEXTURE_MAX_LEVEL(${X}) is less than TEXTURE_BASE_LEVEL(${B})`;
            const V = R[B];
            if (!V)
              return "no base level mip ${baseLevel}";
            const te = V[0];
            if (!te)
              return "TEXTURE_CUBE_MAP_POSITIVE_X face does not exist";
            const {
              width: J,
              height: Z,
              depth: ve,
              // internalFormat: baseInternalFormat,
              internalFormatString: de
            } = te, De = w === it ? 6 : 1, Se = O.get(Zr), ut = H.get(de);
            if (ut && !ut.textureFilterable) {
              if (Se !== Pn)
                return `texture of type (${de}) is not filterable but TEXTURE_MIN_FILTER is set to ${g(Se)}`;
              {
                const Fe = O.get(qr);
                if (Fe !== Pn)
                  return `texture of type (${de}) is not filterable but TEXTURE_MAG_FILTER is set to ${g(Fe)}`;
              }
            }
            const Ke = Se === io || Se === Pn ? 1 : Ln(J, Z, ve);
            {
              let xe = J, Fe = Z, Je = ve;
              const Ge = Math.min(X, B + Ke - 1);
              for (let ae = B; ae <= Ge; ++ae) {
                const xt = R[ae];
                if (!xt)
                  return `filtering is set to use mips from level ${B} to ${Ge} with (TEXTURE_MIN_FILTER = ${g(Se)}) but mip level ${ae} does not exist`;
                for (let ct = 0; ct < De; ++ct) {
                  const He = xt[ct];
                  if (!He)
                    return `filtering is set to use mips level ${B} to ${Ge} with (TEXTURE_MIN_FILTER = ${g(Se)}) but mip level ${ae}${Mn(ct, w)} does not exist`;
                  if (He.width !== xe || He.height !== Fe || He.depth !== Je)
                    return `mip level ${ae}${Mn(ct, w)} needs to be ${To(w, xe, Fe, Je)} but it is ${To(w, He.width, He.height, He.depth)}`;
                  if (He.internalFormatString !== de)
                    return `mip level ${ae}${Mn(ct, w)}'s internal format ${He.internalFormatString} does not match mip level ${B}'s internal format ${de}`;
                }
                xe = Math.max(1, xe / 2 | 0), Fe = Math.max(1, Fe / 2 | 0), w !== oo && (Je = Math.max(1, Je / 2 | 0));
              }
            }
            if (I && (!an(J) || !an(Z))) {
              if (Ke > 1)
                return `texture's ${Ao(J, Z)} but TEXTURE_MIN_FILTER (${g(Se)}) is set to need mips`;
              const xe = O.get(to), Fe = O.get(no);
              if (xe !== Zt || Fe !== Zt)
                return `texture's ${Ao(J, Z)} but ${Nu(xe, Fe)}.`;
            }
            if (w === it && J !== Z)
              return `texture is CUBE_MAP but dimensions ${J}x${Z} are not square`;
          }
          function fe(P) {
            const O = Vr(P), w = he.get(O);
            return k.get(w);
          }
          function et(P, O) {
            const w = fe(P), R = uo.get(P);
            return w.mips[O][R];
          }
          function je(P, O, w) {
            const R = fe(P);
            R.parameters.set(O, w), Ae(R);
          }
          function bt(P, O) {
            for (let w = 0; w < $.length; ++w) {
              const R = $[w];
              R.get(P) === O && R.set(P, null);
            }
          }
          function K(P) {
            const { mips: O, parameters: w } = P, R = w.get(Qt) || 0, B = O[R];
            if (!B)
              return "";
            const X = B[0];
            return X ? X.internalFormatString : "";
          }
          function se(P, O) {
            const w = U.has(O);
            [
              Oe,
              Me,
              en,
              tn,
              qt
            ].forEach((R) => {
              H.set(
                Ct(R, P),
                { textureFormat: h.RGBA, textureFilterable: w }
              );
            });
          }
          function fn(P) {
            for (const O of P) {
              const w = H.get(
                Ct(O)
              );
              w.textureFilterable = !0;
            }
          }
          this.addExtension = function(P) {
            switch (U.add(P), P) {
              case "oes_texture_float":
                se(Pe, "oes_texture_float_linear");
                break;
              case "oes_texture_float_linear":
                v ? fn([
                  fo,
                  mo,
                  po,
                  bo
                ]) : U.has("oes_texture_float") && se(Pe, "oes_texture_float_linear"), be();
                break;
              case "oes_texture_half_float":
                se(at, "oes_texture_half_float_linear"), se(go, "oes_texture_half_float_linear");
                break;
              case "oes_texture_half_float_linear":
                v ? fn([
                  co,
                  lo,
                  _o,
                  ho
                ]) : U.has("oes_texture_half_float") && (se(at, "oes_texture_half_float_linear"), se(go, "oes_texture_half_float_linear")), be();
                break;
              default:
                return;
            }
          }, this.getTextureForTextureUnit = function(P, O) {
            return $[P].get(O);
          }, this.getTextureUnitUnrenderableReason = function(P, O, w, R) {
            const B = $[O].get(w);
            if (!B)
              return `no texture bound to texture unit ${O} ${w}`;
            const X = k.get(B), { mips: V, parameters: te } = X, J = te.get(Qt) || 0, Z = V[J];
            if (!Z)
              return `no mip level ${J}`;
            const ve = Z[0];
            if (!ve)
              return `TEXTURE_CUBE_MAP_POSITIVE_X face at mip level ${J} does not exist`;
            const de = Bu(ve.internalFormat), De = ua(P);
            if (de !== De)
              return `uniform ${zr(P)} needs a ${De} texture but ${R(B)} on texture unit ${O} is ${de} texture (${K(X)})`;
            const Se = $[O].get("SAMPLER");
            if (Se) {
              const ut = M.get(Se), Ke = Te(X, ut);
              return Ke && `${Ke} with sampler ${R(Se)} bound to texture unit ${O}`;
            } else
              return X.notRenderable;
          };
          function we(P, O, w, R, B, X, V = 0) {
            const te = Ct(w, V), J = fe(P), { mips: Z } = J;
            Z[O] || (Z[O] = []);
            const ve = uo.get(P);
            Z[O][ve] = { width: R, height: B, depth: X, internalFormatString: te, internalFormat: w, type: V }, Ae(J);
          }
          this.postChecks = {
            activeTexture(P, O, w) {
              ie = w[0] - Ia, he = $[ie];
            },
            bindTexture(P, O, w) {
              const [R, B] = w, X = Vr(R);
              if (he.get(X) === B)
                ++E.bindTexture;
              else if (he.set(X, B), B) {
                const V = k.get(B);
                if (V.type) {
                  if (V.type !== R)
                    throw new Error("should never get here");
                } else
                  V.type = R;
              }
            },
            createTexture(P, O, w, R) {
              const B = {
                mips: [],
                parameters: /* @__PURE__ */ new Map([
                  [Zr, Ca],
                  [qr, io],
                  [to, ro],
                  [no, ro]
                ]),
                renderable: !1
              };
              k.set(R, B);
            },
            deleteTexture(P, O, w) {
              const [R] = w, { type: B } = k.get(R);
              k.delete(R), bt(B, R);
            },
            createSampler(P, O, w, R) {
              M.set(R, /* @__PURE__ */ new Map());
            },
            deleteSampler(P, O, w) {
              const [R] = w;
              M.delete(R), bt("SAMPLER", R);
            },
            bindSampler(P, O, w) {
              const [R, B] = w;
              B === $[R].get("SAMPLER") ? ++E.bindSampler : $[R].set("SAMPLER", B);
            },
            samplerParameteri(P, O, w) {
              const [R, B, X] = w;
              M.get(R).set(B, X);
            },
            copyTexImage2D(P, O, w) {
              const [R, B, X, V, te] = w, J = P.UNSIGNED_BYTE;
              we(R, B, X, V, te, 1, J);
            },
            texImage2D(P, O, w) {
              const R = Na.get(w.length), { target: B, level: X, internalFormat: V, width: te, height: J, type: Z } = R(w);
              we(B, X, V, te, J, 1, Z);
            },
            texImage3D(P, O, w) {
              const [R, B, X, V, te, J, , , Z] = w;
              we(R, B, X, V, te, J, Z);
            },
            texStorage2D(P, O, w) {
              const [R, B, X, V, te] = w;
              let J = V, Z = te;
              const ve = R === it ? Da : Ba;
              for (let de = 0; de < B; ++de) {
                for (const De of ve)
                  we(De, de, X, J, Z, 1);
                J = Math.max(1, J / 2 | 0), Z = Math.max(1, Z / 2 | 0);
              }
            },
            texStorage3D(P, O, w) {
              const [R, B, X, V, te, J] = w;
              let Z = V, ve = te, de = J;
              for (let De = 0; De < B; ++De)
                we(R, De, X, Z, ve, de), Z = Math.max(1, Z / 2 | 0), ve = Math.max(1, ve / 2 | 0), R === Dn && (de = Math.max(1, de / 2 | 0));
            },
            generateMipmap(P, O, w) {
              const [R] = w, B = fe(R), { parameters: X } = B, V = X.get(Qt) || 0, te = Dr(X.get(eo), N), J = et(R, V), { width: Z, height: ve, depth: de, internalFormat: De, type: Se } = J, ut = Math.min(Ln(Z, ve, de), te + 1 - V), Ke = R === it ? 6 : 1;
              let xe = Z, Fe = ve, Je = de;
              for (let Ge = 0; Ge < ut; ++Ge) {
                xe = Math.max(1, xe / 2 | 0), Fe = Math.max(1, Fe / 2 | 0), R === Dn && (Je = Math.max(1, Je / 2 | 0));
                for (let ae = 0; ae < Ke; ++ae) {
                  const xt = R === it ? Jt + ae : R;
                  we(xt, V + Ge, De, xe, Fe, Je, Se);
                }
              }
            },
            compressedTexImage2D(P, O, w) {
              const [R, B, X, V, te] = w;
              we(R, B, X, V, te, 1);
            },
            compressedTexImage3D(P, O, w) {
              const [R, B, X, V, te, J] = w;
              we(R, B, X, V, te, J);
            },
            texParameteri(P, O, w) {
              const [R, B, X] = w;
              je(R, B, X);
            }
          };
        }
      }
      class vo {
        constructor(h) {
          this.elementAttribArray = null, this.attribs = [];
          for (let E = 0; E < h; ++E)
            this.attribs.push({
              size: 0,
              type: 0,
              normalize: !1,
              stride: 0,
              offset: 0,
              divisor: 0,
              buffer: null,
              iPointer: !1
            });
        }
        setElementArrayBuffer(h, E) {
          ot(this.elementAttribArray, E) ? ++h.bindBuffer : this.elementAttribArray = rt(E);
        }
        setAttrib(h, E, v, I, U, k, M, $, N) {
          const H = this.attribs[v];
          ot(H.buffer, N) && H.iPointer === E && H.size === I && H.type === U && H.normalize === k && H.stride === M && H.offset === $ ? ++h.vertexAttribPointer : Object.assign(H, {
            iPointer: E,
            size: I,
            type: U,
            normalize: k,
            stride: M,
            offset: $,
            buffer: rt(N)
          });
        }
      }
      class Pu {
        constructor(h, E) {
          this.gl = h, this.redundantStateSetting = E, this.numAttribs = h.getParameter(h.MAX_VERTEX_ATTRIBS), this.vertexArrays = /* @__PURE__ */ new WeakMap(), this.defaultVertexArray = new vo(this.numAttribs), this.currentVertexArray = this.defaultVertexArray;
          const v = (k, M, $, N) => {
            this.vertexArrays.set(N, new vo(this.numAttribs));
          }, I = (k, M, $) => {
            const [N] = $, H = this.vertexArrays.get(N);
            this.currentVertexArray === H && (this.currentVertexArray = this.defaultVertexArray), this.vertexArrays.delete(N);
          }, U = (k, M, $) => {
            let [N] = $;
            N = N ? this.vertexArrays.get(N) : this.defaultVertexArray, N === this.currentVertexArray ? ++this.redundantStateSetting.bindVertexArray : this.currentVertexArray = N;
          };
          this.postChecks = {
            createVertexArray: v,
            createVertexArrayOES: v,
            bindVertexArray: U,
            bindVertexArrayOES: U,
            bindBuffer: (k, M, $) => {
              const [N, H] = $;
              N === h.ELEMENT_ARRAY_BUFFER && this.currentVertexArray.setElementArrayBuffer(this.redundantStateSetting, H);
            },
            deleteVertexArray: I,
            deleteVertexArrayOES: I,
            vertexAttribPointer: (k, M, $) => {
              const [N, H, ie, he, Ae, be] = $, Te = this.gl;
              this.currentVertexArray.setAttrib(this.redundantStateSetting, !1, N, H, ie, he, Ae, be, Te.getParameter(Te.ARRAY_BUFFER_BINDING));
            },
            vertexAttribIPointer: (k, M, $) => {
              const [N, H, ie, he, Ae] = $, be = this.gl;
              this.currentVertexArray.setAttrib(this.redundantStateSetting, !0, N, H, ie, !1, he, Ae, be.getParameter(be.ARRAY_BUFFER_BINDING));
            }
          };
        }
      }
      const So = u([
        "COLOR_BUFFER_BIT",
        "DEPTH_BUFFER_BIT",
        "STENCIL_BUFFER_BIT"
      ]);
      function cn(s, h) {
        Array.isArray(s[h]) && (s[h] = Object.fromEntries(s[h].map((E) => [Math.abs(E), E])));
      }
      function Uu(s, h, E, v) {
        const I = E[0], U = v.locationsToNamesMap.get(I), k = s.getParameter(s.CURRENT_PROGRAM), M = [];
        if (U && M.push(`trying to set uniform '${U}'`), k) {
          const $ = v.webglObjectToNamesMap.get(k);
          $ && M.push(`on WebGLProgram(${o($)})`);
        } else
          M.push("on ** no current program **");
        return M.length ? `: ${M.join(" ")}` : "";
      }
      function Ro(s) {
        if (Array.isArray(s) || n(s) || typeof s != "object")
          throw new Error("not a WebGLObject");
      }
      function Mu() {
        return {
          elementArrayBuffer: null,
          vertexAttribs: []
        };
      }
      const kn = /* @__PURE__ */ new Set(), wo = {
        useProgram: 0,
        bindBuffer: 0,
        bindFramebuffer: 0,
        bindRenderbuffer: 0,
        bindSampler: 0,
        bindTexture: 0,
        bindVertexArray: 0,
        enableDisable: 0,
        vertexAttribPointer: 0
      };
      function Fo(s, h, E = {}) {
        if (kn.has(s))
          return s;
        kn.add(s);
        const v = E.origGLErrorFn || s.getError;
        b(s);
        function I(a) {
          const l = Mu(), f = { ...wo }, d = {};
          for (const A in a) {
            const S = a[A];
            d[A] = typeof S == "function" ? function(...F) {
              return S.call(a, ...F);
            } : S;
          }
          const x = {
            baseContext: a,
            config: E,
            apis: { gman_debug_helper: {
              ctx: {
                tagObject(A, S) {
                  Ro(A), x.webglObjectToNamesMap.set(A, S);
                },
                untagObject(A) {
                  Ro(A), x.webglObjectToNamesMap.delete(A);
                },
                getTagForObject(A) {
                  return x.webglObjectToNamesMap.get(A);
                },
                disable() {
                  R();
                },
                setConfiguration(A) {
                  for (const [S, F] of Object.entries(A)) {
                    if (!(S in x.config))
                      throw new Error(`unknown configuration option: ${S}`);
                    x.config[S] = F;
                  }
                  for (const S of x.config.ignoreUniforms)
                    x.ignoredUniforms.add(S);
                },
                getAndResetRedundantCallInfo() {
                  const A = { ...f };
                  if (Object.assign(f, wo), this._checksRemoved)
                    for (const S of Object.keys(A))
                      A[S] = "invalid is webgl-lint is no longer running. maxDrawCalls exceeded";
                  return A;
                }
              }
            } },
            idCounts: {},
            textureManager: new Du(d, f),
            vertexArrayManager: new Pu(d, f),
            bufferToIndices: /* @__PURE__ */ new Map(),
            ignoredUniforms: /* @__PURE__ */ new Set(),
            // Okay or bad? This is a map of all WebGLUniformLocation object looked up
            // by the user via getUniformLocation. We use this to map a location back to
            // a name and unfortunately a WebGLUniformLocation is not unique, by which
            // I mean if you call get getUniformLocation twice for the same uniform you'll
            // get 2 different WebGLUniformLocation objects referring to the same location.
            //
            // So, that means I can't look up the locations myself and know what they are
            // unless I passed the location objects I looked up back to the user but if I
            // did that then technically I'd have changed the semantics (though I suspect
            // no one ever takes advantage of that quirk)
            //
            // In any case this is all uniforms for all programs. That means in order
            // to clean up later I have to track all the uniforms (see programToUniformMap)
            // so that makes me wonder if I should track names per program instead.
            //
            // The advantage to this global list is given a WebGLUniformLocation and
            // no other info I can lookup the name where as if I switch it to per-program
            // then I need to know the program. That's generally available but it's indirect.
            locationsToNamesMap: /* @__PURE__ */ new Map(),
            webglObjectToNamesMap: /* @__PURE__ */ new Map(),
            // @typedef {Object} UnusedUniformRef
            // @property {number} index the index of this name. for foo[3] it's 3
            // @property {Map<string, number>} altNames example <foo,0>, <foo[0],0>, <foo[1],1>, <foo[2],2>, <foo[3],3>  for `uniform vec4 foo[3]`
            // @property {Set<number>} unused this is size so for the example above it's `Set<[0, 1, 2, 3]`
            // Both the altName array and the unused Set are shared with an entry in `programToUnsetUniformsMap`
            // by each name (foo, foo[0], foo[1], foo[2]). That we we can unused.delete each element of set
            // and if set is empty then delete all altNames entries from programToUnsetUniformsMap.
            // When programsToUniformsMap is empty all uniforms have been set.
            // @typedef {Map<WebGLProgram, Map<string, UnusedUniformRef>}
            programToUnsetUniformsMap: /* @__PURE__ */ new Map(),
            // class UniformInfo {
            //   index: the index of this name. for foo[3] it's 3
            //   size: this is the array size for this uniform
            //   type: the enum for the type like FLOAT_VEC4
            // }
            /** @type {WebGLProgram, Map<UniformInfo>} */
            programToUniformInfoMap: /* @__PURE__ */ new Map(),
            /** @type {WebGLProgram, Set<WebGLUniformLocation>} */
            programToLocationsMap: /* @__PURE__ */ new Map(),
            // class UniformSamplerInfo {
            //   type: the enum for the uniform type like SAMPLER_2D
            //   values: number[],
            //   name: string
            // }
            /** @type {WebGLProgram, UniformSamplerInfo[]} */
            programToUniformSamplerValues: /* @__PURE__ */ new Map(),
            // state for state tracking
            defaultVertexArray: l,
            webglState: {
              currentProgram: null,
              buffers: {},
              currentReadFramebuffer: null,
              currentDrawFramebuffer: null,
              currentRenderbuffer: null,
              textureUnits: [],
              enabled: {}
            },
            redundantStateSetting: f
          };
          return x;
        }
        const U = E.sharedState || I(s);
        E.sharedState = U;
        const {
          apis: k,
          baseContext: M,
          bufferToIndices: $,
          config: N,
          ignoredUniforms: H,
          locationsToNamesMap: ie,
          programToLocationsMap: he,
          programToUniformInfoMap: Ae,
          programToUniformSamplerValues: be,
          programToUnsetUniformsMap: Te,
          textureManager: fe,
          vertexArrayManager: et,
          webglObjectToNamesMap: je,
          idCounts: bt,
          webglState: K,
          redundantStateSetting: se
        } = U;
        ({
          oes_texture_float(...a) {
            fe.addExtension(...a);
          },
          oes_texture_float_linear(...a) {
            fe.addExtension(...a);
          },
          OES_texture_half_float(...a) {
            fe.addExtension(...a);
          },
          oes_texture_half_float_linear(...a) {
            fe.addExtension(...a);
          }
        }[h] || X)(h);
        const we = {
          // Generic setters and getters
          enable: { 1: { enums: [0] } },
          disable: { 1: { enums: [0] } },
          getParameter: { 1: { enums: [0] } },
          // Rendering
          drawArrays: { 3: { enums: [0], numbers: [1, 2] } },
          drawElements: { 4: { enums: [0, 2], numbers: [1, 3] } },
          drawArraysInstanced: { 4: { enums: [0], numbers: [1, 2, 3] } },
          drawElementsInstanced: { 5: { enums: [0, 2], numbers: [1, 3, 4] } },
          drawRangeElements: { 6: { enums: [0, 4], numbers: [1, 2, 3, 5] } },
          // Shaders
          createShader: { 1: { enums: [0] } },
          getActiveAttrib: { 2: { numbers: [1] } },
          getActiveUniform: { 2: { numbers: [1] } },
          getShaderParameter: { 2: { enums: [1] } },
          getProgramParameter: { 2: { enums: [1] } },
          getShaderPrecisionFormat: { 2: { enums: [0, 1] } },
          bindAttribLocation: { 3: { numbers: [1] } },
          // Vertex attributes
          getVertexAttrib: { 2: { enums: [1], numbers: [0] } },
          vertexAttribPointer: { 6: { enums: [2], numbers: [0, 1, 4, 5] } },
          vertexAttribIPointer: { 5: { enums: [2], numbers: [0, 1, 3, 4] } },
          // WebGL2
          vertexAttribDivisor: { 2: { numbers: [0, 1] } },
          // WebGL2
          disableVertexAttribArray: { 1: { numbers: [0] } },
          enableVertexAttribArray: { 1: { numbers: [0] } },
          // Textures
          bindTexture: { 2: { enums: [0], undef: [1] } },
          activeTexture: { 1: { enums: [0, 1] } },
          getTexParameter: { 2: { enums: [0, 1] } },
          texParameterf: { 3: { enums: [0, 1] } },
          texParameteri: { 3: { enums: [0, 1, 2] } },
          texImage2D: {
            9: { enums: [0, 2, 6, 7], numbers: [1, 3, 4, 5], arrays: [-8] },
            6: { enums: [0, 2, 3, 4] },
            10: { enums: [0, 2, 6, 7], numbers: [1, 3, 4, 5, 9], arrays: { 8: Gu } }
            // WebGL2
          },
          texImage3D: {
            10: { enums: [0, 2, 7, 8], numbers: [1, 3, 4, 5] },
            // WebGL2
            11: { enums: [0, 2, 7, 8], numbers: [1, 3, 4, 5, 10], arrays: { 9: zn } }
            // WebGL2
          },
          texSubImage2D: {
            9: { enums: [0, 6, 7], numbers: [1, 2, 3, 4, 5] },
            7: { enums: [0, 4, 5], numbers: [1, 2, 3] },
            10: { enums: [0, 6, 7], numbers: [1, 2, 3, 4, 5, 9], arrays: { 9: zn } }
            // WebGL2
          },
          texSubImage3D: {
            11: { enums: [0, 8, 9], numbers: [1, 2, 3, 4, 5, 6, 7] },
            // WebGL2
            12: { enums: [0, 8, 9], numbers: [1, 2, 3, 4, 5, 6, 7, 11], arrays: { 10: zn } }
            // WebGL2
          },
          texStorage2D: { 5: { enums: [0, 2], numbers: [1, 3, 4] } },
          // WebGL2
          texStorage3D: { 6: { enums: [0, 2], numbers: [1, 3, 4, 6] } },
          // WebGL2
          copyTexImage2D: { 8: { enums: [0, 2], numbers: [1, 3, 4, 5, 6, 7] } },
          copyTexSubImage2D: { 8: { enums: [0], numbers: [1, 2, 3, 4, 5, 6, 7] } },
          copyTexSubImage3D: { 9: { enums: [0], numbers: [1, 2, 3, 4, 5, 6, 7, 8] } },
          // WebGL2
          generateMipmap: { 1: { enums: [0] } },
          compressedTexImage2D: {
            7: { enums: [0, 2], numbers: [1, 3, 4, 5] },
            8: { enums: [0, 2], numbers: [1, 3, 4, 5, 7] },
            // WebGL2
            9: { enums: [0, 2], numbers: [1, 3, 4, 5, 7, 8] }
            // WebGL2
          },
          compressedTexSubImage2D: {
            8: { enums: [0, 6], numbers: [1, 2, 3, 4, 5] },
            9: { enums: [0, 6], numbers: [1, 2, 3, 4, 5, 8] },
            // WebGL2
            10: { enums: [0, 6], numbers: [1, 2, 3, 4, 5, 8, 9] }
            // WebGL2
          },
          compressedTexImage3D: {
            8: { enums: [0, 2], numbers: [1, 3, 4, 5, 6] },
            // WebGL2
            9: { enums: [0, 2], numbers: [1, 3, 4, 5, 6, -7, 8] },
            // WebGL2
            10: { enums: [0, 2], numbers: [1, 3, 4, 5, 6, 8, 9] }
            // WebGL2
          },
          compressedTexSubImage3D: {
            12: { enums: [0, 8], numbers: [1, 2, 3, 4, 5, 6, 7, 8, 10, 11] },
            // WebGL2
            11: { enums: [0, 8], numbers: [1, 2, 3, 4, 5, 6, 7, 8, -9, 10] },
            // WebGL2
            10: { enums: [0, 8], numbers: [1, 2, 3, 4, 5, 6, 7, 8] }
            // WebGL2
          },
          // Buffer objects
          bindBuffer: { 2: { enums: [0], undef: [1] } },
          bufferData: {
            3: { enums: [0, 2], numbers: [-1], arrays: [-1] },
            4: { enums: [0, 2], numbers: [-1, 3], arrays: { 1: Bo } },
            // WebGL2
            5: { enums: [0, 2], numbers: [-1, 3, 4], arrays: { 1: Do } }
            // WebGL2
          },
          bufferSubData: {
            3: { enums: [0], numbers: [1], arrays: { 2: Vu } },
            4: { enums: [0], numbers: [1, 3], arrays: { 2: Bo } },
            // WebGL2
            5: { enums: [0], numbers: [1, 3, 4], arrays: { 2: Do } }
            // WebGL2
          },
          copyBufferSubData: {
            5: { enums: [0], numbers: [2, 3, 4] }
            // WebGL2
          },
          getBufferParameter: { 2: { enums: [0, 1] } },
          getBufferSubData: {
            3: { enums: [0], numbers: [1] },
            // WebGL2
            4: { enums: [0], numbers: [1, 3] },
            // WebGL2
            5: { enums: [0], numbers: [1, 3, 4] }
            // WebGL2
          },
          // Renderbuffers and framebuffers
          pixelStorei: { 2: { enums: [0, 1], numbers: [1] } },
          readPixels: {
            7: { enums: [4, 5], numbers: [0, 1, 2, 3, -6] },
            8: { enums: [4, 5], numbers: [0, 1, 2, 3, 7] }
            // WebGL2
          },
          bindRenderbuffer: { 2: { enums: [0], undef: [1] } },
          bindFramebuffer: { 2: { enums: [0], undef: [1] } },
          blitFramebuffer: { 10: { enums: { 8: So, 9: !0 }, numbers: [0, 1, 2, 3, 4, 5, 6, 7] } },
          // WebGL2
          checkFramebufferStatus: { 1: { enums: [0] } },
          framebufferRenderbuffer: { 4: { enums: [0, 1, 2] } },
          framebufferTexture2D: { 5: { enums: [0, 1, 2], numbers: [4] } },
          framebufferTextureLayer: { 5: { enums: [0, 1], numbers: [3, 4] } },
          // WebGL2
          getFramebufferAttachmentParameter: { 3: { enums: [0, 1, 2] } },
          getInternalformatParameter: { 3: { enums: [0, 1, 2] } },
          // WebGL2
          getRenderbufferParameter: { 2: { enums: [0, 1] } },
          invalidateFramebuffer: { 2: { enums: { 0: !0, 1: c } } },
          // WebGL2
          invalidateSubFramebuffer: { 6: { enums: { 0: !0, 1: c }, numbers: [2, 3, 4, 5] } },
          // WebGL2
          readBuffer: { 1: { enums: [0] } },
          // WebGL2
          renderbufferStorage: { 4: { enums: [0, 1], numbers: [2, 3] } },
          renderbufferStorageMultisample: { 5: { enums: [0, 2], numbers: [1, 3, 4] } },
          // WebGL2
          bindVertexBuffer: { 1: { undef: [1] } },
          bindVertexBufferOES: { 1: { undef: [1] } },
          // Frame buffer operations (clear, blend, depth test, stencil)
          lineWidth: { 1: { numbers: [0] } },
          polygonOffset: { 2: { numbers: [0, 1] } },
          scissor: { 4: { numbers: [0, 1, 2, 3] } },
          viewport: { 4: { numbers: [0, 1, 2, 3] } },
          clear: { 1: { enums: { 0: So } } },
          clearColor: { 4: { numbers: [0, 1, 2, 3] } },
          clearDepth: { 1: { numbers: [0] } },
          clearStencil: { 1: { numbers: [0] } },
          depthFunc: { 1: { enums: [0] } },
          depthRange: { 2: { numbers: [0, 1] } },
          blendColor: { 4: { numbers: [0, 1, 2, 3] } },
          blendFunc: { 2: { enums: [0, 1] } },
          blendFuncSeparate: { 4: { enums: [0, 1, 2, 3] } },
          blendEquation: { 1: { enums: [0] } },
          blendEquationSeparate: { 2: { enums: [0, 1] } },
          stencilFunc: { 3: { enums: [0], numbers: [1, 2] } },
          stencilFuncSeparate: { 4: { enums: [0, 1], numberS: [2, 3] } },
          stencilMask: { 1: { numbers: [0] } },
          stencilMaskSeparate: { 2: { enums: [0], numbers: [1] } },
          stencilOp: { 3: { enums: [0, 1, 2] } },
          stencilOpSeparate: { 4: { enums: [0, 1, 2, 3] } },
          // Culling
          cullFace: { 1: { enums: [0] } },
          frontFace: { 1: { enums: [0] } },
          // ANGLE_instanced_arrays extension
          drawArraysInstancedANGLE: { 4: { enums: [0], numbers: [1, 2, 3] } },
          drawElementsInstancedANGLE: { 5: { enums: [0, 2], numbers: [1, 3, 4] } },
          // EXT_blend_minmax extension
          blendEquationEXT: { 1: { enums: [0] } },
          // Multiple Render Targets
          drawBuffersWebGL: { 1: { enums: { 0: c }, arrays: [0] } },
          // WEBGL_draw_buffers
          drawBuffers: { 1: { enums: { 0: c }, arrays: [0] } },
          // WebGL2
          clearBufferfv: {
            3: { enums: [0], numbers: [1], arrays: [2] },
            // WebGL2
            4: { enums: [0], numbers: [1, 3], arrays: [2] }
            // WebGL2
          },
          clearBufferiv: {
            3: { enums: [0], numbers: [1], arrays: [2] },
            // WebGL2
            4: { enums: [0], numbers: [1, 3], arrays: [2] }
            // WebGL2
          },
          clearBufferuiv: {
            3: { enums: [0], numbers: [1], arrays: [2] },
            // WebGL2
            4: { enums: [0], numbers: [1, 3], arrays: [2] }
            // WebGL2
          },
          clearBufferfi: { 4: { enums: [0], numbers: [1, 2, 3] } },
          // WebGL2
          // uniform value setters
          uniform1f: { 2: { numbers: [1] } },
          uniform2f: { 3: { numbers: [1, 2] } },
          uniform3f: { 4: { numbers: [1, 2, 3] } },
          uniform4f: { 5: { numbers: [1, 2, 3, 4] } },
          uniform1i: { 2: { numbers: [1] } },
          uniform2i: { 3: { numbers: [1, 2] } },
          uniform3i: { 4: { numbers: [1, 2, 3] } },
          uniform4i: { 5: { numbers: [1, 2, 3, 4] } },
          uniform1fv: {
            2: { arrays: { 1: pe(1) } },
            3: { arrays: { 1: _e(1) }, numbers: [2] },
            4: { arrays: { 1: me(1) }, numbers: [2, 3] }
          },
          uniform2fv: {
            2: { arrays: { 1: pe(2) } },
            3: { arrays: { 1: _e(2) }, numbers: [2] },
            4: { arrays: { 1: me(2) }, numbers: [2, 3] }
          },
          uniform3fv: {
            2: { arrays: { 1: pe(3) } },
            3: { arrays: { 1: _e(3) }, numbers: [2] },
            4: { arrays: { 1: me(3) }, numbers: [2, 3] }
          },
          uniform4fv: {
            2: { arrays: { 1: pe(4) } },
            3: { arrays: { 1: _e(4) }, numbers: [2] },
            4: { arrays: { 1: me(4) }, numbers: [2, 3] }
          },
          uniform1iv: {
            2: { arrays: { 1: pe(1) } },
            3: { arrays: { 1: _e(1) }, numbers: [2] },
            4: { arrays: { 1: me(1) }, numbers: [2, 3] }
          },
          uniform2iv: {
            2: { arrays: { 1: pe(2) } },
            3: { arrays: { 1: _e(2) }, numbers: [2] },
            4: { arrays: { 1: me(2) }, numbers: [2, 3] }
          },
          uniform3iv: {
            2: { arrays: { 1: pe(3) } },
            3: { arrays: { 1: _e(3) }, numbers: [2] },
            4: { arrays: { 1: me(3) }, numbers: [2, 3] }
          },
          uniform4iv: {
            2: { arrays: { 1: pe(4) } },
            3: { arrays: { 1: _e(4) }, numbers: [2] },
            4: { arrays: { 1: me(4) }, numbers: [2, 3] }
          },
          uniformMatrix2fv: {
            3: { arrays: { 2: pe(4) } },
            4: { arrays: { 2: _e(4) }, numbers: [3] },
            5: { arrays: { 2: me(4) }, numbers: [3, 4] }
          },
          uniformMatrix3fv: {
            3: { arrays: { 2: pe(9) } },
            4: { arrays: { 2: _e(9) }, numbers: [3] },
            5: { arrays: { 2: me(9) }, numbers: [3, 4] }
          },
          uniformMatrix4fv: {
            3: { arrays: { 2: pe(16) } },
            4: { arrays: { 2: _e(16) }, numbers: [3] },
            5: { arrays: { 2: me(16) }, numbers: [3, 4] }
          },
          uniform1ui: { 2: { numbers: [1] } },
          // WebGL2
          uniform2ui: { 3: { numbers: [1, 2] } },
          // WebGL2
          uniform3ui: { 4: { numbers: [1, 2, 3] } },
          // WebGL2
          uniform4ui: { 5: { numbers: [1, 2, 3, 4] } },
          // WebGL2
          uniform1uiv: {
            // WebGL2
            2: { arrays: { 1: pe(1) } },
            3: { arrays: { 1: _e(1) }, numbers: [2] },
            4: { arrays: { 1: me(1) }, numbers: [2, 3] }
          },
          uniform2uiv: {
            // WebGL2
            2: { arrays: { 1: pe(2) } },
            3: { arrays: { 1: _e(2) }, numbers: [2] },
            4: { arrays: { 1: me(2) }, numbers: [2, 3] }
          },
          uniform3uiv: {
            // WebGL2
            2: { arrays: { 1: pe(3) } },
            3: { arrays: { 1: _e(3) }, numbers: [2] },
            4: { arrays: { 1: me(3) }, numbers: [2, 3] }
          },
          uniform4uiv: {
            // WebGL2
            2: { arrays: { 1: pe(4) } },
            3: { arrays: { 1: _e(4) }, numbers: [2] },
            4: { arrays: { 1: me(4) }, numbers: [2, 3] }
          },
          uniformMatrix3x2fv: {
            // WebGL2
            3: { arrays: { 2: pe(6) } },
            4: { arrays: { 2: _e(6) }, numbers: [3] },
            5: { arrays: { 2: me(6) }, numbers: [3, 4] }
          },
          uniformMatrix4x2fv: {
            // WebGL2
            3: { arrays: { 2: pe(8) } },
            4: { arrays: { 2: _e(8) }, numbers: [3] },
            5: { arrays: { 2: me(8) }, numbers: [3, 4] }
          },
          uniformMatrix2x3fv: {
            // WebGL2
            3: { arrays: { 2: pe(6) } },
            4: { arrays: { 2: _e(6) }, numbers: [3] },
            5: { arrays: { 2: me(6) }, numbers: [3, 4] }
          },
          uniformMatrix4x3fv: {
            // WebGL2
            3: { arrays: { 2: pe(12) } },
            4: { arrays: { 2: _e(12) }, numbers: [3] },
            5: { arrays: { 2: me(12) }, numbers: [3, 4] }
          },
          uniformMatrix2x4fv: {
            // WebGL2
            3: { arrays: { 2: pe(8) } },
            4: { arrays: { 2: _e(8) }, numbers: [3] },
            5: { arrays: { 2: me(8) }, numbers: [3, 4] }
          },
          uniformMatrix3x4fv: {
            // WebGL2
            3: { arrays: { 2: pe(12) } },
            4: { arrays: { 2: _e(12) }, numbers: [3] },
            5: { arrays: { 2: me(12) }, numbers: [3, 4] }
          },
          // attribute value setters
          vertexAttrib1f: { 2: { numbers: [0, 1] } },
          vertexAttrib2f: { 3: { numbers: [0, 1, 2] } },
          vertexAttrib3f: { 4: { numbers: [0, 1, 2, 3] } },
          vertexAttrib4f: { 5: { numbers: [0, 1, 2, 3, 4] } },
          vertexAttrib1fv: { 2: { numbers: [0], arrays: [1] } },
          vertexAttrib2fv: { 2: { numbers: [0], arrays: [1] } },
          vertexAttrib3fv: { 2: { numbers: [0], arrays: [1] } },
          vertexAttrib4fv: { 2: { numbers: [0], arrays: [1] } },
          vertexAttribI4i: { 5: { numbers: [0, 1, 2, 3, 4] } },
          // WebGL2
          vertexAttribI4iv: { 2: { numbers: [0], arrays: [1] } },
          // WebGL2
          vertexAttribI4ui: { 5: { numbers: [0, 1, 2, 3, 4] } },
          // WebGL2
          vertexAttribI4uiv: { 2: { numbers: [0], arrays: [1] } },
          // WebGL2
          // QueryObjects
          beginQuery: { 2: { enums: [0] } },
          // WebGL2
          endQuery: { 1: { enums: [0] } },
          // WebGL2
          getQuery: { 2: { enums: [0, 1] } },
          // WebGL2
          getQueryParameter: { 2: { enums: [1] } },
          // WebGL2
          //  Sampler Objects
          samplerParameteri: { 3: { enums: [1] } },
          // WebGL2
          samplerParameterf: { 3: { enums: [1] } },
          // WebGL2
          getSamplerParameter: { 2: { enums: [1] } },
          // WebGL2
          //  Sync objects
          clientWaitSync: { 3: { enums: { 1: u(["SYNC_FLUSH_COMMANDS_BIT"]) }, numbers: [2] } },
          // WebGL2
          fenceSync: { 2: { enums: [0] } },
          // WebGL2
          getSyncParameter: { 2: { enums: [1] } },
          // WebGL2
          //  Transform Feedback
          bindTransformFeedback: { 2: { enums: [0], undef: [1] } },
          // WebGL2
          beginTransformFeedback: { 1: { enums: [0] } },
          // WebGL2
          // Uniform Buffer Objects and Transform Feedback Buffers
          bindBufferBase: { 3: { enums: [0], numbers: [1] } },
          // WebGL2
          bindBufferRange: { 5: { enums: [0], numbers: [1, 3, 4] } },
          // WebGL2
          getIndexedParameter: { 2: { enums: [0], numbers: [1] } },
          // WebGL2
          getActiveUniforms: { 3: { enums: [2] }, arrays: [1] },
          // WebGL2
          getActiveUniformBlockParameter: { 3: { enums: [2], numbers: [1] } },
          // WebGL2
          getActiveUniformBlockName: { 2: { numbers: [1] } },
          // WebGL2
          transformFeedbackVaryings: { 3: { enums: [2] } },
          // WebGL2
          uniformBlockBinding: { 3: { numbers: [1, 2] } }
          // WebGL2
        };
        for (const [a, l] of Object.entries(we)) {
          for (const f of Object.values(l))
            cn(f, "enums"), cn(f, "numbers"), cn(f, "arrays"), cn(f, "undef");
          /uniform(\d|Matrix)/.test(a) && (l.errorHelper = Uu);
        }
        const P = {}, O = {};
        function w(a) {
          const l = he.get(a);
          l && l.forEach((f) => ie.delete(f)), he.set(a, /* @__PURE__ */ new Set()), Te.delete(a), Ae.delete(a), be.delete(a);
        }
        function R() {
          for (const { ctx: a, origFuncs: l } of Object.values(k))
            Object.assign(a, l), kn.delete(a);
          U.apis.gman_debug_helper._checksRemoved = !0;
          for (const a of [...Object.keys(U)])
            delete U[a];
        }
        function B(a, l, f) {
          const { vertCount: d, instances: p } = Br(l, f);
          d === 0 && console.warn(ln(a, l, f, `count for ${l} is 0!`)), p === 0 && console.warn(ln(a, l, f, `instanceCount for ${l} is 0!`)), --N.maxDrawCalls, N.maxDrawCalls === 0 && R();
        }
        function X() {
        }
        function V(a) {
          return function(l, f, d, p) {
            if (N.makeDefaultTags) {
              const x = (bt[a] || 0) + 1;
              bt[a] = x, je.set(p, `*UNTAGGED:${a}${x}*`);
            }
          };
        }
        function te(a) {
          const l = wa(new Error().stack), f = l ? `${l.url}:${l.lineNo}: ${a}` : a;
          if (N.throwOnError)
            throw new Error(f);
          console.error(f);
        }
        function J(a, l, f) {
          a ? te(f) : l && console.warn(f);
        }
        function Z(a) {
          return typeof a == "number";
        }
        const ve = 34229;
        function de() {
          const a = M;
          return typeof WebGL2RenderingContext < "u" && a instanceof WebGL2RenderingContext || k.oes_vertex_array_object ? a.getParameter(ve) : null;
        }
        function De(a, l, f) {
          if (!N.failUnsetUniforms)
            return;
          const d = Te.get(K.currentProgram);
          if (d) {
            const p = [];
            for (const [x, { index: A, unset: S }] of d)
              S.has(A) && p.push(x);
            ne(a, l, f, `uniforms "${p.join('", "')}" have not been set
    See docs at https://github.com/greggman/webgl-lint/ for how to turn off this check using "failUnsetUniforms": false`);
          }
        }
        function Se(a, l, f) {
          return l > 1 || f > 1 ? `${a}[${f}]` : a;
        }
        function ut(a, l, f) {
          if (!N.failUnrenderableTextures)
            return;
          const d = be.get(K.currentProgram), p = fe.numTextureUnits;
          for (const { type: x, values: A, name: S } of d) {
            const F = aa(x);
            for (let C = 0; C < A.length; ++C) {
              const G = A[C];
              if (G >= p) {
                ne(a, l, f, `uniform ${It(x).name} ${Se(S, A.length, C)} is set to ${G} which is out of range. There are only ${p} texture units`);
                return;
              }
              const ee = fe.getTextureUnitUnrenderableReason(x, G, F, Xe);
              if (ee) {
                const re = fe.getTextureForTextureUnit(G, F);
                ne(
                  a,
                  l,
                  f,
                  re ? `texture ${Xe(re)} on texture unit ${G} referenced by uniform ${zr(x)} ${Se(S, A.length, C)} is not renderable: ${ee}` : `no texture on texture unit ${G} referenced by uniform ${Se(S, A.length, C)}`
                );
                return;
              }
            }
          }
        }
        function Ke(a, l, f) {
          const d = be.get(K.currentProgram), p = /* @__PURE__ */ new Map();
          for (const { type: x, values: A, name: S } of d) {
            const F = A[0], C = p.get(F);
            if (!C)
              p.set(F, x);
            else if (C !== x) {
              ne(a, l, f, `Two textures of different types can't use the same sampler location. uniform ${It(x).name} ${Se(S, A.length, 0)} is not ${It(C).name}`);
              return;
            }
          }
        }
        function xe(a, l, f) {
          if (!K.currentProgram) {
            ne(a, l, f, "no current program");
            return;
          }
          De(a, l, f), ut(a, l, f), Ke(a, l, f);
        }
        function Fe(a, l, f) {
          const [d, p, x, A = 0, S = 0] = f, F = M.getBufferParameter(d, a.BUFFER_SIZE), C = x instanceof DataView || x instanceof ArrayBuffer, G = S || (C ? x.byteLength - A : x.length - A);
          if (F < p + G) {
            const ee = wr(d), re = M.getParameter(ee);
            ne(
              a,
              l,
              f,
              F === 0 ? `buffer ${Xe(re)} has 0 size. You need to call bufferData before calling bufferSubData.` : `buffer ${Xe(re)} buffer is too small for data [bufferSize:${F} dstByteOffset(${p}) + copyLength(${G}) = ${p + G}]`
            );
          }
        }
        const Je = {
          bufferSubData: Fe,
          drawArrays: xe,
          drawElements: xe,
          drawArraysInstanced: xe,
          drawElementsInstanced: xe,
          drawArraysInstancedANGLE: xe,
          drawElementsInstancedANGLE: xe,
          drawRangeElements: xe
        };
        function Ge(a, l) {
          if (!a) {
            J(N.failUndefinedUniforms, N.warnUndefinedUniforms, `attempt to set non-existent uniform on ${Xe(K.currentProgram)}
    See docs at https://github.com/greggman/webgl-lint/ for how to turn off this check using "warnUndefinedUniforms: false"`);
            return;
          }
          const f = Te.get(K.currentProgram);
          if (!f)
            return;
          const d = ie.get(a), p = f.get(d);
          if (p) {
            for (let x = 0; x < l; ++x)
              p.unset.delete(p.index + x);
            if (!p.unset.size) {
              for (const [x] of p.altNames)
                f.delete(x);
              f.size || Te.delete(K.currentProgram);
            }
          }
        }
        function ae(a) {
          return function(l, f, d) {
            const [p, x, A = 0, S = 0] = d, F = S || x.length - A;
            Ge(p, F / a | 0);
          };
        }
        function xt(a) {
          return H.has(a);
        }
        function ct(a) {
          return xt(ie.get(a));
        }
        function He(a, l) {
          const [f, d] = l;
          return e(a) && a.getUniformIndices(f, [d])[0] !== a.INVALID_INDEX;
        }
        function tt(a) {
          return function(l, f, d) {
            const [p, x, A, S = 0, F = 0] = d, G = (F || A.length - S) / a | 0;
            if (N.failZeroMatrixUniforms && !ct(p))
              for (let ee = 0; ee < G; ++ee) {
                let re = !0;
                const ft = S + a * ee;
                for (let Ce = 0; Ce < a; ++Ce)
                  if (A[ft + Ce]) {
                    re = !1;
                    break;
                  }
                if (re) {
                  ne(l, f, [p, x, ...d], `matrix is all zeros
    See docs at https://github.com/greggman/webgl-lint/ for how to turn off this check using "failZeroMatrixUniforms": false`);
                  return;
                }
              }
            Ge(p, G);
          };
        }
        function Ou(a) {
          const l = ae(a);
          return function(f, d, p) {
            l(f, d, p);
            const [x, A] = p;
            Co(x, A);
          };
        }
        function Le(a, l, f) {
          const [d] = f;
          Ge(d, 1);
        }
        function Lu(a, l, f) {
          Le(a, l, f);
          const [d, p] = f;
          Co(d, [p]);
        }
        function Co(a, l) {
          const f = ie.get(a), d = Ae.get(K.currentProgram), { index: p, type: x, values: A } = d.get(f);
          if (!jt(x))
            return;
          const S = Math.min(l.length, A.length - p);
          for (let F = 0; F < S; ++F)
            A[F] = l[F];
        }
        function Qe(a, l, f) {
          const [d] = f;
          je.delete(d);
        }
        const ku = /ERROR:\s*\d+:(\d+)/gi;
        function No(a, l = "") {
          const f = [...l.matchAll(ku)], d = new Map(f.map((p, x) => {
            const A = parseInt(p[1]), S = f[x + 1], F = S ? S.index : l.length, C = l.substring(p.index, F);
            return [A - 1, C];
          }));
          return a.split(`
    `).map((p, x) => {
            const A = d.get(x);
            return `${x + 1}: ${p}${A ? `

    ^^^ ${A}` : ""}`;
          }).join(`
    `);
        }
        const $n = {
          enable(a, l, f) {
            const [d] = f;
            K.enabled[d] ? ++se.enableDisable : K.enabled[d] = !0;
          },
          disable(a, l, f) {
            const [d] = f;
            K.enabled[d] ? K.enabled[d] = !1 : ++se.enableDisable;
          },
          bindBuffer(a, l, f) {
            const [d, p] = f;
            switch (d) {
              case a.ELEMENT_ARRAY_BUFFER:
                break;
              default:
                ot(K.buffers[d], p) ? ++se.bindBuffer : K.buffers[d] = rt(p);
            }
          },
          bindFramebuffer(a, l, f) {
            const [d, p] = f;
            switch (d) {
              case a.READ_FRAMEBUFFER:
                ot(K.currentReadFramebuffer, p) ? ++se.bindFramebuffer : K.currentReadFramebuffer = rt(p);
                break;
              case a.DRAW_FRAMEBUFFER:
                ot(K.currentDrawFramebuffer, p) ? ++se.bindFramebuffer : K.currentDrawFramebuffer = rt(p);
                break;
              case a.FRAMEBUFFER:
                ot(K.currentDrawFramebuffer, p) && ot(K.currentDrawFramebuffer, p) ? ++se.bindFramebuffer : (K.currentDrawFramebuffer = rt(p), K.currentReadFramebuffer = rt(p));
            }
          },
          bindRenderbuffer(a, l, f) {
            const [, d] = f;
            ot(K.currentRenderbuffer, d) ? ++se.bindRenderbuffer : K.currentRenderbuffer = rt(d);
          },
          // WebGL1
          //   void bufferData(GLenum target, GLsizeiptr size, GLenum usage);
          //   void bufferData(GLenum target, [AllowShared] BufferSource? srcData, GLenum usage);
          // WebGL2:
          //   void bufferData(GLenum target, [AllowShared] ArrayBufferView srcData, GLenum usage, GLuint srcOffset,
          //                   optional GLuint length = 0);
          bufferData(a, l, f) {
            const [
              d,
              p,
              /* usage */
              ,
              x = 0,
              A = 0
            ] = f;
            if (d !== a.ELEMENT_ARRAY_BUFFER)
              return;
            const S = M.getParameter(a.ELEMENT_ARRAY_BUFFER_BINDING);
            if (Z(p))
              $.set(S, new ArrayBuffer(p));
            else {
              const F = p instanceof DataView, C = A || (F ? p.byteLength - x : p.length - x), G = F ? 1 : p.BYTES_PER_ELEMENT, ee = C * G, re = p.buffer ? p.buffer : p, Ce = (p.byteOffset || 0) + x * G;
              $.set(S, re.slice(Ce, Ce + ee));
            }
          },
          // WebGL1
          //   void bufferSubData(GLenum target, GLintptr dstByteOffset, [AllowShared] BufferSource srcData);
          // WebGL2
          //   void bufferSubData(GLenum target, GLintptr dstByteOffset, [AllowShared] ArrayBufferView srcData,
          //                      GLuint srcOffset, optional GLuint length = 0);
          bufferSubData(a, l, f) {
            const [d, p, x, A = 0, S = 0] = f;
            if (d !== a.ELEMENT_ARRAY_BUFFER)
              return;
            const F = M.getParameter(a.ELEMENT_ARRAY_BUFFER_BINDING), C = $.get(F), G = new Uint8Array(C), ee = x instanceof DataView, re = S || (ee ? x.byteLength - A : x.length - A), ft = ee ? 1 : x.BYTES_PER_ELEMENT, Ce = re * ft, Dt = x.buffer ? x.buffer : x, Pt = (x.byteOffset || 0) + A * ft, lt = new Uint8Array(Dt, Pt, Ce);
            G.set(lt, p);
          },
          compileShader(a, l, f) {
            if (!N.failBadShadersAndPrograms)
              return;
            const [d] = f;
            if (!M.getShaderParameter(d, a.COMPILE_STATUS)) {
              const x = M.getShaderInfoLog(d), A = No(M.getShaderSource(d), x), S = M.getShaderParameter(d, a.SHADER_TYPE), F = `failed to compile ${g(S)}: ${x}
    ------[ shader source ]------
    ${A}`;
              ne(a, l, f, F);
            }
          },
          createBuffer: V("Buffer"),
          createFramebuffer: V("Framebuffer"),
          createProgram: V("Program"),
          createQuery: V("Query"),
          createRenderbuffer: V("Renderbuffer"),
          createShader: V("Shader"),
          createTexture: V("Texture"),
          createTransformFeedback: V("TransformFeedback"),
          createSampler: V("Sampler"),
          createVertexArray: V("VertexArray"),
          createVertexArrayOES: V("VertexArray"),
          drawArrays: B,
          drawElements: B,
          drawArraysInstanced: B,
          drawElementsInstanced: B,
          drawArraysInstancedANGLE: B,
          drawElementsInstancedANGLE: B,
          drawRangeElements: B,
          fenceSync: V("Sync"),
          uniform1f: Le,
          uniform2f: Le,
          uniform3f: Le,
          uniform4f: Le,
          uniform1i: Lu,
          uniform2i: Le,
          uniform3i: Le,
          uniform4i: Le,
          uniform1fv: ae(1),
          uniform2fv: ae(2),
          uniform3fv: ae(3),
          uniform4fv: ae(4),
          uniform1iv: Ou(1),
          uniform2iv: ae(2),
          uniform3iv: ae(3),
          uniform4iv: ae(4),
          uniformMatrix2fv: tt(4),
          uniformMatrix3fv: tt(9),
          uniformMatrix4fv: tt(16),
          uniform1ui: Le,
          uniform2ui: Le,
          uniform3ui: Le,
          uniform4ui: Le,
          uniform1uiv: ae(1),
          uniform2uiv: ae(2),
          uniform3uiv: ae(3),
          uniform4uiv: ae(4),
          uniformMatrix3x2fv: tt(6),
          uniformMatrix4x2fv: tt(8),
          uniformMatrix2x3fv: tt(6),
          uniformMatrix4x3fv: tt(12),
          uniformMatrix2x4fv: tt(8),
          uniformMatrix3x4fv: tt(12),
          getSupportedExtensions(a, l, f, d) {
            d.push("GMAN_debug_helper");
          },
          getUniformLocation(a, l, f, d) {
            const [p, x] = f;
            d ? (ie.set(d, x), he.get(p).add(d)) : !xt(x) && !He(a, f) && Xu(
              a,
              l,
              f,
              `uniform '${x}' does not exist in ${Xe(p)}`,
              N.failUndefinedUniforms,
              N.warnUndefinedUniforms
            );
          },
          linkProgram(a, l, f) {
            const [d] = f;
            if (M.getProgramParameter(d, a.LINK_STATUS)) {
              w(d);
              const x = /* @__PURE__ */ new Map(), A = /* @__PURE__ */ new Map(), S = [], F = M.getProgramParameter(d, a.ACTIVE_UNIFORMS);
              for (let C = 0; C < F; ++C) {
                const { name: G, type: ee, size: re } = s.getActiveUniform(d, C);
                if (t(G) || !M.getUniformLocation(d, G))
                  continue;
                const Ce = /* @__PURE__ */ new Map([[G, 0]]), Dt = G.endsWith("[0]");
                let St = G;
                if (Dt && (St = G.substr(0, G.length - 3), Ce.set(St, 0)), re > 1)
                  for (let Ie = 0; Ie < re; ++Ie)
                    Ce.set(`${St}[${Ie}]`, Ie);
                const Pt = (!jt(ee) || N.failUnsetSamplerUniforms) && !H.has(G), lt = jt(ee) ? new Array(re).fill(0) : void 0;
                lt && S.push({ type: ee, values: lt, name: St });
                const Gn = new Set(Ju(0, re));
                for (const [Ie, Po] of Ce)
                  Pt && x.set(Ie, {
                    index: Po,
                    unset: Gn,
                    altNames: Ce
                  }), A.set(Ie, {
                    index: Po,
                    type: ee,
                    size: re,
                    ...lt && { values: lt }
                  });
              }
              be.set(d, S), Ae.set(d, A), x.size && Te.set(d, x);
            } else if (N.failBadShadersAndPrograms) {
              const A = M.getAttachedShaders(d).map((C) => {
                const G = No(M.getShaderSource(C)), ee = M.getShaderParameter(C, a.SHADER_TYPE);
                return `-------[ ${g(ee)} ${Xe(C)} ]-------
    ${G}`;
              }).join(`
    `), F = `failed to link program: ${M.getProgramInfoLog(d)}
    ${A}`;
              ne(a, l, f, F);
            }
          },
          useProgram(a, l, f) {
            const [d] = f;
            K.currentProgram === d ? ++se.useProgram : K.currentProgram = d;
          },
          deleteProgram(a, l, f) {
            const [d] = f;
            K.currentProgram === d && (K.currentProgram = void 0), w(d);
          },
          deleteBuffer(a, l, f) {
            const [d] = f;
            $.delete(d);
          },
          deleteFramebuffer: Qe,
          deleteRenderbuffer: Qe,
          deleteTexture: Qe,
          deleteShader: Qe,
          deleteQuery: Qe,
          deleteSampler: Qe,
          deleteSync: Qe,
          deleteTransformFeedback: Qe,
          deleteVertexArray: Qe,
          deleteVertexArrayOES: Qe
        };
        [fe, et].forEach((a) => {
          Object.entries(a.postChecks).forEach(([l, f]) => {
            const d = $n[l] || X;
            $n[l] = function(...p) {
              d(...p), N.failUnrenderableTextures && f(...p);
            };
          });
        });
        function Xe(a) {
          const l = je.get(a) || "*unnamed*";
          return `${a.constructor.name}(${o(l)})`;
        }
        function $u(a) {
          return $.get(a);
        }
        function zu(a, l, f, d, p) {
          const x = je.get(p);
          if (x)
            return `${p.constructor.name}("${x}")`;
          if (p instanceof WebGLUniformLocation)
            return `WebGLUniformLocation("${ie.get(p)}")`;
          const A = we[l];
          if (A !== void 0) {
            const S = A[f];
            if (S !== void 0) {
              const F = S.enums;
              if (F) {
                const C = F[d];
                if (C !== void 0) {
                  if (typeof C == "function")
                    return C(a, p);
                  if (!l.startsWith("bind") && d === 0) {
                    const G = wr(p);
                    if (G) {
                      const ee = M.getParameter(G);
                      if (ee)
                        return `${g(p)}{${Xe(ee)}}`;
                    }
                  }
                  return g(p);
                }
              }
            }
          }
          return p === null ? "null" : p === void 0 ? "undefined" : Array.isArray(p) || n(p) ? p.length <= 32 ? `[${Array.from(p.slice(0, 32)).join(", ")}]` : `${p.constructor.name}(${p.length !== void 0 ? p.length : p.byteLength})` : p.toString();
        }
        function Bt(a, l, f, d, p, x, A) {
          if (!n(d)) {
            ne(a, l, f, `argument ${p} must be a TypedArray`);
            return;
          }
          if (!r(d))
            return;
          const S = x, F = x + A;
          for (let C = S; C < F; ++C)
            if (d[C] === void 0) {
              ne(a, l, f, `element ${C} of argument ${p} is undefined`);
              return;
            } else if (isNaN(d[C])) {
              ne(a, l, f, `element ${C} of argument ${p} is NaN`);
              return;
            }
        }
        function zn(a, l, f, d, p) {
          const x = f[f.length - 1], A = d.length - x;
          Bt(a, l, f, d, p, x, A);
        }
        function Vu(a, l, f, d, p) {
          if (n(d) && r(d)) {
            const A = d.length - 0;
            Bt(a, l, f, d, p, 0, A);
          } else
            Array.isArray(d) && ne(a, l, f, `argument ${p} is not an ArrayBufferView or ArrayBuffer`);
        }
        function Bo(a, l, f, d, p) {
          if (n(d) && r(d)) {
            const x = f[f.length - 1], A = d.length - x;
            Bt(a, l, f, d, p, x, A);
          } else
            Array.isArray(d) && ne(a, l, f, `argument ${p} is not an ArrayBufferView or ArrayBuffer`);
        }
        function Do(a, l, f, d, p) {
          if (n(d) && r(d)) {
            const x = f[f.length - 2], A = f[f.length - 1];
            Bt(a, l, f, d, p, x, A);
          } else
            Array.isArray(d) && ne(a, l, f, `argument ${p} is not an ArrayBufferView or ArrayBuffer`);
        }
        function Gu(a, l, f, d, p) {
          if (Array.isArray(d) || n(d)) {
            const x = f[f.length - 1], A = d.length - x;
            Bt(a, l, f, d, p, x, A);
          }
        }
        function Vn(a, l, f, d, p, x, A, S) {
          const F = f[0];
          if (!F)
            return;
          const C = Ae.get(K.currentProgram);
          if (!C)
            return;
          const G = ie.get(F), { type: ee, size: re, index: ft } = C.get(G), Ce = It(ee).size;
          S !== Ce && ne(a, l, f, `uniform "${G}" is ${It(ee).name} which is wrong for ${l}`);
          const Dt = re - ft, Pt = Math.min(A / S | 0, Dt) * S, lt = x, Gn = x + Pt;
          for (let Ie = lt; Ie < Gn; ++Ie)
            if (d[Ie] === void 0) {
              ne(a, l, f, `element ${Ie} of argument ${p} is undefined`);
              return;
            } else if (Yu(d[Ie])) {
              ne(a, l, f, `element ${Ie} of argument ${p} is an array. WebGL expects flat arrays`);
              return;
            } else if (isNaN(d[Ie])) {
              ne(a, l, f, `element ${Ie} of argument ${p} is NaN`);
              return;
            }
        }
        function me(a) {
          return function(l, f, d, p, x) {
            const A = d[d.length - 2], S = d[d.length - 1];
            Vn(l, f, d, p, x, A, S, a);
          };
        }
        function _e(a) {
          return function(l, f, d, p, x) {
            const A = d[d.length - 1], S = p.length - A;
            Vn(l, f, d, p, x, A, S, a);
          };
        }
        function pe(a) {
          return function(l, f, d, p, x) {
            const S = p.length;
            Vn(l, f, d, p, x, 0, S, a);
          };
        }
        function Hu(a, l, f) {
          const d = f.length;
          return f.map(function(x, A) {
            let S = zu(a, l, d, A, x);
            return S.length > 200 && (S = S.substring(0, 200) + "..."), S;
          }).join(", ");
        }
        function ln(a, l, f, d) {
          const p = M, x = [d], A = we[l];
          if (A && A.errorHelper && x.push(A.errorHelper(a, l, f, U)), l.includes("draw")) {
            const F = p.getParameter(p.CURRENT_PROGRAM);
            F ? x.push(`with ${Xe(F)} as current program`) : x.push("no shader program in use!");
          }
          if (l.includes("vertexAttrib") || Nn(l)) {
            const F = de(), C = je.get(F), G = `WebGLVertexArrayObject(${o(C || "*unnamed*")})`;
            x.push(`with ${F ? G : "the default vertex array"} bound`);
          }
          const S = Hu(a, l, f);
          return `error in ${l}(${S}): ${x.join(`
    `)}`;
        }
        function Xu(a, l, f, d, p, x) {
          J(p, x, ln(a, l, f, d));
        }
        function ne(a, l, f, d) {
          te(ln(a, l, f, d));
        }
        const Yu = (a) => Array.isArray(a) || n(a);
        function Wu(a, l, f) {
          const d = we[l];
          if (d) {
            const p = d[f.length];
            if (p) {
              const { numbers: x = {}, arrays: A = {}, undef: S = {} } = p;
              for (let F = 0; F < f.length; ++F) {
                const C = f[F];
                if (C === void 0 && !S[F]) {
                  ne(a, l, f, `argument ${F} is undefined`);
                  return;
                }
                if (x[F] !== void 0) {
                  if (x[F] >= 0) {
                    if (typeof C != "number" && !(C instanceof Number) && C !== !1 && C !== !0 || isNaN(C)) {
                      ne(a, l, f, `argument ${F} is not a number`);
                      return;
                    }
                  } else if (!(C instanceof Object) && isNaN(C)) {
                    ne(a, l, f, `argument ${F} is NaN`);
                    return;
                  }
                }
                const G = A[F];
                if (G !== void 0) {
                  const ee = Array.isArray(C) || n(C);
                  if (G >= 0 && !ee) {
                    ne(a, l, f, `argument ${F} is not an array or typedarray`);
                    return;
                  }
                  if (ee && r(C)) {
                    if (typeof G == "function")
                      G(a, l, f, C, F);
                    else
                      for (let re = 0; re < C.length; ++re)
                        if (C[re] === void 0) {
                          ne(a, l, f, `element ${re} of argument ${F} is undefined`);
                          return;
                        } else if (isNaN(C[re])) {
                          ne(a, l, f, `element ${re} of argument ${F} is NaN`);
                          return;
                        }
                  }
                }
              }
            } else {
              ne(a, l, f, `no version of function '${l}' takes ${f.length} arguments`);
              return;
            }
          }
        }
        const ju = {
          getExtension(a, l) {
            const f = a[l];
            a[l] = function(...d) {
              const p = d[0].toLowerCase(), x = k[p];
              if (x)
                return x.ctx;
              const A = f.call(a, ...d);
              return A && Fo(A, p, { ...E, origGLErrorFn: v }), A;
            };
          }
        };
        function Ku(a, l) {
          const f = a[l], d = Je[l] || X, p = $n[l] || X;
          a[l] = function(...A) {
            if (d(a, l, A), Wu(a, l, A), K.currentProgram && Nn(l)) {
              const G = Zs(M, l, A, Xe, $u);
              G.length && ne(a, l, A, G.join(`
    `));
            }
            const S = f.call(a, ...A), F = M, C = v.call(F);
            if (C !== 0) {
              P[C] = !0;
              const G = [g(C)];
              Nn(l) && K.currentProgram && G.push(...Sa(F, Xe)), ne(a, l, A, G.join(`
    `));
            } else
              p(a, l, A, S);
            return S;
          };
          const x = ju[l];
          x && x(a, l, v);
        }
        function Ju(a, l) {
          const f = [];
          for (let d = a; d < l; ++d)
            f.push(d);
          return f;
        }
        for (const a in s)
          typeof s[a] == "function" && (O[a] = s[a], Ku(s, a));
        s.getError && (s.getError = function() {
          for (const a of Object.keys(P))
            if (P[a])
              return P[a] = !1, a;
          return s.NO_ERROR;
        }), k[h.toLowerCase()] = { ctx: s, origFuncs: O };
      }
      console.log("webgl-lint running");
      function Io(s) {
        const h = s.prototype.getContext;
        s.prototype.getContext = function(E, ...v) {
          const I = h.call(this, E, ...v);
          if (I && I.bindTexture) {
            Fo(I, E, {
              maxDrawCalls: 1e3,
              throwOnError: !0,
              failBadShadersAndPrograms: !0,
              failUnsetUniforms: !0,
              failUnsetSamplerUniforms: !1,
              failZeroMatrixUniforms: !0,
              failUnrenderableTextures: !0,
              failUndefinedUniforms: !1,
              warnUndefinedUniforms: !0,
              makeDefaultTags: !0,
              ignoreUniforms: []
            });
            const k = I.getExtension("GMAN_debug_helper");
            document.querySelectorAll("[data-gman-debug-helper]").forEach((M) => {
              const $ = M.dataset.gmanDebugHelper;
              let N;
              try {
                N = JSON.parse($);
              } catch (H) {
                throw H.message += `
    ${$}
    failed to parse data-gman-debug-helper as JSON in: ${M.outerHTML}`, H;
              }
              N && k.setConfiguration(N);
            });
          }
          return I;
        };
      }
      typeof HTMLCanvasElement < "u" && Io(HTMLCanvasElement), typeof OffscreenCanvas < "u" && Io(OffscreenCanvas);
    });
    /* @license twgl.js 5.5.4 Copyright (c) 2015, Gregg Tavares All Rights Reserved.
    Available via the MIT license.
    see: http://github.com/greggman/twgl.js for details */
    const rr = 5120, Gt = 5121, or = 5122, ir = 5123, sr = 5124, ar = 5125, ur = 5126, Qu = 32819, Zu = 32820, qu = 33635, ec = 5131, tc = 33640, nc = 35899, rc = 35902, oc = 36269, ic = 34042, ni = {};
    {
      const t = ni;
      t[rr] = Int8Array, t[Gt] = Uint8Array, t[or] = Int16Array, t[ir] = Uint16Array, t[sr] = Int32Array, t[ar] = Uint32Array, t[ur] = Float32Array, t[Qu] = Uint16Array, t[Zu] = Uint16Array, t[qu] = Uint16Array, t[ec] = Uint16Array, t[tc] = Uint32Array, t[nc] = Uint32Array, t[rc] = Uint32Array, t[oc] = Uint32Array, t[ic] = Uint32Array;
    }
    function ri(t) {
      if (t instanceof Int8Array)
        return rr;
      if (t instanceof Uint8Array || t instanceof Uint8ClampedArray)
        return Gt;
      if (t instanceof Int16Array)
        return or;
      if (t instanceof Uint16Array)
        return ir;
      if (t instanceof Int32Array)
        return sr;
      if (t instanceof Uint32Array)
        return ar;
      if (t instanceof Float32Array)
        return ur;
      throw new Error("unsupported typed array type");
    }
    function oi(t) {
      if (t === Int8Array)
        return rr;
      if (t === Uint8Array || t === Uint8ClampedArray)
        return Gt;
      if (t === Int16Array)
        return or;
      if (t === Uint16Array)
        return ir;
      if (t === Int32Array)
        return sr;
      if (t === Uint32Array)
        return ar;
      if (t === Float32Array)
        return ur;
      throw new Error("unsupported typed array type");
    }
    function sc(t) {
      const e = ni[t];
      if (!e)
        throw new Error("unknown gl type");
      return e;
    }
    const jn = typeof SharedArrayBuffer < "u" ? function(e) {
      return e && e.buffer && (e.buffer instanceof ArrayBuffer || e.buffer instanceof SharedArrayBuffer);
    } : function(e) {
      return e && e.buffer && e.buffer instanceof ArrayBuffer;
    };
    function ac(...t) {
      console.error(...t);
    }
    const Uo = /* @__PURE__ */ new Map();
    function ii(t, e) {
      if (!t || typeof t != "object")
        return !1;
      let n = Uo.get(e);
      n || (n = /* @__PURE__ */ new WeakMap(), Uo.set(e, n));
      let r = n.get(t);
      if (r === void 0) {
        const o = Object.prototype.toString.call(t);
        r = o.substring(8, o.length - 1) === e, n.set(t, r);
      }
      return r;
    }
    function uc(t, e) {
      return typeof WebGLBuffer < "u" && ii(e, "WebGLBuffer");
    }
    function si(t, e) {
      return typeof WebGLTexture < "u" && ii(e, "WebGLTexture");
    }
    const ai = 35044, qe = 34962, cc = 34963, fc = 34660, lc = 5120, dc = 5121, mc = 5122, _c = 5123, pc = 5124, hc = 5125, ui = 5126, ci = {
      attribPrefix: ""
    };
    function fi(t, e, n, r, o) {
      t.bindBuffer(e, n), t.bufferData(e, r, o || ai);
    }
    function li(t, e, n, r) {
      if (uc(t, e))
        return e;
      n = n || qe;
      const o = t.createBuffer();
      return fi(t, n, o, e, r), o;
    }
    function di(t) {
      return t === "indices";
    }
    function bc(t) {
      return t === Int8Array || t === Uint8Array;
    }
    function xc(t) {
      return t.length ? t : t.data;
    }
    const yc = /coord|texture/i, Ec = /color|colour/i;
    function gc(t, e) {
      let n;
      if (yc.test(t) ? n = 2 : Ec.test(t) ? n = 4 : n = 3, e % n > 0)
        throw new Error(`Can not guess numComponents for attribute '${t}'. Tried ${n} but ${e} values is not evenly divisible by ${n}. You should specify it.`);
      return n;
    }
    function Ac(t, e, n) {
      return t.numComponents || t.size || gc(e, n || xc(t).length);
    }
    function cr(t, e) {
      if (jn(t))
        return t;
      if (jn(t.data))
        return t.data;
      Array.isArray(t) && (t = {
        data: t
      });
      let n = t.type ? fr(t.type) : void 0;
      return n || (di(e) ? n = Uint16Array : n = Float32Array), new n(t.data);
    }
    function Tc(t) {
      return typeof t == "number" ? t : t ? oi(t) : ui;
    }
    function fr(t) {
      return typeof t == "number" ? sc(t) : t || Float32Array;
    }
    function vc(t, e) {
      return {
        buffer: e.buffer,
        numValues: 2 * 3 * 4,
        // safely divided by 2, 3, 4
        type: Tc(e.type),
        arrayType: fr(e.type)
      };
    }
    function Sc(t, e) {
      const n = e.data || e, r = fr(e.type), o = n * r.BYTES_PER_ELEMENT, i = t.createBuffer();
      return t.bindBuffer(qe, i), t.bufferData(qe, o, e.drawType || ai), {
        buffer: i,
        numValues: n,
        type: oi(r),
        arrayType: r
      };
    }
    function Rc(t, e, n) {
      const r = cr(e, n);
      return {
        arrayType: r.constructor,
        buffer: li(t, r, void 0, e.drawType),
        type: ri(r),
        numValues: 0
      };
    }
    function wc(t, e) {
      const n = {};
      return Object.keys(e).forEach(function(r) {
        if (!di(r)) {
          const o = e[r], i = o.attrib || o.name || o.attribName || ci.attribPrefix + r;
          if (o.value) {
            if (!Array.isArray(o.value) && !jn(o.value))
              throw new Error("array.value is not array or typedarray");
            n[i] = {
              value: o.value
            };
          } else {
            let c;
            o.buffer && o.buffer instanceof WebGLBuffer ? c = vc : typeof o == "number" || typeof o.data == "number" ? c = Sc : c = Rc;
            const { buffer: u, type: m, numValues: b, arrayType: g } = c(t, o, r), T = o.normalize !== void 0 ? o.normalize : bc(g), z = Ac(o, r, b);
            n[i] = {
              buffer: u,
              numComponents: z,
              type: m,
              normalize: T,
              stride: o.stride || 0,
              offset: o.offset || 0,
              divisor: o.divisor === void 0 ? void 0 : o.divisor,
              drawType: o.drawType
            };
          }
        }
      }), t.bindBuffer(qe, null), n;
    }
    function Mo(t, e, n, r) {
      n = cr(n), r !== void 0 ? (t.bindBuffer(qe, e.buffer), t.bufferSubData(qe, r, n)) : fi(t, qe, e.buffer, n, e.drawType);
    }
    function Fc(t, e) {
      return e === lc || e === dc ? 1 : e === mc || e === _c ? 2 : e === pc || e === hc || e === ui ? 4 : 0;
    }
    const Hn = ["position", "positions", "a_position"];
    function Ic(t, e) {
      let n, r;
      for (r = 0; r < Hn.length && (n = Hn[r], !(n in e || (n = ci.attribPrefix + n, n in e))); ++r)
        ;
      r === Hn.length && (n = Object.keys(e)[0]);
      const o = e[n];
      if (!o.buffer)
        return 1;
      t.bindBuffer(qe, o.buffer);
      const i = t.getBufferParameter(qe, fc);
      t.bindBuffer(qe, null);
      const c = Fc(t, o.type), u = i / c, m = o.numComponents || o.size, b = u / m;
      if (b % 1 !== 0)
        throw new Error(`numComponents ${m} not correct for length ${length}`);
      return b;
    }
    function Xn(t, e, n) {
      const r = wc(t, e), o = Object.assign({}, n || {});
      o.attribs = Object.assign({}, n ? n.attribs : {}, r);
      const i = e.indices;
      if (i) {
        const c = cr(i, "indices");
        o.indices = li(t, c, cc), o.numElements = c.length, o.elementType = ri(c);
      } else o.numElements || (o.numElements = Ic(t, o.attribs));
      return o;
    }
    function lr(t) {
      return !!t.texStorage2D;
    }
    const Cc = /* @__PURE__ */ function() {
      const t = {}, e = {};
      function n(r) {
        const o = r.constructor.name;
        if (!t[o]) {
          for (const i in r)
            if (typeof r[i] == "number") {
              const c = e[r[i]];
              e[r[i]] = c ? `${c} | ${i}` : i;
            }
          t[o] = !0;
        }
      }
      return function(o, i) {
        return n(o), e[i] || (typeof i == "number" ? `0x${i.toString(16)}` : i);
      };
    }(), dr = ac;
    function mi(t) {
      return typeof document < "u" && document.getElementById ? document.getElementById(t) : null;
    }
    const xn = 33984, Tn = 34962, Nc = 34963, Bc = 35713, Dc = 35714, Pc = 35632, Uc = 35633, Mc = 35981, _i = 35718, Oc = 35721, Lc = 35971, kc = 35382, $c = 35396, zc = 35398, Vc = 35392, Gc = 35395, vn = 5126, pi = 35664, hi = 35665, bi = 35666, mr = 5124, xi = 35667, yi = 35668, Ei = 35669, gi = 35670, Ai = 35671, Ti = 35672, vi = 35673, Si = 35674, Ri = 35675, wi = 35676, Hc = 35678, Xc = 35680, Yc = 35679, Wc = 35682, jc = 35685, Kc = 35686, Jc = 35687, Qc = 35688, Zc = 35689, qc = 35690, ef = 36289, tf = 36292, nf = 36293, _r = 5125, Fi = 36294, Ii = 36295, Ci = 36296, rf = 36298, of = 36299, sf = 36300, af = 36303, uf = 36306, cf = 36307, ff = 36308, lf = 36311, Sn = 3553, Rn = 34067, pr = 32879, wn = 35866, W = {};
    function Ni(t, e) {
      return W[e].bindPoint;
    }
    function df(t, e) {
      return function(n) {
        t.uniform1f(e, n);
      };
    }
    function mf(t, e) {
      return function(n) {
        t.uniform1fv(e, n);
      };
    }
    function _f(t, e) {
      return function(n) {
        t.uniform2fv(e, n);
      };
    }
    function pf(t, e) {
      return function(n) {
        t.uniform3fv(e, n);
      };
    }
    function hf(t, e) {
      return function(n) {
        t.uniform4fv(e, n);
      };
    }
    function Bi(t, e) {
      return function(n) {
        t.uniform1i(e, n);
      };
    }
    function Di(t, e) {
      return function(n) {
        t.uniform1iv(e, n);
      };
    }
    function Pi(t, e) {
      return function(n) {
        t.uniform2iv(e, n);
      };
    }
    function Ui(t, e) {
      return function(n) {
        t.uniform3iv(e, n);
      };
    }
    function Mi(t, e) {
      return function(n) {
        t.uniform4iv(e, n);
      };
    }
    function bf(t, e) {
      return function(n) {
        t.uniform1ui(e, n);
      };
    }
    function xf(t, e) {
      return function(n) {
        t.uniform1uiv(e, n);
      };
    }
    function yf(t, e) {
      return function(n) {
        t.uniform2uiv(e, n);
      };
    }
    function Ef(t, e) {
      return function(n) {
        t.uniform3uiv(e, n);
      };
    }
    function gf(t, e) {
      return function(n) {
        t.uniform4uiv(e, n);
      };
    }
    function Af(t, e) {
      return function(n) {
        t.uniformMatrix2fv(e, !1, n);
      };
    }
    function Tf(t, e) {
      return function(n) {
        t.uniformMatrix3fv(e, !1, n);
      };
    }
    function vf(t, e) {
      return function(n) {
        t.uniformMatrix4fv(e, !1, n);
      };
    }
    function Sf(t, e) {
      return function(n) {
        t.uniformMatrix2x3fv(e, !1, n);
      };
    }
    function Rf(t, e) {
      return function(n) {
        t.uniformMatrix3x2fv(e, !1, n);
      };
    }
    function wf(t, e) {
      return function(n) {
        t.uniformMatrix2x4fv(e, !1, n);
      };
    }
    function Ff(t, e) {
      return function(n) {
        t.uniformMatrix4x2fv(e, !1, n);
      };
    }
    function If(t, e) {
      return function(n) {
        t.uniformMatrix3x4fv(e, !1, n);
      };
    }
    function Cf(t, e) {
      return function(n) {
        t.uniformMatrix4x3fv(e, !1, n);
      };
    }
    function Ne(t, e, n, r) {
      const o = Ni(t, e);
      return lr(t) ? function(i) {
        let c, u;
        !i || si(t, i) ? (c = i, u = null) : (c = i.texture, u = i.sampler), t.uniform1i(r, n), t.activeTexture(xn + n), t.bindTexture(o, c), t.bindSampler(n, u);
      } : function(i) {
        t.uniform1i(r, n), t.activeTexture(xn + n), t.bindTexture(o, i);
      };
    }
    function Be(t, e, n, r, o) {
      const i = Ni(t, e), c = new Int32Array(o);
      for (let u = 0; u < o; ++u)
        c[u] = n + u;
      return lr(t) ? function(u) {
        t.uniform1iv(r, c), u.forEach(function(m, b) {
          t.activeTexture(xn + c[b]);
          let g, T;
          !m || si(t, m) ? (g = m, T = null) : (g = m.texture, T = m.sampler), t.bindSampler(n, T), t.bindTexture(i, g);
        });
      } : function(u) {
        t.uniform1iv(r, c), u.forEach(function(m, b) {
          t.activeTexture(xn + c[b]), t.bindTexture(i, m);
        });
      };
    }
    W[vn] = { Type: Float32Array, size: 4, setter: df, arraySetter: mf };
    W[pi] = { Type: Float32Array, size: 8, setter: _f, cols: 2 };
    W[hi] = { Type: Float32Array, size: 12, setter: pf, cols: 3 };
    W[bi] = { Type: Float32Array, size: 16, setter: hf, cols: 4 };
    W[mr] = { Type: Int32Array, size: 4, setter: Bi, arraySetter: Di };
    W[xi] = { Type: Int32Array, size: 8, setter: Pi, cols: 2 };
    W[yi] = { Type: Int32Array, size: 12, setter: Ui, cols: 3 };
    W[Ei] = { Type: Int32Array, size: 16, setter: Mi, cols: 4 };
    W[_r] = { Type: Uint32Array, size: 4, setter: bf, arraySetter: xf };
    W[Fi] = { Type: Uint32Array, size: 8, setter: yf, cols: 2 };
    W[Ii] = { Type: Uint32Array, size: 12, setter: Ef, cols: 3 };
    W[Ci] = { Type: Uint32Array, size: 16, setter: gf, cols: 4 };
    W[gi] = { Type: Uint32Array, size: 4, setter: Bi, arraySetter: Di };
    W[Ai] = { Type: Uint32Array, size: 8, setter: Pi, cols: 2 };
    W[Ti] = { Type: Uint32Array, size: 12, setter: Ui, cols: 3 };
    W[vi] = { Type: Uint32Array, size: 16, setter: Mi, cols: 4 };
    W[Si] = { Type: Float32Array, size: 32, setter: Af, rows: 2, cols: 2 };
    W[Ri] = { Type: Float32Array, size: 48, setter: Tf, rows: 3, cols: 3 };
    W[wi] = { Type: Float32Array, size: 64, setter: vf, rows: 4, cols: 4 };
    W[jc] = { Type: Float32Array, size: 32, setter: Sf, rows: 2, cols: 3 };
    W[Kc] = { Type: Float32Array, size: 32, setter: wf, rows: 2, cols: 4 };
    W[Jc] = { Type: Float32Array, size: 48, setter: Rf, rows: 3, cols: 2 };
    W[Qc] = { Type: Float32Array, size: 48, setter: If, rows: 3, cols: 4 };
    W[Zc] = { Type: Float32Array, size: 64, setter: Ff, rows: 4, cols: 2 };
    W[qc] = { Type: Float32Array, size: 64, setter: Cf, rows: 4, cols: 3 };
    W[Hc] = { Type: null, size: 0, setter: Ne, arraySetter: Be, bindPoint: Sn };
    W[Xc] = { Type: null, size: 0, setter: Ne, arraySetter: Be, bindPoint: Rn };
    W[Yc] = { Type: null, size: 0, setter: Ne, arraySetter: Be, bindPoint: pr };
    W[Wc] = { Type: null, size: 0, setter: Ne, arraySetter: Be, bindPoint: Sn };
    W[ef] = { Type: null, size: 0, setter: Ne, arraySetter: Be, bindPoint: wn };
    W[tf] = { Type: null, size: 0, setter: Ne, arraySetter: Be, bindPoint: wn };
    W[nf] = { Type: null, size: 0, setter: Ne, arraySetter: Be, bindPoint: Rn };
    W[rf] = { Type: null, size: 0, setter: Ne, arraySetter: Be, bindPoint: Sn };
    W[of] = { Type: null, size: 0, setter: Ne, arraySetter: Be, bindPoint: pr };
    W[sf] = { Type: null, size: 0, setter: Ne, arraySetter: Be, bindPoint: Rn };
    W[af] = { Type: null, size: 0, setter: Ne, arraySetter: Be, bindPoint: wn };
    W[uf] = { Type: null, size: 0, setter: Ne, arraySetter: Be, bindPoint: Sn };
    W[cf] = { Type: null, size: 0, setter: Ne, arraySetter: Be, bindPoint: pr };
    W[ff] = { Type: null, size: 0, setter: Ne, arraySetter: Be, bindPoint: Rn };
    W[lf] = { Type: null, size: 0, setter: Ne, arraySetter: Be, bindPoint: wn };
    function Fn(t, e) {
      return function(n) {
        if (n.value)
          switch (t.disableVertexAttribArray(e), n.value.length) {
            case 4:
              t.vertexAttrib4fv(e, n.value);
              break;
            case 3:
              t.vertexAttrib3fv(e, n.value);
              break;
            case 2:
              t.vertexAttrib2fv(e, n.value);
              break;
            case 1:
              t.vertexAttrib1fv(e, n.value);
              break;
            default:
              throw new Error("the length of a float constant value must be between 1 and 4!");
          }
        else
          t.bindBuffer(Tn, n.buffer), t.enableVertexAttribArray(e), t.vertexAttribPointer(
            e,
            n.numComponents || n.size,
            n.type || vn,
            n.normalize || !1,
            n.stride || 0,
            n.offset || 0
          ), t.vertexAttribDivisor && t.vertexAttribDivisor(e, n.divisor || 0);
      };
    }
    function mt(t, e) {
      return function(n) {
        if (n.value)
          if (t.disableVertexAttribArray(e), n.value.length === 4)
            t.vertexAttrib4iv(e, n.value);
          else
            throw new Error("The length of an integer constant value must be 4!");
        else
          t.bindBuffer(Tn, n.buffer), t.enableVertexAttribArray(e), t.vertexAttribIPointer(
            e,
            n.numComponents || n.size,
            n.type || mr,
            n.stride || 0,
            n.offset || 0
          ), t.vertexAttribDivisor && t.vertexAttribDivisor(e, n.divisor || 0);
      };
    }
    function In(t, e) {
      return function(n) {
        if (n.value)
          if (t.disableVertexAttribArray(e), n.value.length === 4)
            t.vertexAttrib4uiv(e, n.value);
          else
            throw new Error("The length of an unsigned integer constant value must be 4!");
        else
          t.bindBuffer(Tn, n.buffer), t.enableVertexAttribArray(e), t.vertexAttribIPointer(
            e,
            n.numComponents || n.size,
            n.type || _r,
            n.stride || 0,
            n.offset || 0
          ), t.vertexAttribDivisor && t.vertexAttribDivisor(e, n.divisor || 0);
      };
    }
    function hr(t, e, n) {
      const r = n.size, o = n.count;
      return function(i) {
        t.bindBuffer(Tn, i.buffer);
        const c = i.size || i.numComponents || r, u = c / o, m = i.type || vn, g = W[m].size * c, T = i.normalize || !1, z = i.offset || 0, Q = g / o;
        for (let L = 0; L < o; ++L)
          t.enableVertexAttribArray(e + L), t.vertexAttribPointer(
            e + L,
            u,
            m,
            T,
            g,
            z + Q * L
          ), t.vertexAttribDivisor && t.vertexAttribDivisor(e + L, i.divisor || 0);
      };
    }
    const ye = {};
    ye[vn] = { size: 4, setter: Fn };
    ye[pi] = { size: 8, setter: Fn };
    ye[hi] = { size: 12, setter: Fn };
    ye[bi] = { size: 16, setter: Fn };
    ye[mr] = { size: 4, setter: mt };
    ye[xi] = { size: 8, setter: mt };
    ye[yi] = { size: 12, setter: mt };
    ye[Ei] = { size: 16, setter: mt };
    ye[_r] = { size: 4, setter: In };
    ye[Fi] = { size: 8, setter: In };
    ye[Ii] = { size: 12, setter: In };
    ye[Ci] = { size: 16, setter: In };
    ye[gi] = { size: 4, setter: mt };
    ye[Ai] = { size: 8, setter: mt };
    ye[Ti] = { size: 12, setter: mt };
    ye[vi] = { size: 16, setter: mt };
    ye[Si] = { size: 4, setter: hr, count: 2 };
    ye[Ri] = { size: 9, setter: hr, count: 3 };
    ye[wi] = { size: 16, setter: hr, count: 4 };
    const Nf = /ERROR:\s*\d+:(\d+)/gi;
    function Bf(t, e = "", n = 0) {
      const r = [...e.matchAll(Nf)], o = new Map(r.map((i, c) => {
        const u = parseInt(i[1]), m = r[c + 1], b = m ? m.index : e.length, g = e.substring(i.index, b);
        return [u - 1, g];
      }));
      return t.split(`
    `).map((i, c) => {
        const u = o.get(c);
        return `${c + 1 + n}: ${i}${u ? `

    ^^^ ${u}` : ""}`;
      }).join(`
    `);
    }
    const Oo = /^[ \t]*\n/;
    function Oi(t) {
      let e = 0;
      return Oo.test(t) && (e = 1, t = t.replace(Oo, "")), { lineOffset: e, shaderSource: t };
    }
    function Df(t, e) {
      return t.errorCallback(e), t.callback && setTimeout(() => {
        t.callback(`${e}
    ${t.errors.join(`
    `)}`);
      }), null;
    }
    function Pf(t, e, n, r) {
      if (r = r || dr, !t.getShaderParameter(n, Bc)) {
        const i = t.getShaderInfoLog(n), { lineOffset: c, shaderSource: u } = Oi(t.getShaderSource(n)), m = `${Bf(u, i, c)}
    Error compiling ${Cc(t, e)}: ${i}`;
        return r(m), m;
      }
      return "";
    }
    function br(t, e, n) {
      let r, o, i;
      if (typeof e == "function" && (n = e, e = void 0), typeof t == "function")
        n = t, t = void 0;
      else if (t && !Array.isArray(t)) {
        const b = t;
        n = b.errorCallback, t = b.attribLocations, r = b.transformFeedbackVaryings, o = b.transformFeedbackMode, i = b.callback;
      }
      const c = n || dr, u = [], m = {
        errorCallback(b, ...g) {
          u.push(b), c(b, ...g);
        },
        transformFeedbackVaryings: r,
        transformFeedbackMode: o,
        callback: i,
        errors: u
      };
      {
        let b = {};
        Array.isArray(t) ? t.forEach(function(g, T) {
          b[g] = e ? e[T] : T;
        }) : b = t || {}, m.attribLocations = b;
      }
      return m;
    }
    const Uf = [
      "VERTEX_SHADER",
      "FRAGMENT_SHADER"
    ];
    function Mf(t, e) {
      if (e.indexOf("frag") >= 0)
        return Pc;
      if (e.indexOf("vert") >= 0)
        return Uc;
    }
    function Of(t, e, n) {
      const r = t.getAttachedShaders(e);
      for (const o of r)
        n.has(o) && t.deleteShader(o);
      t.deleteProgram(e);
    }
    const Lf = (t = 0) => new Promise((e) => setTimeout(e, t));
    function kf(t, e, n) {
      const r = t.createProgram(), {
        attribLocations: o,
        transformFeedbackVaryings: i,
        transformFeedbackMode: c
      } = br(n);
      for (let u = 0; u < e.length; ++u) {
        let m = e[u];
        if (typeof m == "string") {
          const b = mi(m), g = b ? b.text : m;
          let T = t[Uf[u]];
          b && b.type && (T = Mf(t, b.type) || T), m = t.createShader(T), t.shaderSource(m, Oi(g).shaderSource), t.compileShader(m), t.attachShader(r, m);
        }
      }
      Object.entries(o).forEach(([u, m]) => t.bindAttribLocation(r, m, u));
      {
        let u = i;
        u && (u.attribs && (u = u.attribs), Array.isArray(u) || (u = Object.keys(u)), t.transformFeedbackVaryings(r, u, c || Mc));
      }
      return t.linkProgram(r), r;
    }
    function $f(t, e, n, r, o) {
      const i = br(n, r, o), c = new Set(e), u = kf(t, e, i);
      function m(b, g) {
        const T = Vf(b, g, i.errorCallback);
        return T && Of(b, g, c), T;
      }
      if (i.callback) {
        zf(t, u).then(() => {
          const b = m(t, u);
          i.callback(b, b ? void 0 : u);
        });
        return;
      }
      return m(t, u) ? void 0 : u;
    }
    async function zf(t, e) {
      const n = t.getExtension("KHR_parallel_shader_compile"), r = n ? (i, c) => i.getProgramParameter(c, n.COMPLETION_STATUS_KHR) : () => !0;
      let o = 0;
      do
        await Lf(o), o = 1e3 / 60;
      while (!r(t, e));
    }
    function Vf(t, e, n) {
      if (n = n || dr, !t.getProgramParameter(e, Dc)) {
        const o = t.getProgramInfoLog(e);
        n(`Error in program linking: ${o}`);
        const c = t.getAttachedShaders(e).map((u) => Pf(t, t.getShaderParameter(u, t.SHADER_TYPE), u, n));
        return `${o}
    ${c.filter((u) => u).join(`
    `)}`;
      }
    }
    function Gf(t, e, n, r, o) {
      return $f(t, e, n, r, o);
    }
    function Li(t) {
      const e = t.name;
      return e.startsWith("gl_") || e.startsWith("webgl_");
    }
    const Hf = /(\.|\[|]|\w+)/g, Xf = (t) => t >= "0" && t <= "9";
    function Yf(t, e, n, r) {
      const o = t.split(Hf).filter((u) => u !== "");
      let i = 0, c = "";
      for (; ; ) {
        const u = o[i++];
        c += u;
        const m = Xf(u[0]), b = m ? parseInt(u) : u;
        if (m && (c += o[i++]), i === o.length) {
          n[b] = e;
          break;
        } else {
          const T = o[i++], z = T === "[", Q = n[b] || (z ? [] : {});
          n[b] = Q, n = Q, r[c] = r[c] || /* @__PURE__ */ function(L) {
            return function(D) {
              ki(L, D);
            };
          }(Q), c += T;
        }
      }
    }
    function Wf(t, e) {
      let n = 0;
      function r(u, m, b) {
        const g = m.name.endsWith("[0]"), T = m.type, z = W[T];
        if (!z)
          throw new Error(`unknown type: 0x${T.toString(16)}`);
        let Q;
        if (z.bindPoint) {
          const L = n;
          n += m.size, g ? Q = z.arraySetter(t, T, L, b, m.size) : Q = z.setter(t, T, L, b, m.size);
        } else
          z.arraySetter && g ? Q = z.arraySetter(t, b) : Q = z.setter(t, b);
        return Q.location = b, Q;
      }
      const o = {}, i = {}, c = t.getProgramParameter(e, _i);
      for (let u = 0; u < c; ++u) {
        const m = t.getActiveUniform(e, u);
        if (Li(m))
          continue;
        let b = m.name;
        b.endsWith("[0]") && (b = b.substr(0, b.length - 3));
        const g = t.getUniformLocation(e, m.name);
        if (g) {
          const T = r(e, m, g);
          o[b] = T, Yf(b, T, i, o);
        }
      }
      return o;
    }
    function jf(t, e) {
      const n = {}, r = t.getProgramParameter(e, Lc);
      for (let o = 0; o < r; ++o) {
        const i = t.getTransformFeedbackVarying(e, o);
        n[i.name] = {
          index: o,
          type: i.type,
          size: i.size
        };
      }
      return n;
    }
    function Kf(t, e) {
      const n = t.getProgramParameter(e, _i), r = [], o = [];
      for (let u = 0; u < n; ++u) {
        o.push(u), r.push({});
        const m = t.getActiveUniform(e, u);
        r[u].name = m.name;
      }
      [
        ["UNIFORM_TYPE", "type"],
        ["UNIFORM_SIZE", "size"],
        // num elements
        ["UNIFORM_BLOCK_INDEX", "blockNdx"],
        ["UNIFORM_OFFSET", "offset"]
      ].forEach(function(u) {
        const m = u[0], b = u[1];
        t.getActiveUniforms(e, o, t[m]).forEach(function(g, T) {
          r[T][b] = g;
        });
      });
      const i = {}, c = t.getProgramParameter(e, kc);
      for (let u = 0; u < c; ++u) {
        const m = t.getActiveUniformBlockName(e, u), b = {
          index: t.getUniformBlockIndex(e, m),
          usedByVertexShader: t.getActiveUniformBlockParameter(e, u, $c),
          usedByFragmentShader: t.getActiveUniformBlockParameter(e, u, zc),
          size: t.getActiveUniformBlockParameter(e, u, Vc),
          uniformIndices: t.getActiveUniformBlockParameter(e, u, Gc)
        };
        b.used = b.usedByVertexShader || b.usedByFragmentShader, i[m] = b;
      }
      return {
        blockSpecs: i,
        uniformData: r
      };
    }
    function ki(t, e) {
      for (const n in e) {
        const r = t[n];
        typeof r == "function" ? r(e[n]) : ki(t[n], e[n]);
      }
    }
    function pn(t, ...e) {
      const n = t.uniformSetters || t, r = e.length;
      for (let o = 0; o < r; ++o) {
        const i = e[o];
        if (Array.isArray(i)) {
          const c = i.length;
          for (let u = 0; u < c; ++u)
            pn(n, i[u]);
        } else
          for (const c in i) {
            const u = n[c];
            u && u(i[c]);
          }
      }
    }
    function Jf(t, e) {
      const n = {}, r = t.getProgramParameter(e, Oc);
      for (let o = 0; o < r; ++o) {
        const i = t.getActiveAttrib(e, o);
        if (Li(i))
          continue;
        const c = t.getAttribLocation(e, i.name), u = ye[i.type], m = u.setter(t, c, u);
        m.location = c, n[i.name] = m;
      }
      return n;
    }
    function Qf(t, e) {
      for (const n in e) {
        const r = t[n];
        r && r(e[n]);
      }
    }
    function dn(t, e, n) {
      n.vertexArrayObject ? t.bindVertexArray(n.vertexArrayObject) : (Qf(e.attribSetters || e, n.attribs), n.indices && t.bindBuffer(Nc, n.indices));
    }
    function Lo(t, e) {
      const n = Wf(t, e), r = Jf(t, e), o = {
        program: e,
        uniformSetters: n,
        attribSetters: r
      };
      return lr(t) && (o.uniformBlockSpec = Kf(t, e), o.transformFeedbackInfo = jf(t, e)), o;
    }
    const Zf = /\s|{|}|;/;
    function Yn(t, e, n, r, o) {
      const i = br(n, r, o), c = [];
      if (e = e.map(function(b) {
        if (!Zf.test(b)) {
          const g = mi(b);
          if (g)
            b = g.text;
          else {
            const T = `no element with id: ${b}`;
            i.errorCallback(T), c.push(T);
          }
        }
        return b;
      }), c.length)
        return Df(i, "");
      const u = i.callback;
      u && (i.callback = (b, g) => {
        u(b, b ? void 0 : Lo(t, g));
      });
      const m = Gf(t, e, i);
      return m ? Lo(t, m) : null;
    }
    const qf = 4, ko = 5123;
    function Ut(t, e, n, r, o, i) {
      n = n === void 0 ? qf : n;
      const c = e.indices, u = e.elementType, m = r === void 0 ? e.numElements : r;
      o = o === void 0 ? 0 : o, u || c ? i !== void 0 ? t.drawElementsInstanced(n, m, u === void 0 ? ko : e.elementType, o, i) : t.drawElements(n, m, u === void 0 ? ko : e.elementType, o) : i !== void 0 ? t.drawArraysInstanced(n, o, m, i) : t.drawArrays(n, o, m);
    }
    function el(t, e) {
      e = e || 1, e = Math.max(0, e);
      const n = t.clientWidth * e | 0, r = t.clientHeight * e | 0;
      return t.width !== n || t.height !== r ? (t.width = n, t.height = r, !0) : !1;
    }
    function tl(t) {
      if (!(typeof window > "u")) {
        var e = document.createElement("style");
        return e.setAttribute("type", "text/css"), e.innerHTML = t, document.head.appendChild(e), t;
      }
    }
    function Ft(t, e) {
      var n = t.__state.conversionName.toString(), r = Math.round(t.r), o = Math.round(t.g), i = Math.round(t.b), c = t.a, u = Math.round(t.h), m = t.s.toFixed(1), b = t.v.toFixed(1);
      if (e || n === "THREE_CHAR_HEX" || n === "SIX_CHAR_HEX") {
        for (var g = t.hex.toString(16); g.length < 6; )
          g = "0" + g;
        return "#" + g;
      } else {
        if (n === "CSS_RGB")
          return "rgb(" + r + "," + o + "," + i + ")";
        if (n === "CSS_RGBA")
          return "rgba(" + r + "," + o + "," + i + "," + c + ")";
        if (n === "HEX")
          return "0x" + t.hex.toString(16);
        if (n === "RGB_ARRAY")
          return "[" + r + "," + o + "," + i + "]";
        if (n === "RGBA_ARRAY")
          return "[" + r + "," + o + "," + i + "," + c + "]";
        if (n === "RGB_OBJ")
          return "{r:" + r + ",g:" + o + ",b:" + i + "}";
        if (n === "RGBA_OBJ")
          return "{r:" + r + ",g:" + o + ",b:" + i + ",a:" + c + "}";
        if (n === "HSV_OBJ")
          return "{h:" + u + ",s:" + m + ",v:" + b + "}";
        if (n === "HSVA_OBJ")
          return "{h:" + u + ",s:" + m + ",v:" + b + ",a:" + c + "}";
      }
      return "unknown format";
    }
    var $o = Array.prototype.forEach, Mt = Array.prototype.slice, y = {
      BREAK: {},
      extend: function(e) {
        return this.each(Mt.call(arguments, 1), function(n) {
          var r = this.isObject(n) ? Object.keys(n) : [];
          r.forEach((function(o) {
            this.isUndefined(n[o]) || (e[o] = n[o]);
          }).bind(this));
        }, this), e;
      },
      defaults: function(e) {
        return this.each(Mt.call(arguments, 1), function(n) {
          var r = this.isObject(n) ? Object.keys(n) : [];
          r.forEach((function(o) {
            this.isUndefined(e[o]) && (e[o] = n[o]);
          }).bind(this));
        }, this), e;
      },
      compose: function() {
        var e = Mt.call(arguments);
        return function() {
          for (var n = Mt.call(arguments), r = e.length - 1; r >= 0; r--)
            n = [e[r].apply(this, n)];
          return n[0];
        };
      },
      each: function(e, n, r) {
        if (e) {
          if ($o && e.forEach && e.forEach === $o)
            e.forEach(n, r);
          else if (e.length === e.length + 0) {
            var o = void 0, i = void 0;
            for (o = 0, i = e.length; o < i; o++)
              if (o in e && n.call(r, e[o], o) === this.BREAK)
                return;
          } else
            for (var c in e)
              if (n.call(r, e[c], c) === this.BREAK)
                return;
        }
      },
      defer: function(e) {
        setTimeout(e, 0);
      },
      debounce: function(e, n, r) {
        var o = void 0;
        return function() {
          var i = this, c = arguments;
          function u() {
            o = null, r || e.apply(i, c);
          }
          var m = r || !o;
          clearTimeout(o), o = setTimeout(u, n), m && e.apply(i, c);
        };
      },
      toArray: function(e) {
        return e.toArray ? e.toArray() : Mt.call(e);
      },
      isUndefined: function(e) {
        return e === void 0;
      },
      isNull: function(e) {
        return e === null;
      },
      isNaN: function(t) {
        function e(n) {
          return t.apply(this, arguments);
        }
        return e.toString = function() {
          return t.toString();
        }, e;
      }(function(t) {
        return isNaN(t);
      }),
      isArray: Array.isArray || function(t) {
        return t.constructor === Array;
      },
      isObject: function(e) {
        return e === Object(e);
      },
      isNumber: function(e) {
        return e === e + 0;
      },
      isString: function(e) {
        return e === e + "";
      },
      isBoolean: function(e) {
        return e === !1 || e === !0;
      },
      isFunction: function(e) {
        return e instanceof Function;
      }
    }, nl = [
      {
        litmus: y.isString,
        conversions: {
          THREE_CHAR_HEX: {
            read: function(e) {
              var n = e.match(/^#([A-F0-9])([A-F0-9])([A-F0-9])$/i);
              return n === null ? !1 : {
                space: "HEX",
                hex: parseInt("0x" + n[1].toString() + n[1].toString() + n[2].toString() + n[2].toString() + n[3].toString() + n[3].toString(), 0)
              };
            },
            write: Ft
          },
          SIX_CHAR_HEX: {
            read: function(e) {
              var n = e.match(/^#([A-F0-9]{6})$/i);
              return n === null ? !1 : {
                space: "HEX",
                hex: parseInt("0x" + n[1].toString(), 0)
              };
            },
            write: Ft
          },
          CSS_RGB: {
            read: function(e) {
              var n = e.match(/^rgb\(\s*(\S+)\s*,\s*(\S+)\s*,\s*(\S+)\s*\)/);
              return n === null ? !1 : {
                space: "RGB",
                r: parseFloat(n[1]),
                g: parseFloat(n[2]),
                b: parseFloat(n[3])
              };
            },
            write: Ft
          },
          CSS_RGBA: {
            read: function(e) {
              var n = e.match(/^rgba\(\s*(\S+)\s*,\s*(\S+)\s*,\s*(\S+)\s*,\s*(\S+)\s*\)/);
              return n === null ? !1 : {
                space: "RGB",
                r: parseFloat(n[1]),
                g: parseFloat(n[2]),
                b: parseFloat(n[3]),
                a: parseFloat(n[4])
              };
            },
            write: Ft
          }
        }
      },
      {
        litmus: y.isNumber,
        conversions: {
          HEX: {
            read: function(e) {
              return {
                space: "HEX",
                hex: e,
                conversionName: "HEX"
              };
            },
            write: function(e) {
              return e.hex;
            }
          }
        }
      },
      {
        litmus: y.isArray,
        conversions: {
          RGB_ARRAY: {
            read: function(e) {
              return e.length !== 3 ? !1 : {
                space: "RGB",
                r: e[0],
                g: e[1],
                b: e[2]
              };
            },
            write: function(e) {
              return [e.r, e.g, e.b];
            }
          },
          RGBA_ARRAY: {
            read: function(e) {
              return e.length !== 4 ? !1 : {
                space: "RGB",
                r: e[0],
                g: e[1],
                b: e[2],
                a: e[3]
              };
            },
            write: function(e) {
              return [e.r, e.g, e.b, e.a];
            }
          }
        }
      },
      {
        litmus: y.isObject,
        conversions: {
          RGBA_OBJ: {
            read: function(e) {
              return y.isNumber(e.r) && y.isNumber(e.g) && y.isNumber(e.b) && y.isNumber(e.a) ? {
                space: "RGB",
                r: e.r,
                g: e.g,
                b: e.b,
                a: e.a
              } : !1;
            },
            write: function(e) {
              return {
                r: e.r,
                g: e.g,
                b: e.b,
                a: e.a
              };
            }
          },
          RGB_OBJ: {
            read: function(e) {
              return y.isNumber(e.r) && y.isNumber(e.g) && y.isNumber(e.b) ? {
                space: "RGB",
                r: e.r,
                g: e.g,
                b: e.b
              } : !1;
            },
            write: function(e) {
              return {
                r: e.r,
                g: e.g,
                b: e.b
              };
            }
          },
          HSVA_OBJ: {
            read: function(e) {
              return y.isNumber(e.h) && y.isNumber(e.s) && y.isNumber(e.v) && y.isNumber(e.a) ? {
                space: "HSV",
                h: e.h,
                s: e.s,
                v: e.v,
                a: e.a
              } : !1;
            },
            write: function(e) {
              return {
                h: e.h,
                s: e.s,
                v: e.v,
                a: e.a
              };
            }
          },
          HSV_OBJ: {
            read: function(e) {
              return y.isNumber(e.h) && y.isNumber(e.s) && y.isNumber(e.v) ? {
                space: "HSV",
                h: e.h,
                s: e.s,
                v: e.v
              } : !1;
            },
            write: function(e) {
              return {
                h: e.h,
                s: e.s,
                v: e.v
              };
            }
          }
        }
      }
    ], Ot = void 0, mn = void 0, Kn = function() {
      mn = !1;
      var e = arguments.length > 1 ? y.toArray(arguments) : arguments[0];
      return y.each(nl, function(n) {
        if (n.litmus(e))
          return y.each(n.conversions, function(r, o) {
            if (Ot = r.read(e), mn === !1 && Ot !== !1)
              return mn = Ot, Ot.conversionName = o, Ot.conversion = r, y.BREAK;
          }), y.BREAK;
      }), mn;
    }, zo = void 0, yn = {
      hsv_to_rgb: function(e, n, r) {
        var o = Math.floor(e / 60) % 6, i = e / 60 - Math.floor(e / 60), c = r * (1 - n), u = r * (1 - i * n), m = r * (1 - (1 - i) * n), b = [[r, m, c], [u, r, c], [c, r, m], [c, u, r], [m, c, r], [r, c, u]][o];
        return {
          r: b[0] * 255,
          g: b[1] * 255,
          b: b[2] * 255
        };
      },
      rgb_to_hsv: function(e, n, r) {
        var o = Math.min(e, n, r), i = Math.max(e, n, r), c = i - o, u = void 0, m = void 0;
        if (i !== 0)
          m = c / i;
        else
          return {
            h: NaN,
            s: 0,
            v: 0
          };
        return e === i ? u = (n - r) / c : n === i ? u = 2 + (r - e) / c : u = 4 + (e - n) / c, u /= 6, u < 0 && (u += 1), {
          h: u * 360,
          s: m,
          v: i / 255
        };
      },
      rgb_to_hex: function(e, n, r) {
        var o = this.hex_with_component(0, 2, e);
        return o = this.hex_with_component(o, 1, n), o = this.hex_with_component(o, 0, r), o;
      },
      component_from_hex: function(e, n) {
        return e >> n * 8 & 255;
      },
      hex_with_component: function(e, n, r) {
        return r << (zo = n * 8) | e & ~(255 << zo);
      }
    }, rl = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
      return typeof t;
    } : function(t) {
      return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
    }, Ye = function(t, e) {
      if (!(t instanceof e))
        throw new TypeError("Cannot call a class as a function");
    }, We = /* @__PURE__ */ function() {
      function t(e, n) {
        for (var r = 0; r < n.length; r++) {
          var o = n[r];
          o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, o.key, o);
        }
      }
      return function(e, n, r) {
        return n && t(e.prototype, n), r && t(e, r), e;
      };
    }(), dt = function t(e, n, r) {
      e === null && (e = Function.prototype);
      var o = Object.getOwnPropertyDescriptor(e, n);
      if (o === void 0) {
        var i = Object.getPrototypeOf(e);
        return i === null ? void 0 : t(i, n, r);
      } else {
        if ("value" in o)
          return o.value;
        var c = o.get;
        return c === void 0 ? void 0 : c.call(r);
      }
    }, _t = function(t, e) {
      if (typeof e != "function" && e !== null)
        throw new TypeError("Super expression must either be null or a function, not " + typeof e);
      t.prototype = Object.create(e && e.prototype, {
        constructor: {
          value: t,
          enumerable: !1,
          writable: !0,
          configurable: !0
        }
      }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
    }, pt = function(t, e) {
      if (!t)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return e && (typeof e == "object" || typeof e == "function") ? e : t;
    }, Re = function() {
      function t() {
        if (Ye(this, t), this.__state = Kn.apply(this, arguments), this.__state === !1)
          throw new Error("Failed to interpret color arguments");
        this.__state.a = this.__state.a || 1;
      }
      return We(t, [{
        key: "toString",
        value: function() {
          return Ft(this);
        }
      }, {
        key: "toHexString",
        value: function() {
          return Ft(this, !0);
        }
      }, {
        key: "toOriginal",
        value: function() {
          return this.__state.conversion.write(this);
        }
      }]), t;
    }();
    function xr(t, e, n) {
      Object.defineProperty(t, e, {
        get: function() {
          return this.__state.space === "RGB" ? this.__state[e] : (Re.recalculateRGB(this, e, n), this.__state[e]);
        },
        set: function(o) {
          this.__state.space !== "RGB" && (Re.recalculateRGB(this, e, n), this.__state.space = "RGB"), this.__state[e] = o;
        }
      });
    }
    function yr(t, e) {
      Object.defineProperty(t, e, {
        get: function() {
          return this.__state.space === "HSV" ? this.__state[e] : (Re.recalculateHSV(this), this.__state[e]);
        },
        set: function(r) {
          this.__state.space !== "HSV" && (Re.recalculateHSV(this), this.__state.space = "HSV"), this.__state[e] = r;
        }
      });
    }
    Re.recalculateRGB = function(t, e, n) {
      if (t.__state.space === "HEX")
        t.__state[e] = yn.component_from_hex(t.__state.hex, n);
      else if (t.__state.space === "HSV")
        y.extend(t.__state, yn.hsv_to_rgb(t.__state.h, t.__state.s, t.__state.v));
      else
        throw new Error("Corrupted color state");
    };
    Re.recalculateHSV = function(t) {
      var e = yn.rgb_to_hsv(t.r, t.g, t.b);
      y.extend(t.__state, {
        s: e.s,
        v: e.v
      }), y.isNaN(e.h) ? y.isUndefined(t.__state.h) && (t.__state.h = 0) : t.__state.h = e.h;
    };
    Re.COMPONENTS = ["r", "g", "b", "h", "s", "v", "hex", "a"];
    xr(Re.prototype, "r", 2);
    xr(Re.prototype, "g", 1);
    xr(Re.prototype, "b", 0);
    yr(Re.prototype, "h");
    yr(Re.prototype, "s");
    yr(Re.prototype, "v");
    Object.defineProperty(Re.prototype, "a", {
      get: function() {
        return this.__state.a;
      },
      set: function(e) {
        this.__state.a = e;
      }
    });
    Object.defineProperty(Re.prototype, "hex", {
      get: function() {
        return this.__state.space !== "HEX" && (this.__state.hex = yn.rgb_to_hex(this.r, this.g, this.b), this.__state.space = "HEX"), this.__state.hex;
      },
      set: function(e) {
        this.__state.space = "HEX", this.__state.hex = e;
      }
    });
    var Et = function() {
      function t(e, n) {
        Ye(this, t), this.initialValue = e[n], this.domElement = document.createElement("div"), this.object = e, this.property = n, this.__onChange = void 0, this.__onFinishChange = void 0;
      }
      return We(t, [{
        key: "onChange",
        value: function(n) {
          return this.__onChange = n, this;
        }
      }, {
        key: "onFinishChange",
        value: function(n) {
          return this.__onFinishChange = n, this;
        }
      }, {
        key: "setValue",
        value: function(n) {
          return this.object[this.property] = n, this.__onChange && this.__onChange.call(this, n), this.updateDisplay(), this;
        }
      }, {
        key: "getValue",
        value: function() {
          return this.object[this.property];
        }
      }, {
        key: "updateDisplay",
        value: function() {
          return this;
        }
      }, {
        key: "isModified",
        value: function() {
          return this.initialValue !== this.getValue();
        }
      }]), t;
    }(), ol = {
      HTMLEvents: ["change"],
      MouseEvents: ["click", "mousemove", "mousedown", "mouseup", "mouseover"],
      KeyboardEvents: ["keydown"]
    }, $i = {};
    y.each(ol, function(t, e) {
      y.each(t, function(n) {
        $i[n] = e;
      });
    });
    var il = /(\d+(\.\d+)?)px/;
    function Ze(t) {
      if (t === "0" || y.isUndefined(t))
        return 0;
      var e = t.match(il);
      return y.isNull(e) ? 0 : parseFloat(e[1]);
    }
    var _ = {
      makeSelectable: function(e, n) {
        e === void 0 || e.style === void 0 || (e.onselectstart = n ? function() {
          return !1;
        } : function() {
        }, e.style.MozUserSelect = n ? "auto" : "none", e.style.KhtmlUserSelect = n ? "auto" : "none", e.unselectable = n ? "on" : "off");
      },
      makeFullscreen: function(e, n, r) {
        var o = r, i = n;
        y.isUndefined(i) && (i = !0), y.isUndefined(o) && (o = !0), e.style.position = "absolute", i && (e.style.left = 0, e.style.right = 0), o && (e.style.top = 0, e.style.bottom = 0);
      },
      fakeEvent: function(e, n, r, o) {
        var i = r || {}, c = $i[n];
        if (!c)
          throw new Error("Event type " + n + " not supported.");
        var u = document.createEvent(c);
        switch (c) {
          case "MouseEvents": {
            var m = i.x || i.clientX || 0, b = i.y || i.clientY || 0;
            u.initMouseEvent(
              n,
              i.bubbles || !1,
              i.cancelable || !0,
              window,
              i.clickCount || 1,
              0,
              0,
              m,
              b,
              !1,
              !1,
              !1,
              !1,
              0,
              null
            );
            break;
          }
          case "KeyboardEvents": {
            var g = u.initKeyboardEvent || u.initKeyEvent;
            y.defaults(i, {
              cancelable: !0,
              ctrlKey: !1,
              altKey: !1,
              shiftKey: !1,
              metaKey: !1,
              keyCode: void 0,
              charCode: void 0
            }), g(n, i.bubbles || !1, i.cancelable, window, i.ctrlKey, i.altKey, i.shiftKey, i.metaKey, i.keyCode, i.charCode);
            break;
          }
          default: {
            u.initEvent(n, i.bubbles || !1, i.cancelable || !0);
            break;
          }
        }
        y.defaults(u, o), e.dispatchEvent(u);
      },
      bind: function(e, n, r, o) {
        var i = o || !1;
        return e.addEventListener ? e.addEventListener(n, r, i) : e.attachEvent && e.attachEvent("on" + n, r), _;
      },
      unbind: function(e, n, r, o) {
        var i = o || !1;
        return e.removeEventListener ? e.removeEventListener(n, r, i) : e.detachEvent && e.detachEvent("on" + n, r), _;
      },
      addClass: function(e, n) {
        if (e.className === void 0)
          e.className = n;
        else if (e.className !== n) {
          var r = e.className.split(/ +/);
          r.indexOf(n) === -1 && (r.push(n), e.className = r.join(" ").replace(/^\s+/, "").replace(/\s+$/, ""));
        }
        return _;
      },
      removeClass: function(e, n) {
        if (n)
          if (e.className === n)
            e.removeAttribute("class");
          else {
            var r = e.className.split(/ +/), o = r.indexOf(n);
            o !== -1 && (r.splice(o, 1), e.className = r.join(" "));
          }
        else
          e.className = void 0;
        return _;
      },
      hasClass: function(e, n) {
        return new RegExp("(?:^|\\s+)" + n + "(?:\\s+|$)").test(e.className) || !1;
      },
      getWidth: function(e) {
        var n = getComputedStyle(e);
        return Ze(n["border-left-width"]) + Ze(n["border-right-width"]) + Ze(n["padding-left"]) + Ze(n["padding-right"]) + Ze(n.width);
      },
      getHeight: function(e) {
        var n = getComputedStyle(e);
        return Ze(n["border-top-width"]) + Ze(n["border-bottom-width"]) + Ze(n["padding-top"]) + Ze(n["padding-bottom"]) + Ze(n.height);
      },
      getOffset: function(e) {
        var n = e, r = { left: 0, top: 0 };
        if (n.offsetParent)
          do
            r.left += n.offsetLeft, r.top += n.offsetTop, n = n.offsetParent;
          while (n);
        return r;
      },
      isActive: function(e) {
        return e === document.activeElement && (e.type || e.href);
      }
    }, zi = function(t) {
      _t(e, t);
      function e(n, r) {
        Ye(this, e);
        var o = pt(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, n, r)), i = o;
        o.__prev = o.getValue(), o.__checkbox = document.createElement("input"), o.__checkbox.setAttribute("type", "checkbox");
        function c() {
          i.setValue(!i.__prev);
        }
        return _.bind(o.__checkbox, "change", c, !1), o.domElement.appendChild(o.__checkbox), o.updateDisplay(), o;
      }
      return We(e, [{
        key: "setValue",
        value: function(r) {
          var o = dt(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "setValue", this).call(this, r);
          return this.__onFinishChange && this.__onFinishChange.call(this, this.getValue()), this.__prev = this.getValue(), o;
        }
      }, {
        key: "updateDisplay",
        value: function() {
          return this.getValue() === !0 ? (this.__checkbox.setAttribute("checked", "checked"), this.__checkbox.checked = !0, this.__prev = !0) : (this.__checkbox.checked = !1, this.__prev = !1), dt(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "updateDisplay", this).call(this);
        }
      }]), e;
    }(Et), sl = function(t) {
      _t(e, t);
      function e(n, r, o) {
        Ye(this, e);
        var i = pt(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, n, r)), c = o, u = i;
        if (i.__select = document.createElement("select"), y.isArray(c)) {
          var m = {};
          y.each(c, function(b) {
            m[b] = b;
          }), c = m;
        }
        return y.each(c, function(b, g) {
          var T = document.createElement("option");
          T.innerHTML = g, T.setAttribute("value", b), u.__select.appendChild(T);
        }), i.updateDisplay(), _.bind(i.__select, "change", function() {
          var b = this.options[this.selectedIndex].value;
          u.setValue(b);
        }), i.domElement.appendChild(i.__select), i;
      }
      return We(e, [{
        key: "setValue",
        value: function(r) {
          var o = dt(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "setValue", this).call(this, r);
          return this.__onFinishChange && this.__onFinishChange.call(this, this.getValue()), o;
        }
      }, {
        key: "updateDisplay",
        value: function() {
          return _.isActive(this.__select) ? this : (this.__select.value = this.getValue(), dt(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "updateDisplay", this).call(this));
        }
      }]), e;
    }(Et), al = function(t) {
      _t(e, t);
      function e(n, r) {
        Ye(this, e);
        var o = pt(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, n, r)), i = o;
        function c() {
          i.setValue(i.__input.value);
        }
        function u() {
          i.__onFinishChange && i.__onFinishChange.call(i, i.getValue());
        }
        return o.__input = document.createElement("input"), o.__input.setAttribute("type", "text"), _.bind(o.__input, "keyup", c), _.bind(o.__input, "change", c), _.bind(o.__input, "blur", u), _.bind(o.__input, "keydown", function(m) {
          m.keyCode === 13 && this.blur();
        }), o.updateDisplay(), o.domElement.appendChild(o.__input), o;
      }
      return We(e, [{
        key: "updateDisplay",
        value: function() {
          return _.isActive(this.__input) || (this.__input.value = this.getValue()), dt(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "updateDisplay", this).call(this);
        }
      }]), e;
    }(Et);
    function Vo(t) {
      var e = t.toString();
      return e.indexOf(".") > -1 ? e.length - e.indexOf(".") - 1 : 0;
    }
    var Vi = function(t) {
      _t(e, t);
      function e(n, r, o) {
        Ye(this, e);
        var i = pt(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, n, r)), c = o || {};
        return i.__min = c.min, i.__max = c.max, i.__step = c.step, y.isUndefined(i.__step) ? i.initialValue === 0 ? i.__impliedStep = 1 : i.__impliedStep = Math.pow(10, Math.floor(Math.log(Math.abs(i.initialValue)) / Math.LN10)) / 10 : i.__impliedStep = i.__step, i.__precision = Vo(i.__impliedStep), i;
      }
      return We(e, [{
        key: "setValue",
        value: function(r) {
          var o = r;
          return this.__min !== void 0 && o < this.__min ? o = this.__min : this.__max !== void 0 && o > this.__max && (o = this.__max), this.__step !== void 0 && o % this.__step !== 0 && (o = Math.round(o / this.__step) * this.__step), dt(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "setValue", this).call(this, o);
        }
      }, {
        key: "min",
        value: function(r) {
          return this.__min = r, this;
        }
      }, {
        key: "max",
        value: function(r) {
          return this.__max = r, this;
        }
      }, {
        key: "step",
        value: function(r) {
          return this.__step = r, this.__impliedStep = r, this.__precision = Vo(r), this;
        }
      }]), e;
    }(Et);
    function ul(t, e) {
      var n = Math.pow(10, e);
      return Math.round(t * n) / n;
    }
    var En = function(t) {
      _t(e, t);
      function e(n, r, o) {
        Ye(this, e);
        var i = pt(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, n, r, o));
        i.__truncationSuspended = !1;
        var c = i, u = void 0;
        function m() {
          var L = parseFloat(c.__input.value);
          y.isNaN(L) || c.setValue(L);
        }
        function b() {
          c.__onFinishChange && c.__onFinishChange.call(c, c.getValue());
        }
        function g() {
          b();
        }
        function T(L) {
          var D = u - L.clientY;
          c.setValue(c.getValue() + D * c.__impliedStep), u = L.clientY;
        }
        function z() {
          _.unbind(window, "mousemove", T), _.unbind(window, "mouseup", z), b();
        }
        function Q(L) {
          _.bind(window, "mousemove", T), _.bind(window, "mouseup", z), u = L.clientY;
        }
        return i.__input = document.createElement("input"), i.__input.setAttribute("type", "text"), _.bind(i.__input, "change", m), _.bind(i.__input, "blur", g), _.bind(i.__input, "mousedown", Q), _.bind(i.__input, "keydown", function(L) {
          L.keyCode === 13 && (c.__truncationSuspended = !0, this.blur(), c.__truncationSuspended = !1, b());
        }), i.updateDisplay(), i.domElement.appendChild(i.__input), i;
      }
      return We(e, [{
        key: "updateDisplay",
        value: function() {
          return this.__input.value = this.__truncationSuspended ? this.getValue() : ul(this.getValue(), this.__precision), dt(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "updateDisplay", this).call(this);
        }
      }]), e;
    }(Vi);
    function Go(t, e, n, r, o) {
      return r + (o - r) * ((t - e) / (n - e));
    }
    var Jn = function(t) {
      _t(e, t);
      function e(n, r, o, i, c) {
        Ye(this, e);
        var u = pt(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, n, r, { min: o, max: i, step: c })), m = u;
        u.__background = document.createElement("div"), u.__foreground = document.createElement("div"), _.bind(u.__background, "mousedown", b), _.bind(u.__background, "touchstart", z), _.addClass(u.__background, "slider"), _.addClass(u.__foreground, "slider-fg");
        function b(D) {
          document.activeElement.blur(), _.bind(window, "mousemove", g), _.bind(window, "mouseup", T), g(D);
        }
        function g(D) {
          D.preventDefault();
          var j = m.__background.getBoundingClientRect();
          return m.setValue(Go(D.clientX, j.left, j.right, m.__min, m.__max)), !1;
        }
        function T() {
          _.unbind(window, "mousemove", g), _.unbind(window, "mouseup", T), m.__onFinishChange && m.__onFinishChange.call(m, m.getValue());
        }
        function z(D) {
          D.touches.length === 1 && (_.bind(window, "touchmove", Q), _.bind(window, "touchend", L), Q(D));
        }
        function Q(D) {
          var j = D.touches[0].clientX, q = m.__background.getBoundingClientRect();
          m.setValue(Go(j, q.left, q.right, m.__min, m.__max));
        }
        function L() {
          _.unbind(window, "touchmove", Q), _.unbind(window, "touchend", L), m.__onFinishChange && m.__onFinishChange.call(m, m.getValue());
        }
        return u.updateDisplay(), u.__background.appendChild(u.__foreground), u.domElement.appendChild(u.__background), u;
      }
      return We(e, [{
        key: "updateDisplay",
        value: function() {
          var r = (this.getValue() - this.__min) / (this.__max - this.__min);
          return this.__foreground.style.width = r * 100 + "%", dt(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "updateDisplay", this).call(this);
        }
      }]), e;
    }(Vi), Gi = function(t) {
      _t(e, t);
      function e(n, r, o) {
        Ye(this, e);
        var i = pt(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, n, r)), c = i;
        return i.__button = document.createElement("div"), i.__button.innerHTML = o === void 0 ? "Fire" : o, _.bind(i.__button, "click", function(u) {
          return u.preventDefault(), c.fire(), !1;
        }), _.addClass(i.__button, "button"), i.domElement.appendChild(i.__button), i;
      }
      return We(e, [{
        key: "fire",
        value: function() {
          this.__onChange && this.__onChange.call(this), this.getValue().call(this.object), this.__onFinishChange && this.__onFinishChange.call(this, this.getValue());
        }
      }]), e;
    }(Et), Qn = function(t) {
      _t(e, t);
      function e(n, r) {
        Ye(this, e);
        var o = pt(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, n, r));
        o.__color = new Re(o.getValue()), o.__temp = new Re(0);
        var i = o;
        o.domElement = document.createElement("div"), _.makeSelectable(o.domElement, !1), o.__selector = document.createElement("div"), o.__selector.className = "selector", o.__saturation_field = document.createElement("div"), o.__saturation_field.className = "saturation-field", o.__field_knob = document.createElement("div"), o.__field_knob.className = "field-knob", o.__field_knob_border = "2px solid ", o.__hue_knob = document.createElement("div"), o.__hue_knob.className = "hue-knob", o.__hue_field = document.createElement("div"), o.__hue_field.className = "hue-field", o.__input = document.createElement("input"), o.__input.type = "text", o.__input_textShadow = "0 1px 1px ", _.bind(o.__input, "keydown", function(D) {
          D.keyCode === 13 && T.call(this);
        }), _.bind(o.__input, "blur", T), _.bind(o.__selector, "mousedown", function() {
          _.addClass(this, "drag").bind(window, "mouseup", function() {
            _.removeClass(i.__selector, "drag");
          });
        }), _.bind(o.__selector, "touchstart", function() {
          _.addClass(this, "drag").bind(window, "touchend", function() {
            _.removeClass(i.__selector, "drag");
          });
        });
        var c = document.createElement("div");
        y.extend(o.__selector.style, {
          width: "122px",
          height: "102px",
          padding: "3px",
          backgroundColor: "#222",
          boxShadow: "0px 1px 3px rgba(0,0,0,0.3)"
        }), y.extend(o.__field_knob.style, {
          position: "absolute",
          width: "12px",
          height: "12px",
          border: o.__field_knob_border + (o.__color.v < 0.5 ? "#fff" : "#000"),
          boxShadow: "0px 1px 3px rgba(0,0,0,0.5)",
          borderRadius: "12px",
          zIndex: 1
        }), y.extend(o.__hue_knob.style, {
          position: "absolute",
          width: "15px",
          height: "2px",
          borderRight: "4px solid #fff",
          zIndex: 1
        }), y.extend(o.__saturation_field.style, {
          width: "100px",
          height: "100px",
          border: "1px solid #555",
          marginRight: "3px",
          display: "inline-block",
          cursor: "pointer"
        }), y.extend(c.style, {
          width: "100%",
          height: "100%",
          background: "none"
        }), Ho(c, "top", "rgba(0,0,0,0)", "#000"), y.extend(o.__hue_field.style, {
          width: "15px",
          height: "100px",
          border: "1px solid #555",
          cursor: "ns-resize",
          position: "absolute",
          top: "3px",
          right: "3px"
        }), fl(o.__hue_field), y.extend(o.__input.style, {
          outline: "none",
          textAlign: "center",
          color: "#fff",
          border: 0,
          fontWeight: "bold",
          textShadow: o.__input_textShadow + "rgba(0,0,0,0.7)"
        }), _.bind(o.__saturation_field, "mousedown", u), _.bind(o.__saturation_field, "touchstart", u), _.bind(o.__field_knob, "mousedown", u), _.bind(o.__field_knob, "touchstart", u), _.bind(o.__hue_field, "mousedown", m), _.bind(o.__hue_field, "touchstart", m);
        function u(D) {
          Q(D), _.bind(window, "mousemove", Q), _.bind(window, "touchmove", Q), _.bind(window, "mouseup", b), _.bind(window, "touchend", b);
        }
        function m(D) {
          L(D), _.bind(window, "mousemove", L), _.bind(window, "touchmove", L), _.bind(window, "mouseup", g), _.bind(window, "touchend", g);
        }
        function b() {
          _.unbind(window, "mousemove", Q), _.unbind(window, "touchmove", Q), _.unbind(window, "mouseup", b), _.unbind(window, "touchend", b), z();
        }
        function g() {
          _.unbind(window, "mousemove", L), _.unbind(window, "touchmove", L), _.unbind(window, "mouseup", g), _.unbind(window, "touchend", g), z();
        }
        function T() {
          var D = Kn(this.value);
          D !== !1 ? (i.__color.__state = D, i.setValue(i.__color.toOriginal())) : this.value = i.__color.toString();
        }
        function z() {
          i.__onFinishChange && i.__onFinishChange.call(i, i.__color.toOriginal());
        }
        o.__saturation_field.appendChild(c), o.__selector.appendChild(o.__field_knob), o.__selector.appendChild(o.__saturation_field), o.__selector.appendChild(o.__hue_field), o.__hue_field.appendChild(o.__hue_knob), o.domElement.appendChild(o.__input), o.domElement.appendChild(o.__selector), o.updateDisplay();
        function Q(D) {
          D.type.indexOf("touch") === -1 && D.preventDefault();
          var j = i.__saturation_field.getBoundingClientRect(), q = D.touches && D.touches[0] || D, ue = q.clientX, ce = q.clientY, Ee = (ue - j.left) / (j.right - j.left), le = 1 - (ce - j.top) / (j.bottom - j.top);
          return le > 1 ? le = 1 : le < 0 && (le = 0), Ee > 1 ? Ee = 1 : Ee < 0 && (Ee = 0), i.__color.v = le, i.__color.s = Ee, i.setValue(i.__color.toOriginal()), !1;
        }
        function L(D) {
          D.type.indexOf("touch") === -1 && D.preventDefault();
          var j = i.__hue_field.getBoundingClientRect(), q = D.touches && D.touches[0] || D, ue = q.clientY, ce = 1 - (ue - j.top) / (j.bottom - j.top);
          return ce > 1 ? ce = 1 : ce < 0 && (ce = 0), i.__color.h = ce * 360, i.setValue(i.__color.toOriginal()), !1;
        }
        return o;
      }
      return We(e, [{
        key: "updateDisplay",
        value: function() {
          var r = Kn(this.getValue());
          if (r !== !1) {
            var o = !1;
            y.each(Re.COMPONENTS, function(u) {
              if (!y.isUndefined(r[u]) && !y.isUndefined(this.__color.__state[u]) && r[u] !== this.__color.__state[u])
                return o = !0, {};
            }, this), o && y.extend(this.__color.__state, r);
          }
          y.extend(this.__temp.__state, this.__color.__state), this.__temp.a = 1;
          var i = this.__color.v < 0.5 || this.__color.s > 0.5 ? 255 : 0, c = 255 - i;
          y.extend(this.__field_knob.style, {
            marginLeft: 100 * this.__color.s - 7 + "px",
            marginTop: 100 * (1 - this.__color.v) - 7 + "px",
            backgroundColor: this.__temp.toHexString(),
            border: this.__field_knob_border + "rgb(" + i + "," + i + "," + i + ")"
          }), this.__hue_knob.style.marginTop = (1 - this.__color.h / 360) * 100 + "px", this.__temp.s = 1, this.__temp.v = 1, Ho(this.__saturation_field, "left", "#fff", this.__temp.toHexString()), this.__input.value = this.__color.toString(), y.extend(this.__input.style, {
            backgroundColor: this.__color.toHexString(),
            color: "rgb(" + i + "," + i + "," + i + ")",
            textShadow: this.__input_textShadow + "rgba(" + c + "," + c + "," + c + ",.7)"
          });
        }
      }]), e;
    }(Et), cl = ["-moz-", "-o-", "-webkit-", "-ms-", ""];
    function Ho(t, e, n, r) {
      t.style.background = "", y.each(cl, function(o) {
        t.style.cssText += "background: " + o + "linear-gradient(" + e + ", " + n + " 0%, " + r + " 100%); ";
      });
    }
    function fl(t) {
      t.style.background = "", t.style.cssText += "background: -moz-linear-gradient(top,  #ff0000 0%, #ff00ff 17%, #0000ff 34%, #00ffff 50%, #00ff00 67%, #ffff00 84%, #ff0000 100%);", t.style.cssText += "background: -webkit-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);", t.style.cssText += "background: -o-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);", t.style.cssText += "background: -ms-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);", t.style.cssText += "background: linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);";
    }
    var ll = {
      load: function(e, n) {
        var r = n || document, o = r.createElement("link");
        o.type = "text/css", o.rel = "stylesheet", o.href = e, r.getElementsByTagName("head")[0].appendChild(o);
      },
      inject: function(e, n) {
        var r = n || document, o = document.createElement("style");
        o.type = "text/css", o.innerHTML = e;
        var i = r.getElementsByTagName("head")[0];
        try {
          i.appendChild(o);
        } catch {
        }
      }
    }, dl = `<div id="dg-save" class="dg dialogue">

      Here's the new load parameter for your <code>GUI</code>'s constructor:

      <textarea id="dg-new-constructor"></textarea>

      <div id="dg-save-locally">

        <input id="dg-local-storage" type="checkbox"/> Automatically save
        values to <code>localStorage</code> on exit.

        <div id="dg-local-explain">The values saved to <code>localStorage</code> will
          override those passed to <code>dat.GUI</code>'s constructor. This makes it
          easier to work incrementally, but <code>localStorage</code> is fragile,
          and your friends may not see the same values you do.

        </div>

      </div>

    </div>`, ml = function(e, n) {
      var r = e[n];
      return y.isArray(arguments[2]) || y.isObject(arguments[2]) ? new sl(e, n, arguments[2]) : y.isNumber(r) ? y.isNumber(arguments[2]) && y.isNumber(arguments[3]) ? y.isNumber(arguments[4]) ? new Jn(e, n, arguments[2], arguments[3], arguments[4]) : new Jn(e, n, arguments[2], arguments[3]) : y.isNumber(arguments[4]) ? new En(e, n, { min: arguments[2], max: arguments[3], step: arguments[4] }) : new En(e, n, { min: arguments[2], max: arguments[3] }) : y.isString(r) ? new al(e, n) : y.isFunction(r) ? new Gi(e, n, "") : y.isBoolean(r) ? new zi(e, n) : null;
    };
    function _l(t) {
      setTimeout(t, 1e3 / 60);
    }
    var pl = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || _l, hl = function() {
      function t() {
        Ye(this, t), this.backgroundElement = document.createElement("div"), y.extend(this.backgroundElement.style, {
          backgroundColor: "rgba(0,0,0,0.8)",
          top: 0,
          left: 0,
          display: "none",
          zIndex: "1000",
          opacity: 0,
          WebkitTransition: "opacity 0.2s linear",
          transition: "opacity 0.2s linear"
        }), _.makeFullscreen(this.backgroundElement), this.backgroundElement.style.position = "fixed", this.domElement = document.createElement("div"), y.extend(this.domElement.style, {
          position: "fixed",
          display: "none",
          zIndex: "1001",
          opacity: 0,
          WebkitTransition: "-webkit-transform 0.2s ease-out, opacity 0.2s linear",
          transition: "transform 0.2s ease-out, opacity 0.2s linear"
        }), document.body.appendChild(this.backgroundElement), document.body.appendChild(this.domElement);
        var e = this;
        _.bind(this.backgroundElement, "click", function() {
          e.hide();
        });
      }
      return We(t, [{
        key: "show",
        value: function() {
          var n = this;
          this.backgroundElement.style.display = "block", this.domElement.style.display = "block", this.domElement.style.opacity = 0, this.domElement.style.webkitTransform = "scale(1.1)", this.layout(), y.defer(function() {
            n.backgroundElement.style.opacity = 1, n.domElement.style.opacity = 1, n.domElement.style.webkitTransform = "scale(1)";
          });
        }
      }, {
        key: "hide",
        value: function() {
          var n = this, r = function o() {
            n.domElement.style.display = "none", n.backgroundElement.style.display = "none", _.unbind(n.domElement, "webkitTransitionEnd", o), _.unbind(n.domElement, "transitionend", o), _.unbind(n.domElement, "oTransitionEnd", o);
          };
          _.bind(this.domElement, "webkitTransitionEnd", r), _.bind(this.domElement, "transitionend", r), _.bind(this.domElement, "oTransitionEnd", r), this.backgroundElement.style.opacity = 0, this.domElement.style.opacity = 0, this.domElement.style.webkitTransform = "scale(1.1)";
        }
      }, {
        key: "layout",
        value: function() {
          this.domElement.style.left = window.innerWidth / 2 - _.getWidth(this.domElement) / 2 + "px", this.domElement.style.top = window.innerHeight / 2 - _.getHeight(this.domElement) / 2 + "px";
        }
      }]), t;
    }(), bl = tl(`.dg ul{list-style:none;margin:0;padding:0;width:100%;clear:both}.dg.ac{position:fixed;top:0;left:0;right:0;height:0;z-index:0}.dg:not(.ac) .main{overflow:hidden}.dg.main{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear}.dg.main.taller-than-window{overflow-y:auto}.dg.main.taller-than-window .close-button{opacity:1;margin-top:-1px;border-top:1px solid #2c2c2c}.dg.main ul.closed .close-button{opacity:1 !important}.dg.main:hover .close-button,.dg.main .close-button.drag{opacity:1}.dg.main .close-button{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear;border:0;line-height:19px;height:20px;cursor:pointer;text-align:center;background-color:#000}.dg.main .close-button.close-top{position:relative}.dg.main .close-button.close-bottom{position:absolute}.dg.main .close-button:hover{background-color:#111}.dg.a{float:right;margin-right:15px;overflow-y:visible}.dg.a.has-save>ul.close-top{margin-top:0}.dg.a.has-save>ul.close-bottom{margin-top:27px}.dg.a.has-save>ul.closed{margin-top:0}.dg.a .save-row{top:0;z-index:1002}.dg.a .save-row.close-top{position:relative}.dg.a .save-row.close-bottom{position:fixed}.dg li{-webkit-transition:height .1s ease-out;-o-transition:height .1s ease-out;-moz-transition:height .1s ease-out;transition:height .1s ease-out;-webkit-transition:overflow .1s linear;-o-transition:overflow .1s linear;-moz-transition:overflow .1s linear;transition:overflow .1s linear}.dg li:not(.folder){cursor:auto;height:27px;line-height:27px;padding:0 4px 0 5px}.dg li.folder{padding:0;border-left:4px solid rgba(0,0,0,0)}.dg li.title{cursor:pointer;margin-left:-4px}.dg .closed li:not(.title),.dg .closed ul li,.dg .closed ul li>*{height:0;overflow:hidden;border:0}.dg .cr{clear:both;padding-left:3px;height:27px;overflow:hidden}.dg .property-name{cursor:default;float:left;clear:left;width:40%;overflow:hidden;text-overflow:ellipsis}.dg .cr.function .property-name{width:100%}.dg .c{float:left;width:60%;position:relative}.dg .c input[type=text]{border:0;margin-top:4px;padding:3px;width:100%;float:right}.dg .has-slider input[type=text]{width:30%;margin-left:0}.dg .slider{float:left;width:66%;margin-left:-5px;margin-right:0;height:19px;margin-top:4px}.dg .slider-fg{height:100%}.dg .c input[type=checkbox]{margin-top:7px}.dg .c select{margin-top:5px}.dg .cr.function,.dg .cr.function .property-name,.dg .cr.function *,.dg .cr.boolean,.dg .cr.boolean *{cursor:pointer}.dg .cr.color{overflow:visible}.dg .selector{display:none;position:absolute;margin-left:-9px;margin-top:23px;z-index:10}.dg .c:hover .selector,.dg .selector.drag{display:block}.dg li.save-row{padding:0}.dg li.save-row .button{display:inline-block;padding:0px 6px}.dg.dialogue{background-color:#222;width:460px;padding:15px;font-size:13px;line-height:15px}#dg-new-constructor{padding:10px;color:#222;font-family:Monaco, monospace;font-size:10px;border:0;resize:none;box-shadow:inset 1px 1px 1px #888;word-wrap:break-word;margin:12px 0;display:block;width:440px;overflow-y:scroll;height:100px;position:relative}#dg-local-explain{display:none;font-size:11px;line-height:17px;border-radius:3px;background-color:#333;padding:8px;margin-top:10px}#dg-local-explain code{font-size:10px}#dat-gui-save-locally{display:none}.dg{color:#eee;font:11px 'Lucida Grande', sans-serif;text-shadow:0 -1px 0 #111}.dg.main::-webkit-scrollbar{width:5px;background:#1a1a1a}.dg.main::-webkit-scrollbar-corner{height:0;display:none}.dg.main::-webkit-scrollbar-thumb{border-radius:5px;background:#676767}.dg li:not(.folder){background:#1a1a1a;border-bottom:1px solid #2c2c2c}.dg li.save-row{line-height:25px;background:#dad5cb;border:0}.dg li.save-row select{margin-left:5px;width:108px}.dg li.save-row .button{margin-left:5px;margin-top:1px;border-radius:2px;font-size:9px;line-height:7px;padding:4px 4px 5px 4px;background:#c5bdad;color:#fff;text-shadow:0 1px 0 #b0a58f;box-shadow:0 -1px 0 #b0a58f;cursor:pointer}.dg li.save-row .button.gears{background:#c5bdad url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAANCAYAAAB/9ZQ7AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQJJREFUeNpiYKAU/P//PwGIC/ApCABiBSAW+I8AClAcgKxQ4T9hoMAEUrxx2QSGN6+egDX+/vWT4e7N82AMYoPAx/evwWoYoSYbACX2s7KxCxzcsezDh3evFoDEBYTEEqycggWAzA9AuUSQQgeYPa9fPv6/YWm/Acx5IPb7ty/fw+QZblw67vDs8R0YHyQhgObx+yAJkBqmG5dPPDh1aPOGR/eugW0G4vlIoTIfyFcA+QekhhHJhPdQxbiAIguMBTQZrPD7108M6roWYDFQiIAAv6Aow/1bFwXgis+f2LUAynwoIaNcz8XNx3Dl7MEJUDGQpx9gtQ8YCueB+D26OECAAQDadt7e46D42QAAAABJRU5ErkJggg==) 2px 1px no-repeat;height:7px;width:8px}.dg li.save-row .button:hover{background-color:#bab19e;box-shadow:0 -1px 0 #b0a58f}.dg li.folder{border-bottom:0}.dg li.title{padding-left:16px;background:#000 url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlI+hKgFxoCgAOw==) 6px 10px no-repeat;cursor:pointer;border-bottom:1px solid rgba(255,255,255,0.2)}.dg .closed li.title{background-image:url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlGIWqMCbWAEAOw==)}.dg .cr.boolean{border-left:3px solid #806787}.dg .cr.color{border-left:3px solid}.dg .cr.function{border-left:3px solid #e61d5f}.dg .cr.number{border-left:3px solid #2FA1D6}.dg .cr.number input[type=text]{color:#2FA1D6}.dg .cr.string{border-left:3px solid #1ed36f}.dg .cr.string input[type=text]{color:#1ed36f}.dg .cr.function:hover,.dg .cr.boolean:hover{background:#111}.dg .c input[type=text]{background:#303030;outline:none}.dg .c input[type=text]:hover{background:#3c3c3c}.dg .c input[type=text]:focus{background:#494949;color:#fff}.dg .c .slider{background:#303030;cursor:ew-resize}.dg .c .slider-fg{background:#2FA1D6;max-width:100%}.dg .c .slider:hover{background:#3c3c3c}.dg .c .slider:hover .slider-fg{background:#44abda}
    `);
    ll.inject(bl);
    var Xo = "dg", Yo = 72, Wo = 20, Ht = "Default", kt = function() {
      try {
        return !!window.localStorage;
      } catch {
        return !1;
      }
    }(), $t = void 0, jo = !0, Rt = void 0, Wn = !1, Hi = [], oe = function t(e) {
      var n = this, r = e || {};
      this.domElement = document.createElement("div"), this.__ul = document.createElement("ul"), this.domElement.appendChild(this.__ul), _.addClass(this.domElement, Xo), this.__folders = {}, this.__controllers = [], this.__rememberedObjects = [], this.__rememberedObjectIndecesToControllers = [], this.__listening = [], r = y.defaults(r, {
        closeOnTop: !1,
        autoPlace: !0,
        width: t.DEFAULT_WIDTH
      }), r = y.defaults(r, {
        resizable: r.autoPlace,
        hideable: r.autoPlace
      }), y.isUndefined(r.load) ? r.load = { preset: Ht } : r.preset && (r.load.preset = r.preset), y.isUndefined(r.parent) && r.hideable && Hi.push(this), r.resizable = y.isUndefined(r.parent) && r.resizable, r.autoPlace && y.isUndefined(r.scrollable) && (r.scrollable = !0);
      var o = kt && localStorage.getItem(wt(this, "isLocal")) === "true", i = void 0, c = void 0;
      if (Object.defineProperties(
        this,
        {
          parent: {
            get: function() {
              return r.parent;
            }
          },
          scrollable: {
            get: function() {
              return r.scrollable;
            }
          },
          autoPlace: {
            get: function() {
              return r.autoPlace;
            }
          },
          closeOnTop: {
            get: function() {
              return r.closeOnTop;
            }
          },
          preset: {
            get: function() {
              return n.parent ? n.getRoot().preset : r.load.preset;
            },
            set: function(z) {
              n.parent ? n.getRoot().preset = z : r.load.preset = z, gl(this), n.revert();
            }
          },
          width: {
            get: function() {
              return r.width;
            },
            set: function(z) {
              r.width = z, er(n, z);
            }
          },
          name: {
            get: function() {
              return r.name;
            },
            set: function(z) {
              r.name = z, c && (c.innerHTML = r.name);
            }
          },
          closed: {
            get: function() {
              return r.closed;
            },
            set: function(z) {
              r.closed = z, r.closed ? _.addClass(n.__ul, t.CLASS_CLOSED) : _.removeClass(n.__ul, t.CLASS_CLOSED), this.onResize(), n.__closeButton && (n.__closeButton.innerHTML = z ? t.TEXT_OPEN : t.TEXT_CLOSED);
            }
          },
          load: {
            get: function() {
              return r.load;
            }
          },
          useLocalStorage: {
            get: function() {
              return o;
            },
            set: function(z) {
              kt && (o = z, z ? _.bind(window, "unload", i) : _.unbind(window, "unload", i), localStorage.setItem(wt(n, "isLocal"), z));
            }
          }
        }
      ), y.isUndefined(r.parent)) {
        if (this.closed = r.closed || !1, _.addClass(this.domElement, t.CLASS_MAIN), _.makeSelectable(this.domElement, !1), kt && o) {
          n.useLocalStorage = !0;
          var u = localStorage.getItem(wt(this, "gui"));
          u && (r.load = JSON.parse(u));
        }
        this.__closeButton = document.createElement("div"), this.__closeButton.innerHTML = t.TEXT_CLOSED, _.addClass(this.__closeButton, t.CLASS_CLOSE_BUTTON), r.closeOnTop ? (_.addClass(this.__closeButton, t.CLASS_CLOSE_TOP), this.domElement.insertBefore(this.__closeButton, this.domElement.childNodes[0])) : (_.addClass(this.__closeButton, t.CLASS_CLOSE_BOTTOM), this.domElement.appendChild(this.__closeButton)), _.bind(this.__closeButton, "click", function() {
          n.closed = !n.closed;
        });
      } else {
        r.closed === void 0 && (r.closed = !0);
        var m = document.createTextNode(r.name);
        _.addClass(m, "controller-name"), c = Er(n, m);
        var b = function(z) {
          return z.preventDefault(), n.closed = !n.closed, !1;
        };
        _.addClass(this.__ul, t.CLASS_CLOSED), _.addClass(c, "title"), _.bind(c, "click", b), r.closed || (this.closed = !1);
      }
      r.autoPlace && (y.isUndefined(r.parent) && (jo && (Rt = document.createElement("div"), _.addClass(Rt, Xo), _.addClass(Rt, t.CLASS_AUTO_PLACE_CONTAINER), document.body.appendChild(Rt), jo = !1), Rt.appendChild(this.domElement), _.addClass(this.domElement, t.CLASS_AUTO_PLACE)), this.parent || er(n, r.width)), this.__resizeHandler = function() {
        n.onResizeDebounced();
      }, _.bind(window, "resize", this.__resizeHandler), _.bind(this.__ul, "webkitTransitionEnd", this.__resizeHandler), _.bind(this.__ul, "transitionend", this.__resizeHandler), _.bind(this.__ul, "oTransitionEnd", this.__resizeHandler), this.onResize(), r.resizable && El(this), i = function() {
        kt && localStorage.getItem(wt(n, "isLocal")) === "true" && localStorage.setItem(wt(n, "gui"), JSON.stringify(n.getSaveObject()));
      }, this.saveToLocalStorageIfPossible = i;
      function g() {
        var T = n.getRoot();
        T.width += 1, y.defer(function() {
          T.width -= 1;
        });
      }
      r.parent || g();
    };
    oe.toggleHide = function() {
      Wn = !Wn, y.each(Hi, function(t) {
        t.domElement.style.display = Wn ? "none" : "";
      });
    };
    oe.CLASS_AUTO_PLACE = "a";
    oe.CLASS_AUTO_PLACE_CONTAINER = "ac";
    oe.CLASS_MAIN = "main";
    oe.CLASS_CONTROLLER_ROW = "cr";
    oe.CLASS_TOO_TALL = "taller-than-window";
    oe.CLASS_CLOSED = "closed";
    oe.CLASS_CLOSE_BUTTON = "close-button";
    oe.CLASS_CLOSE_TOP = "close-top";
    oe.CLASS_CLOSE_BOTTOM = "close-bottom";
    oe.CLASS_DRAG = "drag";
    oe.DEFAULT_WIDTH = 245;
    oe.TEXT_CLOSED = "Close Controls";
    oe.TEXT_OPEN = "Open Controls";
    oe._keydownHandler = function(t) {
      document.activeElement.type !== "text" && (t.which === Yo || t.keyCode === Yo) && oe.toggleHide();
    };
    _.bind(window, "keydown", oe._keydownHandler, !1);
    y.extend(
      oe.prototype,
      {
        add: function(e, n) {
          return zt(this, e, n, {
            factoryArgs: Array.prototype.slice.call(arguments, 2)
          });
        },
        addColor: function(e, n) {
          return zt(this, e, n, {
            color: !0
          });
        },
        remove: function(e) {
          this.__ul.removeChild(e.__li), this.__controllers.splice(this.__controllers.indexOf(e), 1);
          var n = this;
          y.defer(function() {
            n.onResize();
          });
        },
        destroy: function() {
          if (this.parent)
            throw new Error("Only the root GUI should be removed with .destroy(). For subfolders, use gui.removeFolder(folder) instead.");
          this.autoPlace && Rt.removeChild(this.domElement);
          var e = this;
          y.each(this.__folders, function(n) {
            e.removeFolder(n);
          }), _.unbind(window, "keydown", oe._keydownHandler, !1), Ko(this);
        },
        addFolder: function(e) {
          if (this.__folders[e] !== void 0)
            throw new Error('You already have a folder in this GUI by the name "' + e + '"');
          var n = { name: e, parent: this };
          n.autoPlace = this.autoPlace, this.load && this.load.folders && this.load.folders[e] && (n.closed = this.load.folders[e].closed, n.load = this.load.folders[e]);
          var r = new oe(n);
          this.__folders[e] = r;
          var o = Er(this, r.domElement);
          return _.addClass(o, "folder"), r;
        },
        removeFolder: function(e) {
          this.__ul.removeChild(e.domElement.parentElement), delete this.__folders[e.name], this.load && this.load.folders && this.load.folders[e.name] && delete this.load.folders[e.name], Ko(e);
          var n = this;
          y.each(e.__folders, function(r) {
            e.removeFolder(r);
          }), y.defer(function() {
            n.onResize();
          });
        },
        open: function() {
          this.closed = !1;
        },
        close: function() {
          this.closed = !0;
        },
        hide: function() {
          this.domElement.style.display = "none";
        },
        show: function() {
          this.domElement.style.display = "";
        },
        onResize: function() {
          var e = this.getRoot();
          if (e.scrollable) {
            var n = _.getOffset(e.__ul).top, r = 0;
            y.each(e.__ul.childNodes, function(o) {
              e.autoPlace && o === e.__save_row || (r += _.getHeight(o));
            }), window.innerHeight - n - Wo < r ? (_.addClass(e.domElement, oe.CLASS_TOO_TALL), e.__ul.style.height = window.innerHeight - n - Wo + "px") : (_.removeClass(e.domElement, oe.CLASS_TOO_TALL), e.__ul.style.height = "auto");
          }
          e.__resize_handle && y.defer(function() {
            e.__resize_handle.style.height = e.__ul.offsetHeight + "px";
          }), e.__closeButton && (e.__closeButton.style.width = e.width + "px");
        },
        onResizeDebounced: y.debounce(function() {
          this.onResize();
        }, 50),
        remember: function() {
          if (y.isUndefined($t) && ($t = new hl(), $t.domElement.innerHTML = dl), this.parent)
            throw new Error("You can only call remember on a top level GUI.");
          var e = this;
          y.each(Array.prototype.slice.call(arguments), function(n) {
            e.__rememberedObjects.length === 0 && yl(e), e.__rememberedObjects.indexOf(n) === -1 && e.__rememberedObjects.push(n);
          }), this.autoPlace && er(this, this.width);
        },
        getRoot: function() {
          for (var e = this; e.parent; )
            e = e.parent;
          return e;
        },
        getSaveObject: function() {
          var e = this.load;
          return e.closed = this.closed, this.__rememberedObjects.length > 0 && (e.preset = this.preset, e.remembered || (e.remembered = {}), e.remembered[this.preset] = _n(this)), e.folders = {}, y.each(this.__folders, function(n, r) {
            e.folders[r] = n.getSaveObject();
          }), e;
        },
        save: function() {
          this.load.remembered || (this.load.remembered = {}), this.load.remembered[this.preset] = _n(this), Zn(this, !1), this.saveToLocalStorageIfPossible();
        },
        saveAs: function(e) {
          this.load.remembered || (this.load.remembered = {}, this.load.remembered[Ht] = _n(this, !0)), this.load.remembered[e] = _n(this), this.preset = e, qn(this, e, !0), this.saveToLocalStorageIfPossible();
        },
        revert: function(e) {
          y.each(this.__controllers, function(n) {
            this.getRoot().load.remembered ? Xi(e || this.getRoot(), n) : n.setValue(n.initialValue), n.__onFinishChange && n.__onFinishChange.call(n, n.getValue());
          }, this), y.each(this.__folders, function(n) {
            n.revert(n);
          }), e || Zn(this.getRoot(), !1);
        },
        listen: function(e) {
          var n = this.__listening.length === 0;
          this.__listening.push(e), n && Yi(this.__listening);
        },
        updateDisplay: function() {
          y.each(this.__controllers, function(e) {
            e.updateDisplay();
          }), y.each(this.__folders, function(e) {
            e.updateDisplay();
          });
        }
      }
    );
    function Er(t, e, n) {
      var r = document.createElement("li");
      return e && r.appendChild(e), n ? t.__ul.insertBefore(r, n) : t.__ul.appendChild(r), t.onResize(), r;
    }
    function Ko(t) {
      _.unbind(window, "resize", t.__resizeHandler), t.saveToLocalStorageIfPossible && _.unbind(window, "unload", t.saveToLocalStorageIfPossible);
    }
    function Zn(t, e) {
      var n = t.__preset_select[t.__preset_select.selectedIndex];
      e ? n.innerHTML = n.value + "*" : n.innerHTML = n.value;
    }
    function xl(t, e, n) {
      if (n.__li = e, n.__gui = t, y.extend(n, {
        options: function(c) {
          if (arguments.length > 1) {
            var u = n.__li.nextElementSibling;
            return n.remove(), zt(t, n.object, n.property, {
              before: u,
              factoryArgs: [y.toArray(arguments)]
            });
          }
          if (y.isArray(c) || y.isObject(c)) {
            var m = n.__li.nextElementSibling;
            return n.remove(), zt(t, n.object, n.property, {
              before: m,
              factoryArgs: [c]
            });
          }
        },
        name: function(c) {
          return n.__li.firstElementChild.firstElementChild.innerHTML = c, n;
        },
        listen: function() {
          return n.__gui.listen(n), n;
        },
        remove: function() {
          return n.__gui.remove(n), n;
        }
      }), n instanceof Jn) {
        var r = new En(n.object, n.property, { min: n.__min, max: n.__max, step: n.__step });
        y.each(["updateDisplay", "onChange", "onFinishChange", "step", "min", "max"], function(i) {
          var c = n[i], u = r[i];
          n[i] = r[i] = function() {
            var m = Array.prototype.slice.call(arguments);
            return u.apply(r, m), c.apply(n, m);
          };
        }), _.addClass(e, "has-slider"), n.domElement.insertBefore(r.domElement, n.domElement.firstElementChild);
      } else if (n instanceof En) {
        var o = function(c) {
          if (y.isNumber(n.__min) && y.isNumber(n.__max)) {
            var u = n.__li.firstElementChild.firstElementChild.innerHTML, m = n.__gui.__listening.indexOf(n) > -1;
            n.remove();
            var b = zt(t, n.object, n.property, {
              before: n.__li.nextElementSibling,
              factoryArgs: [n.__min, n.__max, n.__step]
            });
            return b.name(u), m && b.listen(), b;
          }
          return c;
        };
        n.min = y.compose(o, n.min), n.max = y.compose(o, n.max);
      } else n instanceof zi ? (_.bind(e, "click", function() {
        _.fakeEvent(n.__checkbox, "click");
      }), _.bind(n.__checkbox, "click", function(i) {
        i.stopPropagation();
      })) : n instanceof Gi ? (_.bind(e, "click", function() {
        _.fakeEvent(n.__button, "click");
      }), _.bind(e, "mouseover", function() {
        _.addClass(n.__button, "hover");
      }), _.bind(e, "mouseout", function() {
        _.removeClass(n.__button, "hover");
      })) : n instanceof Qn && (_.addClass(e, "color"), n.updateDisplay = y.compose(function(i) {
        return e.style.borderLeftColor = n.__color.toString(), i;
      }, n.updateDisplay), n.updateDisplay());
      n.setValue = y.compose(function(i) {
        return t.getRoot().__preset_select && n.isModified() && Zn(t.getRoot(), !0), i;
      }, n.setValue);
    }
    function Xi(t, e) {
      var n = t.getRoot(), r = n.__rememberedObjects.indexOf(e.object);
      if (r !== -1) {
        var o = n.__rememberedObjectIndecesToControllers[r];
        if (o === void 0 && (o = {}, n.__rememberedObjectIndecesToControllers[r] = o), o[e.property] = e, n.load && n.load.remembered) {
          var i = n.load.remembered, c = void 0;
          if (i[t.preset])
            c = i[t.preset];
          else if (i[Ht])
            c = i[Ht];
          else
            return;
          if (c[r] && c[r][e.property] !== void 0) {
            var u = c[r][e.property];
            e.initialValue = u, e.setValue(u);
          }
        }
      }
    }
    function zt(t, e, n, r) {
      if (e[n] === void 0)
        throw new Error('Object "' + e + '" has no property "' + n + '"');
      var o = void 0;
      if (r.color)
        o = new Qn(e, n);
      else {
        var i = [e, n].concat(r.factoryArgs);
        o = ml.apply(t, i);
      }
      r.before instanceof Et && (r.before = r.before.__li), Xi(t, o), _.addClass(o.domElement, "c");
      var c = document.createElement("span");
      _.addClass(c, "property-name"), c.innerHTML = o.property;
      var u = document.createElement("div");
      u.appendChild(c), u.appendChild(o.domElement);
      var m = Er(t, u, r.before);
      return _.addClass(m, oe.CLASS_CONTROLLER_ROW), o instanceof Qn ? _.addClass(m, "color") : _.addClass(m, rl(o.getValue())), xl(t, m, o), t.__controllers.push(o), o;
    }
    function wt(t, e) {
      return document.location.href + "." + e;
    }
    function qn(t, e, n) {
      var r = document.createElement("option");
      r.innerHTML = e, r.value = e, t.__preset_select.appendChild(r), n && (t.__preset_select.selectedIndex = t.__preset_select.length - 1);
    }
    function Jo(t, e) {
      e.style.display = t.useLocalStorage ? "block" : "none";
    }
    function yl(t) {
      var e = t.__save_row = document.createElement("li");
      _.addClass(t.domElement, "has-save"), t.__ul.insertBefore(e, t.__ul.firstChild), _.addClass(e, "save-row");
      var n = document.createElement("span");
      n.innerHTML = "&nbsp;", _.addClass(n, "button gears");
      var r = document.createElement("span");
      r.innerHTML = "Save", _.addClass(r, "button"), _.addClass(r, "save");
      var o = document.createElement("span");
      o.innerHTML = "New", _.addClass(o, "button"), _.addClass(o, "save-as");
      var i = document.createElement("span");
      i.innerHTML = "Revert", _.addClass(i, "button"), _.addClass(i, "revert");
      var c = t.__preset_select = document.createElement("select");
      if (t.load && t.load.remembered ? y.each(t.load.remembered, function(T, z) {
        qn(t, z, z === t.preset);
      }) : qn(t, Ht, !1), _.bind(c, "change", function() {
        for (var T = 0; T < t.__preset_select.length; T++)
          t.__preset_select[T].innerHTML = t.__preset_select[T].value;
        t.preset = this.value;
      }), e.appendChild(c), e.appendChild(n), e.appendChild(r), e.appendChild(o), e.appendChild(i), kt) {
        var u = document.getElementById("dg-local-explain"), m = document.getElementById("dg-local-storage"), b = document.getElementById("dg-save-locally");
        b.style.display = "block", localStorage.getItem(wt(t, "isLocal")) === "true" && m.setAttribute("checked", "checked"), Jo(t, u), _.bind(m, "change", function() {
          t.useLocalStorage = !t.useLocalStorage, Jo(t, u);
        });
      }
      var g = document.getElementById("dg-new-constructor");
      _.bind(g, "keydown", function(T) {
        T.metaKey && (T.which === 67 || T.keyCode === 67) && $t.hide();
      }), _.bind(n, "click", function() {
        g.innerHTML = JSON.stringify(t.getSaveObject(), void 0, 2), $t.show(), g.focus(), g.select();
      }), _.bind(r, "click", function() {
        t.save();
      }), _.bind(o, "click", function() {
        var T = prompt("Enter a new preset name.");
        T && t.saveAs(T);
      }), _.bind(i, "click", function() {
        t.revert();
      });
    }
    function El(t) {
      var e = void 0;
      t.__resize_handle = document.createElement("div"), y.extend(t.__resize_handle.style, {
        width: "6px",
        marginLeft: "-3px",
        height: "200px",
        cursor: "ew-resize",
        position: "absolute"
      });
      function n(i) {
        return i.preventDefault(), t.width += e - i.clientX, t.onResize(), e = i.clientX, !1;
      }
      function r() {
        _.removeClass(t.__closeButton, oe.CLASS_DRAG), _.unbind(window, "mousemove", n), _.unbind(window, "mouseup", r);
      }
      function o(i) {
        return i.preventDefault(), e = i.clientX, _.addClass(t.__closeButton, oe.CLASS_DRAG), _.bind(window, "mousemove", n), _.bind(window, "mouseup", r), !1;
      }
      _.bind(t.__resize_handle, "mousedown", o), _.bind(t.__closeButton, "mousedown", o), t.domElement.insertBefore(t.__resize_handle, t.domElement.firstElementChild);
    }
    function er(t, e) {
      t.domElement.style.width = e + "px", t.__save_row && t.autoPlace && (t.__save_row.style.width = e + "px"), t.__closeButton && (t.__closeButton.style.width = e + "px");
    }
    function _n(t, e) {
      var n = {};
      return y.each(t.__rememberedObjects, function(r, o) {
        var i = {}, c = t.__rememberedObjectIndecesToControllers[o];
        y.each(c, function(u, m) {
          i[m] = e ? u.initialValue : u.getValue();
        }), n[o] = i;
      }), n;
    }
    function gl(t) {
      for (var e = 0; e < t.__preset_select.length; e++)
        t.__preset_select[e].value === t.preset && (t.__preset_select.selectedIndex = e);
    }
    function Yi(t) {
      t.length !== 0 && pl.call(window, function() {
        Yi(t);
      }), y.each(t, function(e) {
        e.updateDisplay();
      });
    }
    var Al = oe, ti;
    const Tl = (ti = window.webkit) == null ? void 0 : ti.messageHandlers, vl = window.webkit != null;
    function Qo(t, e = t) {
      vl && Tl[t].postMessage(e);
    }
    const Zo = {
      debug: !1,
      console: !1,
      flicker: !0,
      baseAlphaMultiplier: 1.5,
      lineWidth: 1,
      autoSolve: !1,
      minWorthwhileErrorImprovement: 0.05,
      masterSideAttacherColor: "rgb(255,165,0)",
      instanceSideAttacherColor: "rgb(255,222,33)",
      showControlPoints: !0,
      controlPointColor: "rgba(255,222,33,.2)",
      axisColor: "rgba(255,222,33,0.125)",
      handleRadius: 7,
      closeEnough: 7,
      crosshairsSize: 15,
      fontScale: 10,
      kerning: 0.75,
      showGuideLines: !1,
      guideLineColor: "rgba(255,255,255,.125)",
      statusTimeMillis: 4e3,
      usePredictedEvents: !1,
      weight: 25,
      distanceConstraintTextScale: 0.3,
      distanceConstraintLabelPct: 0.25,
      showImplicitConstraints: !1,
      highlightReferents: !0,
      maxDepth: 10,
      tabletButtonWidth: 100,
      lefty: !1,
      onionSkinAlpha: 0
    };
    let hn;
    function Sl() {
      hn = JSON.parse(localStorage.getItem("config") ?? JSON.stringify(Zo));
      for (const [t, e] of Object.entries(Zo))
        Object.hasOwn(hn, t) || (hn[t] = e);
    }
    function Xt() {
      return hn;
    }
    Sl();
    window.config = Xt;
    const Rl = {
      log: console.log,
      warn: console.warn,
      error: console.error
    };
    let $e = null, bn = [];
    function tr() {
      if (Xt().console) {
        if (!$e) {
          $e = wl();
          for (const e of bn) Wi(e);
        }
        $e.style.display = "block";
      } else $e && ($e.style.display = "none");
    }
    function wl() {
      const t = document.createElement("div");
      t.innerHTML = `<div style="position: absolute; right: 0; bottom:0; padding: 5px; width: fit-content; white-space: pre; font-family: monospace; background: rgba(0,0,0,0.5); max-width: 50%;
        white-space: break-spaces; pointer-events: none"></div>`;
      const e = t.children[0];
      return document.body.appendChild(e), e;
    }
    function gr(t) {
      return function(...e) {
        Rl[t](...e);
        const n = e.map((c) => typeof c == "string" ? c : JSON.stringify(c, null, 2)).join(" "), r = document.createElement("div"), o = t === "error" ? "#F33" : t === "warn" ? "#FD4" : "#CCC", i = new Date(Date.now() - (/* @__PURE__ */ new Date()).getTimezoneOffset() * 6e4).toISOString().slice(11, 23);
        r.innerHTML = `<span style="color: #999">${i}:</span> <span style="color: ${o}">${n}</span>`, bn.length > 100 && bn.shift(), bn.push(r), Wi(r);
      };
    }
    function Wi(t) {
      if ($e) {
        for ($e.appendChild(t); $e.getBoundingClientRect().height > window.innerHeight * 2 && $e.children[1]; )
          $e.children[0].remove();
        $e.scrollTop = $e.scrollHeight;
      }
    }
    console.log = gr("log");
    console.warn = gr("warn");
    console.error = gr("error");
    addEventListener("error", (t) => console.error("Error:", t.error.message || t.error));
    addEventListener("unhandledrejection", (t) => console.error("Unhandled Rejection:", t.reason.message || t.reason));
    console.log("Back to 1963!");
    tr();
    const nr = 16348;
    let Ue = new Int32Array(nr * 2 + 64), ze = 0, yt = 0, qo = [], ke = 0, gn = !1, Vt = {
      // pen location and pseudo pen location
      pos: { x: 0, y: 0 },
      pseudo: { x: 0, y: 0 }
    };
    function Fl(t, e) {
      return e && Nl(e), Ll(t);
    }
    function Il() {
      ze = 0, yt = 0, gn = !0;
    }
    function An(t, e, n) {
      if (typeof t == "object") {
        const i = t;
        return An(i.x, i.y, i.id);
      }
      if (typeof t != "number" || typeof e != "number")
        throw Error("addSpot(x, y, id?) expects x, y as numbers");
      if (n || (n = 0), Y.clipToSquare && (t < -512 || t >= 512 || e < -512 || e >= 512))
        return;
      if (ze >= nr) {
        console.warn(`MAX_SPOTS (${nr}) reached`);
        return;
      }
      const r = ze;
      let o = r;
      if (Y.twinkleSpots) {
        const i = Math.random() * ze | 0;
        Ue[2 * o] = Ue[2 * i], Ue[2 * o + 1] = Ue[2 * i + 1], o = i;
      }
      Ue[2 * o] = t << 16 | n & 65535, Ue[2 * o + 1] = e << 16 | r & 65535, ze++, gn = !0;
    }
    function Cl(t, e) {
      Vt.pos.x = t | 0, Vt.pos.y = e | 0;
    }
    function Nl(t) {
      Object.assign(Y, t);
    }
    function Lt(t) {
      return Y[t];
    }
    const Y = {
      spotSize: 9,
      // size of spot texture
      spotIntensity: 0.3,
      // like beam current
      spotDensity: devicePixelRatio,
      // spots on line/arc
      spotsPerSec: 1e5,
      // draw speed in spots per second
      spotsCPUFraction: 0.5,
      // fraction of CPU time for spots
      phosphorSpeed: 0.5,
      // fade amount per frame
      phosphorAmbient: 0.3,
      // base brightness
      phosphorSmoothness: 0.95,
      // 0: rough, 1: smooth
      phosphorGrain: 3,
      // size of graininess
      clipToSquare: !1,
      // only draw within 1024x1024 square
      interlaceSpots: !1,
      // interlaced rendering
      twinkleSpots: !1,
      // scramble spots for less flicker
      penTracker: !0,
      // draw pen tracking cross
      trackerSize: 5,
      // size of tracking cross
      trackerSnap: 5,
      // snap distance for pseudo pen location
      colorizeByIndex: !1,
      // colorize spots by ID
      showConsole: Xt().console,
      fullscreen: !1,
      showGui: !1,
      // show GUI
      openGui: !1,
      // open controls at start
      // below just for internal use as uniforms
      colorIdx: 0,
      // how many spots to color in frag shader
      pixelRatio: devicePixelRatio,
      // scale for pointSize
      screenScale: [0, 0]
      // set in resize()
    }, Bl = `#version 300 es
    in vec2 pos;
    out vec2 uv;
    void main() {
        gl_Position = vec4(pos, 0.0, 1.0);
        uv = pos * 0.5 + 0.5;
    }`, Dl = `#version 300 es
    precision mediump float;
    uniform float phosphorSpeed;
    uniform float phosphorAmbient;
    uniform float phosphorSmoothness;
    uniform float phosphorGrain;
    uniform float pixelRatio;
    in vec2 uv;
    out vec4 photons;

    // Simplex Noise Function
    vec2 mod289(vec2 x) {
        return x - floor(x * (1.0 / 289.0)) * 289.0;
    }

    vec3 mod289(vec3 x) {
        return x - floor(x * (1.0 / 289.0)) * 289.0;
    }

    vec3 permute(vec3 x) {
        return mod289(((x*34.0)+1.0)*x);
    }

    float simplexNoise(vec2 v) {
        const vec4 C = vec4(0.211324865405187, 0.366025403784439, -0.577350269189626, 0.024390243902439);
        vec2 i  = floor(v + dot(v, C.yy) );
        vec2 x0 = v -   i + dot(i, C.xx);
        vec2 i1;
        i1.x = step( x0.y, x0.x );
        i1.y = 1.0 - i1.x;
        vec4 x12 = x0.xyxy + C.xxzz;
        x12.xy -= i1;
        i = mod289(i);
        vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))
                + i.x + vec3(0.0, i1.x, 1.0 ));
        vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);
        m = m*m ;
        m = m*m ;
        vec3 x = 2.0 * fract(p * C.www) - 1.0;
        vec3 h = abs(x) - 0.5;
        vec3 ox = floor(x + 0.5);
        vec3 a0 = x - ox;
        m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );
        vec3 g;
        g.x  = a0.x  * x0.x  + h.x  * x0.y;
        g.yz = a0.yz * x12.xz + h.yz * x12.yw;
        return 130.0 * dot(m, g);
    }

    void main() {
        // noise to simulate phosphor roughness
        float p = phosphorAmbient * mix(simplexNoise(uv * pixelRatio / phosphorGrain * 500.0) * 2.0, 1.0, phosphorSmoothness);
        // used with src * src.a + dst*(1-src.a)) blending to fade out
        photons = vec4(p, p, p, phosphorSpeed);
    }`, Pl = `#version 300 es
    in      ivec2 xyIdIx;          // position in upper 16 bits, id in lower 16 bits
    uniform vec2  screenScale;     // half width/height of screen
    uniform float pixelRatio;      // device pixel ratio
    uniform float spotSize;        // size of spot

    void main() {
        ivec2 pos = xyIdIx >> ivec2(16, 16);                   // sign extend 16 bits to 32
        gl_Position = vec4(vec2(pos) / screenScale, 0.0, 1.0);
        gl_PointSize = spotSize * pixelRatio;
    }`, Ul = `#version 300 es
    precision mediump float;
    uniform float spotIntensity;
    out vec4 photons;
    void main() {
        float dist = distance(gl_PointCoord, vec2(0.5));
        float gauss = exp(-20.0 * dist*dist) * spotIntensity;          // 20 works well for 8 bit color components
        if (gauss < 0.01) discard;
        // src+dst blending to accumulate photons
        photons = vec4(gauss, gauss, gauss, 1.0);
    }`, Ml = `#version 300 es
    in      ivec2 xyIdIx;          // position in upper 16 bits, id and index in lower 16 bits
    uniform vec2  screenScale;     // half width/height of screen
    uniform float spotSize;        // size of spot
    uniform uint  colorIdx;        // start of spots in display table
    out     vec3  v_color;         // color of spot

    vec3 hue(float h) {
        h = mod(h, 1.0);
        float r = abs(h * 6.0 - 3.0) - 1.0;
        float g = 2.0 - abs(h * 6.0 - 2.0);
        float b = 2.0 - abs(h * 6.0 - 4.0);
        return clamp(vec3(r, g, b), 0.0, 1.0);
    }

    void main() {
        ivec2 pos = xyIdIx >> ivec2(16, 16);                   // sign extend 16 bits to 32
        uint idx = uint(xyIdIx.y & 65535);                     // 16 bit index
        if (idx < colorIdx) {
            float fraction = float(idx) / float(colorIdx);     // map to [0, 1)
            v_color = hue(float(idx) / float(colorIdx));       // color by table index
        } else {
            v_color = vec3(1.0);                               // default: white
        }
        gl_Position = vec4(vec2(pos) / screenScale, 0.0, 1.0);
        gl_PointSize = spotSize * 512.0 / max(screenScale.x, screenScale.y);
    }`, Ol = `#version 300 es
    precision mediump float;
    in vec3 v_color;
    uniform float spotIntensity;
    out vec4 photons;
    void main() {
        float dist = distance(gl_PointCoord, vec2(0.5));
        float gauss = exp(-20.0 * dist*dist) * spotIntensity;          // 20 works well for 8 bit color components
        if (gauss < 0.01) discard;
        // src+dst blending to accumulate photons
        photons = gauss * vec4(v_color, 1.0);
    }`;
    function Ll(t) {
      const e = t.getContext("webgl2", { preserveDrawingBuffer: !0 });
      if (!e) throw new Error("No WebGL2 context found");
      function n() {
        el(t, devicePixelRatio);
        const L = Math.min(t.width / 512, t.height / 512);
        if (e.viewport(0, 0, t.width, t.height), Y.screenScale = [t.width / L, t.height / L], e.clearColor(0, 0, 0, 0), e.clear(e.COLOR_BUFFER_BIT), Y.clipToSquare) {
          const D = t.width / t.height, j = D > 1 ? (t.width - t.height) / 2 : 0, q = D < 1 ? (t.height - t.width) / 2 : 0, ue = D > 1 ? t.height : t.width;
          e.scissor(j, q, ue, ue), e.enable(e.SCISSOR_TEST);
        } else
          e.disable(e.SCISSOR_TEST);
      }
      onresize = () => n(), n(), Xt().console = Y.showConsole, tr();
      const r = new Al();
      r.add(Y, "spotSize", 1, 100), r.add(Y, "spotIntensity", 0.1, 1), r.add(Y, "spotDensity", 0.1, 5), r.add(Y, "spotsPerSec", 1e3, 5e5), r.add(Y, "spotsCPUFraction", 0.01, 1).listen(), r.add(Y, "phosphorSpeed", 0, 1), r.add(Y, "phosphorAmbient", 0, 0.5), r.add(Y, "phosphorSmoothness", 0, 1), r.add(Y, "phosphorGrain", 1, 10), r.add(Y, "clipToSquare").onChange(() => n()), r.add(Y, "interlaceSpots"), r.add(Y, "twinkleSpots"), r.add(Y, "penTracker").onChange((L) => {
        t.style.cursor = L ? "none" : "default", L || ji();
      }), r.add(Y, "trackerSize", 1, 20), r.add(Y, "trackerSnap", 1, 20), r.add(Y, "colorizeByIndex"), r.add(Y, "showConsole").onChange((L) => {
        Xt().console = L, tr();
      }), r.add(Y, "fullscreen").onChange((L) => {
        L ? document.body.requestFullscreen() : document.exitFullscreen();
      }), Y.showGui || r.hide(), Y.openGui || r.close(), t.style.cursor = Y.penTracker ? "none" : "default";
      const o = Yn(e, [Bl, Dl]), c = Xn(e, {
        pos: {
          numComponents: 2,
          data: [-1, -1, 1, -1, 1, 1, -1, 1]
        }
      });
      let u = Yn(e, [Pl, Ul]), m = Yn(e, [
        Ml,
        Ol
      ]);
      const g = Xn(e, {
        xyIdIx: {
          numComponents: 2,
          data: Ue
        }
      }), T = [];
      for (let L = 0; L < 8; L++) {
        const D = {
          xyIdIx: {
            numComponents: 2,
            data: Ue,
            stride: 64,
            // every 8th spot, 8 bytes per spot
            offset: 8 * L
            // staggered by 8 bytes
          }
        };
        T.push(Xn(e, D));
      }
      let z = 0;
      function Q(L) {
        const D = L - z;
        z = L;
        let j = Math.max(8, Math.min(D, 30)) * Y.spotsPerSec * Y.spotsCPUFraction / 1e3 | 0;
        if (Y.penTracker && kl(), e.enable(e.BLEND), e.blendFunc(e.SRC_ALPHA, e.ONE_MINUS_SRC_ALPHA), e.useProgram(o.program), dn(e, o, c), pn(o, Y), Ut(e, c, e.TRIANGLE_FAN), gn) {
          Mo(
            e,
            g.attribs.xyIdIx,
            new Int32Array(Ue.buffer, 0, ze * 2)
          );
          for (let ce = 0; ce < 8; ce++)
            Mo(
              e,
              T[ce].attribs.xyIdIx,
              new Int32Array(Ue.buffer, 0, ze * 2)
            );
          gn = !1;
        }
        const q = ze - yt;
        ke >= q && (ke = 0);
        let ue = Y.colorizeByIndex ? m : u;
        if (e.enable(e.BLEND), e.blendFunc(e.ONE, e.ONE), e.useProgram(ue.program), Y.colorIdx = q, pn(ue, Y), Y.interlaceSpots && q > 8) {
          const ce = q >> 3;
          let Ee = 0, le = ke >> 3, Ve = ke & 7;
          for (; j > 0 && q > Ee; ) {
            dn(e, ue, T[Ve]);
            const nt = Math.min(le + j, ce) - le;
            if (nt <= 0) break;
            Ut(e, T[Ve], e.POINTS, nt, le), Ee += nt, j -= nt, le += nt, le === ce && (le = 0, Ve++ === 7 && (Ve = 0));
          }
          ke = (le << 3) + Ve;
        } else if (q > 0) {
          dn(e, ue, g);
          const Ee = Math.min(ke + j, q) - ke;
          Ee > 0 && Ut(e, g, e.POINTS, Ee, ke);
          const le = Ee;
          if (j -= le, ke = (ke + le) % q, j > 0 && q > le) {
            const Ve = Math.min(j, q - le);
            Ut(e, g, e.POINTS, Ve), ke = (ke + Ve) % q;
          }
        }
        yt > 0 && (Y.colorIdx = 0, pn(ue, Y), dn(e, ue, g), Ut(e, g, e.POINTS, yt, q)), requestAnimationFrame(Q);
      }
      return requestAnimationFrame(Q), { gui: r };
    }
    function ji() {
      ze -= yt, yt = 0;
    }
    let ei = !1;
    function kl() {
      const { x: t, y: e } = Vt.pos;
      ji();
      const n = ze, r = Y.twinkleSpots;
      Y.twinkleSpots = !1;
      const o = 6, i = 2.5, c = 0.25, u = 0.4, m = Math.max(5, Y.spotSize) * devicePixelRatio * Y.trackerSize / 30, b = Y.trackerSnap * 6;
      qo.length = 0;
      let g = t, T = e, z = 1 / 0;
      for (let D = 0; D < ze; D++) {
        const j = Ue[2 * D] >> 16, q = Math.abs(t - j);
        if (q > b) continue;
        const ue = Ue[2 * D + 1] >> 16, ce = Math.abs(e - ue);
        if (ce > b) continue;
        qo.push({ x: j, y: ue, id: Ue[2 * D] & 65535 });
        const Ee = Math.min(q, ce);
        Ee < z && (g = j, T = ue, z = Ee);
      }
      const Q = z < 1 / 0;
      Q !== ei && (Q && (Qo("prepareHaptics"), Qo("hapticImpact")), ei = Q);
      const L = m * u;
      for (const [D, j] of [
        [-2, -2],
        [-3, 0],
        [-2, 2],
        [0, -3],
        [0, 0],
        [0, 3],
        [2, -2],
        [3, 0],
        [2, 2]
      ])
        An(g + D * L, T + j * L);
      for (let D = 0; D < o; D++) {
        const j = Math.log(i + D) / c * m;
        for (const [q, ue] of [
          [-1, 0],
          [1, 0],
          [0, -1],
          [0, 1]
        ])
          An(t + q * j, e + ue * j);
      }
      yt = ze - n, Q && (Vt.pseudo.x = g, Vt.pseudo.y = T), Y.twinkleSpots = r;
    }
    function $l(t) {
      const { gui: e } = Fl(t, {
        showGui: !0,
        openGui: !0
      }), n = {
        demoMulX: 3,
        demoMulY: 4,
        demoRotation: 10
      };
      e.add(n, "demoMulX", 1, 10), e.add(n, "demoMulY", 1, 10), e.add(n, "demoRotation", 0, 50);
      const r = Math.min(t.offsetWidth, t.offsetHeight) / 1024;
      t.onmousemove = t.onmousedown = t.onmouseup = (b) => {
        const g = (b.offsetX - t.offsetWidth / 2) / r, T = (t.offsetHeight / 2 - b.offsetY) / r;
        Cl(g, T);
      };
      let o = "";
      function i() {
        const b = n.demoMulX + "," + n.demoMulY + "," + Lt("spotSize") + Lt("spotDensity");
        return b === o ? !1 : (o = b, !0);
      }
      let c = 0, u = 0;
      function m() {
        const b = 2e3 / (n.demoRotation || 1), g = Date.now();
        g - c < b && !i() || (u += (g - c) * n.demoRotation / 1e5, c = g, Il(), zl(400, 400, u, 0, n.demoMulX | 0, n.demoMulY | 0, Lt("spotSize") / Lt("spotDensity")), n.demoMulX, n.demoMulY, Lt("spotDensity"));
      }
      setInterval(m, 1e3 / 20);
    }
    function zl(t, e, n, r, o, i, c) {
      const u = Math.min(8e3 / c, 16e3);
      for (let m = 0; m < u; m++) {
        const b = m * Math.PI * 2 / u, g = Math.sin(o * b + n) * t | 0, T = Math.cos(i * b + r) * e | 0;
        An(g, T);
      }
    }
    $l(document.getElementById("canvas"));
    </script>
  </body>
</html>
