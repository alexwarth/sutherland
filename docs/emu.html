<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <style>
        *,
        *::before,
        *::after {
          margin: 0;
          touch-action: none;
          -webkit-user-drag: none;
          -webkit-user-select: none;
          user-select: none;
        }

        html,
        body,
        canvas {
          position: absolute;
          top: 0;
          left: 0;
          width: 100%;
          height: 100vh;
          overflow: hidden;
        }
        @supports (height: 100dvh) {
          html,
          body,
          canvas {
            height: 100dvh;
          }
        }
        body {
          background-color: black;
        }
        canvas {
          cursor: none;
        }
    </style>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>TX2 Display Test</title>
  </head>
  <body>
    <canvas id="canvas"> </canvas>
    <script>
      (function(t) {
  typeof define == "function" && define.amd ? define(t) : t();
})(function() {
  function t(s) {
    return s.startsWith("gl_") || s.startsWith("webgl_");
  }
  function e(s) {
    return !!s.texImage3D;
  }
  function n(s) {
    return s && s.buffer && s.buffer instanceof ArrayBuffer;
  }
  function o(s) {
    return Array.isArray(s) || s instanceof Float32Array || s instanceof Float64Array;
  }
  function r(s) {
    return s ? `"${s}"` : "";
  }
  const i = {};
  function c(s, h) {
    const E = [];
    if (h.length) {
      for (let v = 0; v < h.length; ++v)
        h.push(A(h[v]));
      return "[" + E.join(", ") + "]";
    }
    return E.toString();
  }
  function u(s) {
    return function(h, E) {
      let v = 0;
      const I = [];
      for (let D = 0; D < s.length; ++D) {
        const O = i[s[D]];
        E & O && (v |= O, I.push(A(O)));
      }
      return v === E ? I.join(" | ") : A(E);
    };
  }
  const _ = /* @__PURE__ */ new Map();
  function x(s) {
    for (const h in s) {
      const E = s[h];
      typeof E == "number" && (_.has(E) || _.set(E, /* @__PURE__ */ new Set()), _.get(E).add(h));
    }
  }
  function A(s) {
    const h = _.get(s);
    return h ? [...h.keys()].map((E) => `${E}`).join(" | ") : `/*UNKNOWN WebGL ENUM*/ ${typeof s == "number" ? `0x${s.toString(16)}` : s}`;
  }
  const T = 5126, k = 35664, j = 35665, W = 35666, H = 5124, ee = 35667, V = 35668, pe = 35669, Z = 35670, ie = 35671, Ee = 35672, Je = 35673, rt = 35674, Ce = 35675, He = 35676, wr = 35678, yt = 35680, os = 35679, is = 35682, ss = 35685, as = 35686, us = 35687, cs = 35688, fs = 35689, ls = 35690, ds = 36289, ms = 36292, _s = 36293, Jt = 5125, Fr = 36294, Ir = 36295, Cr = 36296, ps = 36298, hs = 36299, bs = 36300, xs = 36303, ys = 36306, Es = 36307, gs = 36308, As = 36311, Ts = /* @__PURE__ */ new Map([
    [T, { size: 1, name: "float" }],
    [k, { size: 2, name: "vec2" }],
    [j, { size: 3, name: "vec3" }],
    [W, { size: 4, name: "vec4" }],
    [H, { size: 1, name: "int" }],
    [ee, { size: 2, name: "ivec2" }],
    [V, { size: 3, name: "ivec3" }],
    [pe, { size: 4, name: "ivec4" }],
    [Jt, { size: 1, name: "uint" }],
    [Fr, { size: 2, name: "uvec2" }],
    [Ir, { size: 3, name: "uvec3" }],
    [Cr, { size: 4, name: "uvec4" }],
    [Z, { size: 1, name: "bool" }],
    [ie, { size: 2, name: "bvec2" }],
    [Ee, { size: 3, name: "bvec3" }],
    [Je, { size: 4, name: "bvec4" }],
    [rt, { size: 4, name: "mat2" }],
    [Ce, { size: 9, name: "mat3" }],
    [He, { size: 16, name: "mat4" }],
    [ss, { size: 6, name: "mat2x3" }],
    [as, { size: 8, name: "mat2x4" }],
    [us, { size: 6, name: "mat3x2" }],
    [cs, { size: 12, name: "mat3x4" }],
    [fs, { size: 8, name: "mat4x2" }],
    [ls, { size: 12, name: "mat4x3" }],
    [wr, { size: 1, name: "sampler2D" }],
    [yt, { size: 1, name: "samplerCube" }],
    [os, { size: 1, name: "sampler3D" }],
    [is, { size: 1, name: "sampler2DShadow" }],
    [ds, { size: 1, name: "sampler2DArray" }],
    [ms, { size: 1, name: "sampler2DArrayShadow" }],
    [_s, { size: 1, name: "samplerCubeShadow" }],
    [ps, { size: 1, name: "isampler2D" }],
    [hs, { size: 1, name: "isampler3D" }],
    [bs, { size: 1, name: "isamplerCube" }],
    [xs, { size: 1, name: "isampler2DArray" }],
    [ys, { size: 1, name: "usampler2D" }],
    [Es, { size: 1, name: "usampler3D" }],
    [gs, { size: 1, name: "usamplerCube" }],
    [As, { size: 1, name: "usampler2DArray" }]
  ]);
  function Dt(s) {
    return Ts.get(s);
  }
  const vs = 32873, Ss = 34068, Rs = 32874, ws = 35869, Fs = 34962, Is = 34963, Cs = 34964, Ns = 34965, Bs = 3553, Ps = 32879, Ds = 35866, Us = 34067, Ms = 36160, Os = 36161, Nr = 36006, Ls = 36007, ks = 35982, $s = 35983, zs = 36009, Vs = 36008, Gs = 36010, Hs = 35345, Xs = 35368, Ys = 36386, Ws = 36389, js = /* @__PURE__ */ new Map([
    [Fs, Cs],
    [Is, Ns],
    [Bs, vs],
    [Us, Ss],
    [Ps, Rs],
    [Ds, ws],
    [Os, Ls],
    [Ms, Nr],
    [zs, Nr],
    [Vs, Gs],
    [Hs, Xs],
    [ks, $s],
    [Ys, Ws]
  ]);
  function Br(s) {
    return js.get(s);
  }
  const Ks = 5120, Js = 5122, Pr = 5121, Dr = 5123, Qs = /* @__PURE__ */ new Map([
    [Z, 1],
    [Ks, 1],
    [Pr, 1],
    [Js, 2],
    [Dr, 2],
    [H, 4],
    [Jt, 4],
    [T, 4]
  ]);
  function Ur(s) {
    return Qs.get(s) || 0;
  }
  const Zs = /* @__PURE__ */ new Map([
    [Pr, Uint8Array],
    [Dr, Uint16Array],
    [Jt, Uint32Array]
  ]);
  function qs(s) {
    return Zs.get(s);
  }
  const Mr = {
    drawArrays(s, h, E) {
      return { startOffset: h, vertCount: E, instances: 1 };
    },
    drawElements(s, h, E, v) {
      return { startOffset: v, vertCount: h, instances: 1, indexType: E };
    },
    drawArraysInstanced(s, h, E, v) {
      return { startOffset: h, vertCount: E, instances: v };
    },
    drawElementsInstanced(s, h, E, v, I) {
      return { startOffset: v, vertCount: h, instances: I, indexType: E };
    },
    drawArraysInstancedANGLE(s, h, E, v) {
      return { startOffset: h, vertCount: E, instances: v };
    },
    drawElementsInstancedANGLE(s, h, E, v, I) {
      return { startOffset: v, vertCount: h, instances: I, indexType: E };
    },
    drawRangeElements(s, h, E, v, I, D) {
      return { startOffset: D, vertCount: v, instances: 1, indexType: I };
    }
  };
  function Or(s, h) {
    return Mr[s](...h);
  }
  function Dn(s) {
    return !!Mr[s];
  }
  const ea = /* @__PURE__ */ new Map([
    [T, { size: 4 }],
    [k, { size: 8 }],
    [j, { size: 12 }],
    [W, { size: 16 }],
    [H, { size: 4 }],
    [ee, { size: 8 }],
    [V, { size: 12 }],
    [pe, { size: 16 }],
    [Jt, { size: 4 }],
    [Fr, { size: 8 }],
    [Ir, { size: 12 }],
    [Cr, { size: 16 }],
    [Z, { size: 4 }],
    [ie, { size: 8 }],
    [Ee, { size: 12 }],
    [Je, { size: 16 }],
    [rt, { size: 4, count: 2 }],
    [Ce, { size: 9, count: 3 }],
    [He, { size: 16, count: 4 }]
  ]);
  function ta(s) {
    return ea.get(s);
  }
  const st = (s) => s ? new WeakRef(s) : null, at = (s, h) => {
    const E = s == null ? void 0 : s.deref();
    return !!E != !!h ? !1 : E ? E === h : !0;
  };
  function Lr(s, h) {
    return s === "undefined" ? h : s;
  }
  const na = 35070;
  function ra(s, h) {
    return s + h - 1;
  }
  function oa(s, h, E, v, I, D, O, U, L) {
    const N = s.getParameter(s.ELEMENT_ARRAY_BUFFER_BINDING);
    if (!N) {
      L.push("No ELEMENT_ARRAY_BUFFER bound");
      return;
    }
    const G = Ur(D), ae = s.getBufferParameter(s.ELEMENT_ARRAY_BUFFER, s.BUFFER_SIZE), he = E + v * G;
    if (he > ae) {
      L.push(`offset: ${E} and count: ${v} with index type: ${A(D)} passed to ${h} are out of range for current ELEMENT_ARRAY_BUFFER.
Those parameters require ${he} bytes but the current ELEMENT_ARRAY_BUFFER ${O(N)} only has ${ae} bytes`);
      return;
    }
    const Ae = U(N), be = qs(D), Te = new be(Ae, E);
    let fe = Te[0];
    for (let ot = 1; ot < v; ++ot)
      fe = Math.max(fe, Te[ot]);
    return fe;
  }
  function ia(s, h, E, v, I) {
    const { vertCount: D, startOffset: O, indexType: U, instances: L } = Or(h, E);
    if (D <= 0 || L <= 0)
      return [];
    const N = s.getParameter(s.CURRENT_PROGRAM), G = [], ae = U ? oa(s, h, O, D, L, U, v, I, G) : ra(O, D);
    if (G.length)
      return G;
    const he = e(s) || s.getExtension("ANGLE_instanced_arrays"), Ae = s.getProgramParameter(N, s.ACTIVE_ATTRIBUTES), be = s.getParameter(s.ARRAY_BUFFER_BINDING);
    for (let Te = 0; Te < Ae; ++Te) {
      const { name: fe, type: ot } = s.getActiveAttrib(N, Te);
      if (t(fe))
        continue;
      const Qe = s.getAttribLocation(N, fe), { count: gt } = { count: 1, ...ta(ot) };
      for (let K = 0; K < gt; ++K) {
        const ue = Qe + K;
        if (!s.getVertexAttrib(ue, s.VERTEX_ATTRIB_ARRAY_ENABLED))
          continue;
        const we = s.getVertexAttrib(ue, s.VERTEX_ATTRIB_ARRAY_BUFFER_BINDING);
        if (!we) {
          G.push(`no buffer bound to attribute (${fe}) location: ${Qe}`);
          continue;
        }
        const P = s.getVertexAttrib(ue, s.VERTEX_ATTRIB_ARRAY_SIZE), M = s.getVertexAttrib(ue, s.VERTEX_ATTRIB_ARRAY_TYPE), w = Ur(M) * P, R = s.getVertexAttribOffset(ue, s.VERTEX_ATTRIB_ARRAY_POINTER), B = s.getVertexAttrib(ue, s.VERTEX_ATTRIB_ARRAY_STRIDE), X = B || w, $ = he ? s.getVertexAttrib(ue, na) : 0;
        s.bindBuffer(s.ARRAY_BUFFER, we);
        const ne = s.getBufferParameter(s.ARRAY_BUFFER, s.BUFFER_SIZE), J = $ > 0 ? ((L + $ - 1) / $ | 0) - 1 : ae, q = R + J * X + w;
        q > ne && G.push(`${v(we)} assigned to attribute ${ue} used as attribute '${fe}' in current program is too small for draw parameters.
index of highest vertex accessed: ${J}
attribute size: ${P}, type: ${A(M)}, stride: ${B}, offset: ${R}, divisor: ${$}
needs ${q} bytes for draw but buffer is only ${ne} bytes`);
      }
    }
    return s.bindBuffer(s.ARRAY_BUFFER, be), G;
  }
  const kr = 35678, $r = 35680, zr = 35679, Vr = 35682, Gr = 36289, Hr = 36292, Xr = 36293, sa = 36298, aa = 36299, ua = 36300, ca = 36303, fa = 36306, la = 36307, da = 36308, ma = 36311, Qt = /* @__PURE__ */ new Map([
    [kr, { uniformType: "sampler2D", numberType: "float/normalized", bindPoint: "2D" }],
    [$r, { uniformType: "samplerCube", numberType: "float/normalized", bindPoint: "CUBE" }],
    [zr, { uniformType: "sampler3D", numberType: "float/normalized", bindPoint: "3D" }],
    [Vr, { uniformType: "sampler2D", numberType: "float/normalized", bindPoint: "2D" }],
    [Gr, { uniformType: "sampler2DArray", numberType: "float/normalized", bindPoint: "2D_ARRAY" }],
    [Hr, { uniformType: "sampler2DArray", numberType: "float/normalized", bindPoint: "2D_ARRAY" }],
    [Xr, { uniformType: "samplerCube", numberType: "float/normalized", bindPoint: "CUBE" }],
    [sa, { uniformType: "isampler2D", numberType: "int", bindPoint: "2D" }],
    [aa, { uniformType: "isampler3D", numberType: "int", bindPoint: "3D" }],
    [ua, { uniformType: "isamplerCube", numberType: "int", bindPoint: "CUBE" }],
    [ca, { uniformType: "isampler2DArray", numberType: "int", bindPoint: "2D_ARRAY" }],
    [fa, { uniformType: "usampler2D", numberType: "unsigned int", bindPoint: "2D" }],
    [la, { uniformType: "usampler3D", numberType: "unsigned int", bindPoint: "3D" }],
    [da, { uniformType: "usamplerCube", numberType: "unsigned int", bindPoint: "CUBE" }],
    [ma, { uniformType: "usampler2DArray", numberType: "unsigned int", bindPoint: "2D_ARRAY" }]
  ]);
  function _a(s) {
    return Qt.get(s).bindPoint;
  }
  function Zt(s) {
    return Qt.has(s);
  }
  function pa(s) {
    return Qt.get(s).numberType;
  }
  function Yr(s) {
    return Qt.get(s).uniformType;
  }
  const ha = 3553, ba = 32879, xa = 35866, ya = 34067, Ea = 34069, ga = 34070, Aa = 34071, Ta = 34072, va = 34073, Sa = 34074, Ra = /* @__PURE__ */ new Map([
    [ha, "2D"],
    [ba, "3D"],
    [ya, "CUBE"],
    [Ea, "CUBE"],
    [ga, "CUBE"],
    [Aa, "CUBE"],
    [Ta, "CUBE"],
    [va, "CUBE"],
    [Sa, "CUBE"],
    [xa, "2D_ARRAY"]
  ]);
  function Wr(s) {
    return Ra.get(s);
  }
  const jr = 32873, Kr = 34068, wa = 32874, Jr = 35869, Fa = /* @__PURE__ */ new Map([
    [kr, jr],
    [Vr, jr],
    [zr, wa],
    [Gr, Jr],
    [Hr, Jr],
    [$r, Kr],
    [Xr, Kr]
  ]);
  function Ia(s, h, E) {
    s.activeTexture(s.TEXTURE0 + h);
    const v = Fa.get(E);
    return s.getParameter(v);
  }
  const Ca = 36063;
  function Na(s) {
    return !e(s) && !s.getExtension("WEBGL_draw_buffers") ? 1 : s.getParameter(Ca);
  }
  function qt(s, h, E) {
    if (s.getFramebufferAttachmentParameter(s.FRAMEBUFFER, h, s.FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE) === s.NONE)
      return;
    const I = s.getFramebufferAttachmentParameter(s.FRAMEBUFFER, h, s.FRAMEBUFFER_ATTACHMENT_OBJECT_NAME);
    I instanceof WebGLTexture && (E.has(I) || E.set(I, []), E.get(I).push(h));
  }
  function Ba(s, h) {
    const E = s.getParameter(s.FRAMEBUFFER_BINDING);
    if (!E)
      return [];
    const v = Na(s), I = /* @__PURE__ */ new Map();
    for (let N = 0; N < v; ++N)
      qt(s, s.COLOR_ATTACHMENT0 + N, I);
    qt(s, s.DEPTH_ATTACHMENT, I), qt(s, s.STENCIL_ATTACHMENT, I), e(s) || qt(s, s.DEPTH_STENCIL_ATTACHMENT, I);
    const D = s.getParameter(s.ACTIVE_TEXTURE), O = s.getParameter(s.CURRENT_PROGRAM), U = s.getProgramParameter(O, s.ACTIVE_UNIFORMS), L = [];
    for (let N = 0; N < U; ++N) {
      const { name: G, type: ae, size: he } = s.getActiveUniform(O, N);
      if (!(t(G) || !Zt(ae)))
        if (he > 1) {
          const Ae = G.substr(-3) === "[0]" ? G.substr(0, G.length - 3) : G;
          for (let be = 0; be < he; ++be)
            L.push(...Qr(s, E, I, O, `${Ae}[${be}]`, ae, h));
        } else
          L.push(...Qr(s, E, I, O, G, ae, h));
    }
    return s.activeTexture(D), L;
  }
  function Qr(s, h, E, v, I, D, O) {
    const U = s.getUniformLocation(v, I), L = s.getUniform(v, U), N = Ia(s, L, D), G = E.get(N);
    return G ? [`${O(N)} on uniform: ${I} bound to texture unit ${L} is also attached to ${O(h)} on attachment: ${G.map((ae) => A(ae)).join(", ")}`] : [];
  }
  function Pa() {
    const s = navigator.userAgent;
    let h = s.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];
    if (/trident/i.test(h[1]))
      return h = /\brv[ :]+(\d+)/g.exec(s) || [], {
        name: "IE",
        version: h[1]
      };
    if (h[1] === "Chrome") {
      const v = s.match(/\b(OPR|Edge)\/(\d+)/);
      if (v)
        return {
          name: v[1].replace("OPR", "Opera"),
          version: v[2]
        };
    }
    h = h[2] ? [h[1], h[2]] : [navigator.appName, navigator.appVersion, "-?"];
    const E = s.match(/version\/(\d+)/i);
    return E && h.splice(1, 1, E[1]), {
      name: h[0],
      version: h[1]
    };
  }
  const Da = function() {
    const s = Pa();
    let h, E;
    return /chrome|opera/i.test(s.name) ? (h = 3, E = function(v) {
      const I = /at ([^(]+)*\(*(.*?):(\d+):(\d+)/.exec(v);
      if (I) {
        let D = I[1], O = I[2];
        const U = parseInt(I[3]), L = parseInt(I[4]);
        return O === "" && (O = D, D = ""), {
          url: O,
          lineNo: U,
          colNo: L,
          funcName: D
        };
      }
    }) : /firefox|safari/i.test(s.name) && (h = 2, E = function(v) {
      const I = /@(.*?):(\d+):(\d+)/.exec(v);
      if (I) {
        const D = I[1], O = parseInt(I[2]), U = parseInt(I[3]);
        return {
          url: D,
          lineNo: O,
          colNo: U
        };
      }
    }), function(I) {
      if (E)
        try {
          const D = I.split(`
`);
          return E(D[h]);
        } catch {
        }
    };
  }();
  function Ua(s) {
    const h = [], E = s.getParameter(s.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
    for (let v = 0; v < E; ++v)
      h.push(/* @__PURE__ */ new Map());
    return h;
  }
  const Ma = 33984, Un = 3553, Mn = 32879, ut = 34067, en = 34069, Zr = 34070, qr = 34071, eo = 34072, to = 34073, no = 34074, ro = 10241, oo = 10240, tn = 33084, io = 33085, so = 10242, ao = 10243, uo = 10497, co = 35866, nn = 33071, On = 9728, fo = 9729, Oa = 9986, La = /* @__PURE__ */ new Map([
    [9, function([s, h, E, v, I, , D, O]) {
      return { target: s, level: h, internalFormat: E, width: v, height: I, format: D, type: O };
    }],
    [6, function([s, h, E, v, I, D]) {
      return { target: s, level: h, internalFormat: E, width: D.width, height: D.height, format: v, type: I };
    }],
    [10, function([s, h, E, v, I, , D, O]) {
      return { target: s, level: h, internalFormat: E, width: v, height: I, format: D, type: O };
    }]
  ]), rn = 6406, Le = 6407, ke = 6408, on = 6409, sn = 6410, Ln = 6402, lo = 34041, mo = /* @__PURE__ */ new Set([
    rn,
    on,
    sn,
    Le,
    ke
  ]);
  function Ut(s, h) {
    return mo.has(s) ? `${A(s)}/${A(h)}` : A(s);
  }
  const _o = /* @__PURE__ */ new Map([
    [Un, 0],
    [Mn, 0],
    [co, 0],
    [ut, 0],
    [en, 0],
    [Zr, 1],
    [qr, 2],
    [eo, 3],
    [to, 4],
    [no, 5]
  ]);
  function kn(s, h) {
    return h === ut ? `(${A(en + s)})` : "";
  }
  const ka = [
    Un
  ], $a = [
    en,
    Zr,
    qr,
    eo,
    to,
    no
  ], za = 33321, Va = 36756, po = 33325, ho = 33326, Ga = 33330, Ha = 33329, Xa = 33338, Ya = 33337, Wa = 33340, ja = 33339, Ka = 33323, Ja = 36757, bo = 33327, xo = 33328, Qa = 33336, Za = 33335, qa = 33332, eu = 33331, tu = 33334, nu = 33333, ru = 32849, ou = 35905, iu = 36194, su = 36758, au = 35898, uu = 35901, yo = 34843, Eo = 34837, cu = 36221, fu = 36239, lu = 36215, du = 36233, mu = 36209, _u = 36227, pu = 32856, hu = 35907, bu = 36759, xu = 32855, yu = 32854, Eu = 32857, go = 34842, Ao = 34836, gu = 36220, Au = 36238, Tu = 36975, vu = 36214, Su = 36232, Ru = 36226, wu = 36208, Fu = 33189, Iu = 33190, Cu = 36012, Nu = 36013, Bu = 35056, ct = 5120, ge = 5121, an = 5122, Mt = 5123, un = 5124, St = 5125, Me = 5126, To = 32819, vo = 32820, So = 33635, ft = 5131, Ro = 36193, $n = 33640, Pu = 35899, Du = 35902, Uu = 36269, Mu = 34042, cn = 33319, Rt = 33320, fn = 6403, wt = 36244, Ft = 36248, Et = 36249;
  function Ou() {
    const s = /* @__PURE__ */ new Map([
      // unsized formats
      [rn, { textureFormat: rn, colorRenderable: !0, textureFilterable: !0, bytesPerElement: [1, 2, 2, 4], type: [ge] }],
      [on, { textureFormat: on, colorRenderable: !0, textureFilterable: !0, bytesPerElement: [1, 2, 2, 4], type: [ge] }],
      [sn, { textureFormat: sn, colorRenderable: !0, textureFilterable: !0, bytesPerElement: [2, 4, 4, 8], type: [ge] }],
      [Le, { textureFormat: Le, colorRenderable: !0, textureFilterable: !0, bytesPerElement: [3, 6, 6, 12, 2], type: [ge, So] }],
      [ke, { textureFormat: ke, colorRenderable: !0, textureFilterable: !0, bytesPerElement: [4, 8, 8, 16, 2, 2], type: [ge, To, vo] }],
      // sized formats
      [za, { textureFormat: fn, colorRenderable: !0, textureFilterable: !0, bytesPerElement: [1], type: [ge] }],
      [Va, { textureFormat: fn, colorRenderable: !1, textureFilterable: !0, bytesPerElement: [1], type: [ct] }],
      [po, { textureFormat: fn, colorRenderable: !1, textureFilterable: !0, bytesPerElement: [4, 2], type: [Me, ft] }],
      [ho, { textureFormat: fn, colorRenderable: !1, textureFilterable: !1, bytesPerElement: [4], type: [Me] }],
      [Ga, { textureFormat: wt, colorRenderable: !0, textureFilterable: !1, bytesPerElement: [1], type: [ge] }],
      [Ha, { textureFormat: wt, colorRenderable: !0, textureFilterable: !1, bytesPerElement: [1], type: [ct] }],
      [qa, { textureFormat: wt, colorRenderable: !0, textureFilterable: !1, bytesPerElement: [2], type: [Mt] }],
      [eu, { textureFormat: wt, colorRenderable: !0, textureFilterable: !1, bytesPerElement: [2], type: [an] }],
      [tu, { textureFormat: wt, colorRenderable: !0, textureFilterable: !1, bytesPerElement: [4], type: [St] }],
      [nu, { textureFormat: wt, colorRenderable: !0, textureFilterable: !1, bytesPerElement: [4], type: [un] }],
      [Ka, { textureFormat: cn, colorRenderable: !0, textureFilterable: !0, bytesPerElement: [2], type: [ge] }],
      [Ja, { textureFormat: cn, colorRenderable: !1, textureFilterable: !0, bytesPerElement: [2], type: [ct] }],
      [bo, { textureFormat: cn, colorRenderable: !1, textureFilterable: !0, bytesPerElement: [8, 4], type: [Me, ft] }],
      [xo, { textureFormat: cn, colorRenderable: !1, textureFilterable: !1, bytesPerElement: [8], type: [Me] }],
      [Qa, { textureFormat: Rt, colorRenderable: !0, textureFilterable: !1, bytesPerElement: [2], type: [ge] }],
      [Za, { textureFormat: Rt, colorRenderable: !0, textureFilterable: !1, bytesPerElement: [2], type: [ct] }],
      [Xa, { textureFormat: Rt, colorRenderable: !0, textureFilterable: !1, bytesPerElement: [4], type: [Mt] }],
      [Ya, { textureFormat: Rt, colorRenderable: !0, textureFilterable: !1, bytesPerElement: [4], type: [an] }],
      [Wa, { textureFormat: Rt, colorRenderable: !0, textureFilterable: !1, bytesPerElement: [8], type: [St] }],
      [ja, { textureFormat: Rt, colorRenderable: !0, textureFilterable: !1, bytesPerElement: [8], type: [un] }],
      [ru, { textureFormat: Le, colorRenderable: !0, textureFilterable: !0, bytesPerElement: [3], type: [ge] }],
      [ou, { textureFormat: Le, colorRenderable: !1, textureFilterable: !0, bytesPerElement: [3], type: [ge] }],
      [iu, { textureFormat: Le, colorRenderable: !0, textureFilterable: !0, bytesPerElement: [3, 2], type: [ge, So] }],
      [su, { textureFormat: Le, colorRenderable: !1, textureFilterable: !0, bytesPerElement: [3], type: [ct] }],
      [au, { textureFormat: Le, colorRenderable: !1, textureFilterable: !0, bytesPerElement: [12, 6, 4], type: [Me, ft, Pu] }],
      [uu, { textureFormat: Le, colorRenderable: !1, textureFilterable: !0, bytesPerElement: [12, 6, 4], type: [Me, ft, Du] }],
      [yo, { textureFormat: Le, colorRenderable: !1, textureFilterable: !0, bytesPerElement: [12, 6], type: [Me, ft] }],
      [Eo, { textureFormat: Le, colorRenderable: !1, textureFilterable: !1, bytesPerElement: [12], type: [Me] }],
      [cu, { textureFormat: Ft, colorRenderable: !1, textureFilterable: !1, bytesPerElement: [3], type: [ge] }],
      [fu, { textureFormat: Ft, colorRenderable: !1, textureFilterable: !1, bytesPerElement: [3], type: [ct] }],
      [lu, { textureFormat: Ft, colorRenderable: !1, textureFilterable: !1, bytesPerElement: [6], type: [Mt] }],
      [du, { textureFormat: Ft, colorRenderable: !1, textureFilterable: !1, bytesPerElement: [6], type: [an] }],
      [mu, { textureFormat: Ft, colorRenderable: !1, textureFilterable: !1, bytesPerElement: [12], type: [St] }],
      [_u, { textureFormat: Ft, colorRenderable: !1, textureFilterable: !1, bytesPerElement: [12], type: [un] }],
      [pu, { textureFormat: ke, colorRenderable: !0, textureFilterable: !0, bytesPerElement: [4], type: [ge] }],
      [hu, { textureFormat: ke, colorRenderable: !0, textureFilterable: !0, bytesPerElement: [4], type: [ge] }],
      [bu, { textureFormat: ke, colorRenderable: !1, textureFilterable: !0, bytesPerElement: [4], type: [ct] }],
      [xu, { textureFormat: ke, colorRenderable: !0, textureFilterable: !0, bytesPerElement: [4, 2, 4], type: [ge, vo, $n] }],
      [yu, { textureFormat: ke, colorRenderable: !0, textureFilterable: !0, bytesPerElement: [4, 2], type: [ge, To] }],
      [Eu, { textureFormat: ke, colorRenderable: !0, textureFilterable: !0, bytesPerElement: [4], type: [$n] }],
      [go, { textureFormat: ke, colorRenderable: !1, textureFilterable: !0, bytesPerElement: [16, 8], type: [Me, ft] }],
      [Ao, { textureFormat: ke, colorRenderable: !1, textureFilterable: !1, bytesPerElement: [16], type: [Me] }],
      [gu, { textureFormat: Et, colorRenderable: !0, textureFilterable: !1, bytesPerElement: [4], type: [ge] }],
      [Au, { textureFormat: Et, colorRenderable: !0, textureFilterable: !1, bytesPerElement: [4], type: [ct] }],
      [Tu, { textureFormat: Et, colorRenderable: !0, textureFilterable: !1, bytesPerElement: [4], type: [$n] }],
      [vu, { textureFormat: Et, colorRenderable: !0, textureFilterable: !1, bytesPerElement: [8], type: [Mt] }],
      [Su, { textureFormat: Et, colorRenderable: !0, textureFilterable: !1, bytesPerElement: [8], type: [an] }],
      [Ru, { textureFormat: Et, colorRenderable: !0, textureFilterable: !1, bytesPerElement: [16], type: [un] }],
      [wu, { textureFormat: Et, colorRenderable: !0, textureFilterable: !1, bytesPerElement: [16], type: [St] }],
      // Sized Internal                                                                         these are marked as not filterable but for some reason they apparently are?
      [Fu, { textureFormat: Ln, colorRenderable: !0, textureFilterable: !0, bytesPerElement: [2, 4], type: [Mt, St] }],
      [Iu, { textureFormat: Ln, colorRenderable: !0, textureFilterable: !0, bytesPerElement: [4], type: [St] }],
      [Cu, { textureFormat: Ln, colorRenderable: !0, textureFilterable: !0, bytesPerElement: [4], type: [Me] }],
      [Bu, { textureFormat: lo, colorRenderable: !0, textureFilterable: !1, bytesPerElement: [4], type: [Mu] }],
      [Nu, { textureFormat: lo, colorRenderable: !0, textureFilterable: !1, bytesPerElement: [4], type: [Uu] }]
    ]);
    s.forEach((E) => {
      E.bytesPerElementMap = {}, E.bytesPerElement.forEach(function(v, I) {
        const D = E.type[I];
        E.bytesPerElementMap[D] = v;
      });
    });
    const h = /* @__PURE__ */ new Map();
    return s.forEach((E, v) => {
      mo.has(v) ? E.type.forEach((I) => {
        h.set(
          Ut(v, I),
          E
        );
      }) : h.set(
        Ut(v),
        E
      );
    }), {
      textureInternalFormatInfoMap: s,
      internalFormatStringToFormatInfoMap: h
    };
  }
  function ln(s) {
    return (s & s - 1) === 0;
  }
  function zn(s, h = 0, E = 0) {
    return (Math.log2(Math.max(s, h, E)) | 0) + 1;
  }
  function dn(s, ...h) {
    return s ? h : [];
  }
  function wo(s, h) {
    return [
      ...dn(!ln(s), `width(${s}) is not a power of 2`),
      ...dn(!ln(h), `height(${h}) is not a power of 2`)
    ].join(" and ");
  }
  function Lu(s, h) {
    return [
      ...dn(s !== nn, `TEXTURE_WRAP_S (${A(s)}) is not CLAMP_TO_EDGE`),
      ...dn(h !== nn, `TEXTURE_WRAP_T (${A(h)}) is not CLAMP_TO_EDGE`)
    ].join(" and ");
  }
  function ku(s) {
    const h = A(s);
    return h.endsWith("UI") ? "unsigned int" : h.endsWith("I") ? "int" : "float/normalized";
  }
  function Fo(s, h, E, v) {
    return s === Un || s === ut ? `${h}x${E}` : `${h}x${E}x${v}`;
  }
  class $u {
    constructor(h, E) {
      this.redundantStateSetting = E;
      const v = e(h), I = !v, D = /* @__PURE__ */ new Set(), O = /* @__PURE__ */ new Map(), U = /* @__PURE__ */ new Map(), L = Ua(h), N = zn(h.getParameter(h.MAX_TEXTURE_SIZE)), { internalFormatStringToFormatInfoMap: G } = Ou();
      let ae = 0, he = L[0];
      this.numTextureUnits = L.length;
      function Ae(P) {
        P.notRenderable = Te(P, P.parameters);
      }
      function be() {
        O.forEach(Ae);
      }
      function Te(P, M) {
        const { type: w, mips: R } = P, B = M.get(tn) || 0, X = Lr(M.get(io), N);
        if (X < B)
          return `TEXTURE_MAX_LEVEL(${X}) is less than TEXTURE_BASE_LEVEL(${B})`;
        const $ = R[B];
        if (!$)
          return "no base level mip ${baseLevel}";
        const ne = $[0];
        if (!ne)
          return "TEXTURE_CUBE_MAP_POSITIVE_X face does not exist";
        const {
          width: J,
          height: q,
          depth: ve,
          // internalFormat: baseInternalFormat,
          internalFormatString: le
        } = ne, De = w === ut ? 6 : 1, Se = M.get(ro), lt = G.get(le);
        if (lt && !lt.textureFilterable) {
          if (Se !== On)
            return `texture of type (${le}) is not filterable but TEXTURE_MIN_FILTER is set to ${A(Se)}`;
          {
            const Fe = M.get(oo);
            if (Fe !== On)
              return `texture of type (${le}) is not filterable but TEXTURE_MAG_FILTER is set to ${A(Fe)}`;
          }
        }
        const Ze = Se === fo || Se === On ? 1 : zn(J, q, ve);
        {
          let xe = J, Fe = q, qe = ve;
          const Xe = Math.min(X, B + Ze - 1);
          for (let ce = B; ce <= Xe; ++ce) {
            const At = R[ce];
            if (!At)
              return `filtering is set to use mips from level ${B} to ${Xe} with (TEXTURE_MIN_FILTER = ${A(Se)}) but mip level ${ce} does not exist`;
            for (let dt = 0; dt < De; ++dt) {
              const Ye = At[dt];
              if (!Ye)
                return `filtering is set to use mips level ${B} to ${Xe} with (TEXTURE_MIN_FILTER = ${A(Se)}) but mip level ${ce}${kn(dt, w)} does not exist`;
              if (Ye.width !== xe || Ye.height !== Fe || Ye.depth !== qe)
                return `mip level ${ce}${kn(dt, w)} needs to be ${Fo(w, xe, Fe, qe)} but it is ${Fo(w, Ye.width, Ye.height, Ye.depth)}`;
              if (Ye.internalFormatString !== le)
                return `mip level ${ce}${kn(dt, w)}'s internal format ${Ye.internalFormatString} does not match mip level ${B}'s internal format ${le}`;
            }
            xe = Math.max(1, xe / 2 | 0), Fe = Math.max(1, Fe / 2 | 0), w !== co && (qe = Math.max(1, qe / 2 | 0));
          }
        }
        if (I && (!ln(J) || !ln(q))) {
          if (Ze > 1)
            return `texture's ${wo(J, q)} but TEXTURE_MIN_FILTER (${A(Se)}) is set to need mips`;
          const xe = M.get(so), Fe = M.get(ao);
          if (xe !== nn || Fe !== nn)
            return `texture's ${wo(J, q)} but ${Lu(xe, Fe)}.`;
        }
        if (w === ut && J !== q)
          return `texture is CUBE_MAP but dimensions ${J}x${q} are not square`;
      }
      function fe(P) {
        const M = Wr(P), w = he.get(M);
        return O.get(w);
      }
      function ot(P, M) {
        const w = fe(P), R = _o.get(P);
        return w.mips[M][R];
      }
      function Qe(P, M, w) {
        const R = fe(P);
        R.parameters.set(M, w), Ae(R);
      }
      function gt(P, M) {
        for (let w = 0; w < L.length; ++w) {
          const R = L[w];
          R.get(P) === M && R.set(P, null);
        }
      }
      function K(P) {
        const { mips: M, parameters: w } = P, R = w.get(tn) || 0, B = M[R];
        if (!B)
          return "";
        const X = B[0];
        return X ? X.internalFormatString : "";
      }
      function ue(P, M) {
        const w = D.has(M);
        [
          ke,
          Le,
          on,
          sn,
          rn
        ].forEach((R) => {
          G.set(
            Ut(R, P),
            { textureFormat: h.RGBA, textureFilterable: w }
          );
        });
      }
      function _n(P) {
        for (const M of P) {
          const w = G.get(
            Ut(M)
          );
          w.textureFilterable = !0;
        }
      }
      this.addExtension = function(P) {
        switch (D.add(P), P) {
          case "oes_texture_float":
            ue(Me, "oes_texture_float_linear");
            break;
          case "oes_texture_float_linear":
            v ? _n([
              ho,
              xo,
              Eo,
              Ao
            ]) : D.has("oes_texture_float") && ue(Me, "oes_texture_float_linear"), be();
            break;
          case "oes_texture_half_float":
            ue(ft, "oes_texture_half_float_linear"), ue(Ro, "oes_texture_half_float_linear");
            break;
          case "oes_texture_half_float_linear":
            v ? _n([
              po,
              bo,
              yo,
              go
            ]) : D.has("oes_texture_half_float") && (ue(ft, "oes_texture_half_float_linear"), ue(Ro, "oes_texture_half_float_linear")), be();
            break;
          default:
            return;
        }
      }, this.getTextureForTextureUnit = function(P, M) {
        return L[P].get(M);
      }, this.getTextureUnitUnrenderableReason = function(P, M, w, R) {
        const B = L[M].get(w);
        if (!B)
          return `no texture bound to texture unit ${M} ${w}`;
        const X = O.get(B), { mips: $, parameters: ne } = X, J = ne.get(tn) || 0, q = $[J];
        if (!q)
          return `no mip level ${J}`;
        const ve = q[0];
        if (!ve)
          return `TEXTURE_CUBE_MAP_POSITIVE_X face at mip level ${J} does not exist`;
        const le = ku(ve.internalFormat), De = pa(P);
        if (le !== De)
          return `uniform ${Yr(P)} needs a ${De} texture but ${R(B)} on texture unit ${M} is ${le} texture (${K(X)})`;
        const Se = L[M].get("SAMPLER");
        if (Se) {
          const lt = U.get(Se), Ze = Te(X, lt);
          return Ze && `${Ze} with sampler ${R(Se)} bound to texture unit ${M}`;
        } else
          return X.notRenderable;
      };
      function we(P, M, w, R, B, X, $ = 0) {
        const ne = Ut(w, $), J = fe(P), { mips: q } = J;
        q[M] || (q[M] = []);
        const ve = _o.get(P);
        q[M][ve] = { width: R, height: B, depth: X, internalFormatString: ne, internalFormat: w, type: $ }, Ae(J);
      }
      this.postChecks = {
        activeTexture(P, M, w) {
          ae = w[0] - Ma, he = L[ae];
        },
        bindTexture(P, M, w) {
          const [R, B] = w, X = Wr(R);
          if (he.get(X) === B)
            ++E.bindTexture;
          else if (he.set(X, B), B) {
            const $ = O.get(B);
            if ($.type) {
              if ($.type !== R)
                throw new Error("should never get here");
            } else
              $.type = R;
          }
        },
        createTexture(P, M, w, R) {
          const B = {
            mips: [],
            parameters: /* @__PURE__ */ new Map([
              [ro, Oa],
              [oo, fo],
              [so, uo],
              [ao, uo]
            ]),
            renderable: !1
          };
          O.set(R, B);
        },
        deleteTexture(P, M, w) {
          const [R] = w, { type: B } = O.get(R);
          O.delete(R), gt(B, R);
        },
        createSampler(P, M, w, R) {
          U.set(R, /* @__PURE__ */ new Map());
        },
        deleteSampler(P, M, w) {
          const [R] = w;
          U.delete(R), gt("SAMPLER", R);
        },
        bindSampler(P, M, w) {
          const [R, B] = w;
          B === L[R].get("SAMPLER") ? ++E.bindSampler : L[R].set("SAMPLER", B);
        },
        samplerParameteri(P, M, w) {
          const [R, B, X] = w;
          U.get(R).set(B, X);
        },
        copyTexImage2D(P, M, w) {
          const [R, B, X, $, ne] = w, J = P.UNSIGNED_BYTE;
          we(R, B, X, $, ne, 1, J);
        },
        texImage2D(P, M, w) {
          const R = La.get(w.length), { target: B, level: X, internalFormat: $, width: ne, height: J, type: q } = R(w);
          we(B, X, $, ne, J, 1, q);
        },
        texImage3D(P, M, w) {
          const [R, B, X, $, ne, J, , , q] = w;
          we(R, B, X, $, ne, J, q);
        },
        texStorage2D(P, M, w) {
          const [R, B, X, $, ne] = w;
          let J = $, q = ne;
          const ve = R === ut ? $a : ka;
          for (let le = 0; le < B; ++le) {
            for (const De of ve)
              we(De, le, X, J, q, 1);
            J = Math.max(1, J / 2 | 0), q = Math.max(1, q / 2 | 0);
          }
        },
        texStorage3D(P, M, w) {
          const [R, B, X, $, ne, J] = w;
          let q = $, ve = ne, le = J;
          for (let De = 0; De < B; ++De)
            we(R, De, X, q, ve, le), q = Math.max(1, q / 2 | 0), ve = Math.max(1, ve / 2 | 0), R === Mn && (le = Math.max(1, le / 2 | 0));
        },
        generateMipmap(P, M, w) {
          const [R] = w, B = fe(R), { parameters: X } = B, $ = X.get(tn) || 0, ne = Lr(X.get(io), N), J = ot(R, $), { width: q, height: ve, depth: le, internalFormat: De, type: Se } = J, lt = Math.min(zn(q, ve, le), ne + 1 - $), Ze = R === ut ? 6 : 1;
          let xe = q, Fe = ve, qe = le;
          for (let Xe = 0; Xe < lt; ++Xe) {
            xe = Math.max(1, xe / 2 | 0), Fe = Math.max(1, Fe / 2 | 0), R === Mn && (qe = Math.max(1, qe / 2 | 0));
            for (let ce = 0; ce < Ze; ++ce) {
              const At = R === ut ? en + ce : R;
              we(At, $ + Xe, De, xe, Fe, qe, Se);
            }
          }
        },
        compressedTexImage2D(P, M, w) {
          const [R, B, X, $, ne] = w;
          we(R, B, X, $, ne, 1);
        },
        compressedTexImage3D(P, M, w) {
          const [R, B, X, $, ne, J] = w;
          we(R, B, X, $, ne, J);
        },
        texParameteri(P, M, w) {
          const [R, B, X] = w;
          Qe(R, B, X);
        }
      };
    }
  }
  class Io {
    constructor(h) {
      this.elementAttribArray = null, this.attribs = [];
      for (let E = 0; E < h; ++E)
        this.attribs.push({
          size: 0,
          type: 0,
          normalize: !1,
          stride: 0,
          offset: 0,
          divisor: 0,
          buffer: null,
          iPointer: !1
        });
    }
    setElementArrayBuffer(h, E) {
      at(this.elementAttribArray, E) ? ++h.bindBuffer : this.elementAttribArray = st(E);
    }
    setAttrib(h, E, v, I, D, O, U, L, N) {
      const G = this.attribs[v];
      at(G.buffer, N) && G.iPointer === E && G.size === I && G.type === D && G.normalize === O && G.stride === U && G.offset === L ? ++h.vertexAttribPointer : Object.assign(G, {
        iPointer: E,
        size: I,
        type: D,
        normalize: O,
        stride: U,
        offset: L,
        buffer: st(N)
      });
    }
  }
  class zu {
    constructor(h, E) {
      this.gl = h, this.redundantStateSetting = E, this.numAttribs = h.getParameter(h.MAX_VERTEX_ATTRIBS), this.vertexArrays = /* @__PURE__ */ new WeakMap(), this.defaultVertexArray = new Io(this.numAttribs), this.currentVertexArray = this.defaultVertexArray;
      const v = (O, U, L, N) => {
        this.vertexArrays.set(N, new Io(this.numAttribs));
      }, I = (O, U, L) => {
        const [N] = L, G = this.vertexArrays.get(N);
        this.currentVertexArray === G && (this.currentVertexArray = this.defaultVertexArray), this.vertexArrays.delete(N);
      }, D = (O, U, L) => {
        let [N] = L;
        N = N ? this.vertexArrays.get(N) : this.defaultVertexArray, N === this.currentVertexArray ? ++this.redundantStateSetting.bindVertexArray : this.currentVertexArray = N;
      };
      this.postChecks = {
        createVertexArray: v,
        createVertexArrayOES: v,
        bindVertexArray: D,
        bindVertexArrayOES: D,
        bindBuffer: (O, U, L) => {
          const [N, G] = L;
          N === h.ELEMENT_ARRAY_BUFFER && this.currentVertexArray.setElementArrayBuffer(this.redundantStateSetting, G);
        },
        deleteVertexArray: I,
        deleteVertexArrayOES: I,
        vertexAttribPointer: (O, U, L) => {
          const [N, G, ae, he, Ae, be] = L, Te = this.gl;
          this.currentVertexArray.setAttrib(this.redundantStateSetting, !1, N, G, ae, he, Ae, be, Te.getParameter(Te.ARRAY_BUFFER_BINDING));
        },
        vertexAttribIPointer: (O, U, L) => {
          const [N, G, ae, he, Ae] = L, be = this.gl;
          this.currentVertexArray.setAttrib(this.redundantStateSetting, !0, N, G, ae, !1, he, Ae, be.getParameter(be.ARRAY_BUFFER_BINDING));
        }
      };
    }
  }
  const Co = u([
    "COLOR_BUFFER_BIT",
    "DEPTH_BUFFER_BIT",
    "STENCIL_BUFFER_BIT"
  ]);
  function mn(s, h) {
    Array.isArray(s[h]) && (s[h] = Object.fromEntries(s[h].map((E) => [Math.abs(E), E])));
  }
  function Vu(s, h, E, v) {
    const I = E[0], D = v.locationsToNamesMap.get(I), O = s.getParameter(s.CURRENT_PROGRAM), U = [];
    if (D && U.push(`trying to set uniform '${D}'`), O) {
      const L = v.webglObjectToNamesMap.get(O);
      L && U.push(`on WebGLProgram(${r(L)})`);
    } else
      U.push("on ** no current program **");
    return U.length ? `: ${U.join(" ")}` : "";
  }
  function No(s) {
    if (Array.isArray(s) || n(s) || typeof s != "object")
      throw new Error("not a WebGLObject");
  }
  function Gu() {
    return {
      elementArrayBuffer: null,
      vertexAttribs: []
    };
  }
  const Vn = /* @__PURE__ */ new Set(), Bo = {
    useProgram: 0,
    bindBuffer: 0,
    bindFramebuffer: 0,
    bindRenderbuffer: 0,
    bindSampler: 0,
    bindTexture: 0,
    bindVertexArray: 0,
    enableDisable: 0,
    vertexAttribPointer: 0
  };
  function Po(s, h, E = {}) {
    if (Vn.has(s))
      return s;
    Vn.add(s);
    const v = E.origGLErrorFn || s.getError;
    x(s);
    function I(a) {
      const l = Gu(), f = { ...Bo }, d = {};
      for (const g in a) {
        const S = a[g];
        d[g] = typeof S == "function" ? function(...F) {
          return S.call(a, ...F);
        } : S;
      }
      const b = {
        baseContext: a,
        config: E,
        apis: { gman_debug_helper: {
          ctx: {
            tagObject(g, S) {
              No(g), b.webglObjectToNamesMap.set(g, S);
            },
            untagObject(g) {
              No(g), b.webglObjectToNamesMap.delete(g);
            },
            getTagForObject(g) {
              return b.webglObjectToNamesMap.get(g);
            },
            disable() {
              R();
            },
            setConfiguration(g) {
              for (const [S, F] of Object.entries(g)) {
                if (!(S in b.config))
                  throw new Error(`unknown configuration option: ${S}`);
                b.config[S] = F;
              }
              for (const S of b.config.ignoreUniforms)
                b.ignoredUniforms.add(S);
            },
            getAndResetRedundantCallInfo() {
              const g = { ...f };
              if (Object.assign(f, Bo), this._checksRemoved)
                for (const S of Object.keys(g))
                  g[S] = "invalid is webgl-lint is no longer running. maxDrawCalls exceeded";
              return g;
            }
          }
        } },
        idCounts: {},
        textureManager: new $u(d, f),
        vertexArrayManager: new zu(d, f),
        bufferToIndices: /* @__PURE__ */ new Map(),
        ignoredUniforms: /* @__PURE__ */ new Set(),
        // Okay or bad? This is a map of all WebGLUniformLocation object looked up
        // by the user via getUniformLocation. We use this to map a location back to
        // a name and unfortunately a WebGLUniformLocation is not unique, by which
        // I mean if you call get getUniformLocation twice for the same uniform you'll
        // get 2 different WebGLUniformLocation objects referring to the same location.
        //
        // So, that means I can't look up the locations myself and know what they are
        // unless I passed the location objects I looked up back to the user but if I
        // did that then technically I'd have changed the semantics (though I suspect
        // no one ever takes advantage of that quirk)
        //
        // In any case this is all uniforms for all programs. That means in order
        // to clean up later I have to track all the uniforms (see programToUniformMap)
        // so that makes me wonder if I should track names per program instead.
        //
        // The advantage to this global list is given a WebGLUniformLocation and
        // no other info I can lookup the name where as if I switch it to per-program
        // then I need to know the program. That's generally available but it's indirect.
        locationsToNamesMap: /* @__PURE__ */ new Map(),
        webglObjectToNamesMap: /* @__PURE__ */ new Map(),
        // @typedef {Object} UnusedUniformRef
        // @property {number} index the index of this name. for foo[3] it's 3
        // @property {Map<string, number>} altNames example <foo,0>, <foo[0],0>, <foo[1],1>, <foo[2],2>, <foo[3],3>  for `uniform vec4 foo[3]`
        // @property {Set<number>} unused this is size so for the example above it's `Set<[0, 1, 2, 3]`
        // Both the altName array and the unused Set are shared with an entry in `programToUnsetUniformsMap`
        // by each name (foo, foo[0], foo[1], foo[2]). That we we can unused.delete each element of set
        // and if set is empty then delete all altNames entries from programToUnsetUniformsMap.
        // When programsToUniformsMap is empty all uniforms have been set.
        // @typedef {Map<WebGLProgram, Map<string, UnusedUniformRef>}
        programToUnsetUniformsMap: /* @__PURE__ */ new Map(),
        // class UniformInfo {
        //   index: the index of this name. for foo[3] it's 3
        //   size: this is the array size for this uniform
        //   type: the enum for the type like FLOAT_VEC4
        // }
        /** @type {WebGLProgram, Map<UniformInfo>} */
        programToUniformInfoMap: /* @__PURE__ */ new Map(),
        /** @type {WebGLProgram, Set<WebGLUniformLocation>} */
        programToLocationsMap: /* @__PURE__ */ new Map(),
        // class UniformSamplerInfo {
        //   type: the enum for the uniform type like SAMPLER_2D
        //   values: number[],
        //   name: string
        // }
        /** @type {WebGLProgram, UniformSamplerInfo[]} */
        programToUniformSamplerValues: /* @__PURE__ */ new Map(),
        // state for state tracking
        defaultVertexArray: l,
        webglState: {
          currentProgram: null,
          buffers: {},
          currentReadFramebuffer: null,
          currentDrawFramebuffer: null,
          currentRenderbuffer: null,
          textureUnits: [],
          enabled: {}
        },
        redundantStateSetting: f
      };
      return b;
    }
    const D = E.sharedState || I(s);
    E.sharedState = D;
    const {
      apis: O,
      baseContext: U,
      bufferToIndices: L,
      config: N,
      ignoredUniforms: G,
      locationsToNamesMap: ae,
      programToLocationsMap: he,
      programToUniformInfoMap: Ae,
      programToUniformSamplerValues: be,
      programToUnsetUniformsMap: Te,
      textureManager: fe,
      vertexArrayManager: ot,
      webglObjectToNamesMap: Qe,
      idCounts: gt,
      webglState: K,
      redundantStateSetting: ue
    } = D;
    ({
      oes_texture_float(...a) {
        fe.addExtension(...a);
      },
      oes_texture_float_linear(...a) {
        fe.addExtension(...a);
      },
      OES_texture_half_float(...a) {
        fe.addExtension(...a);
      },
      oes_texture_half_float_linear(...a) {
        fe.addExtension(...a);
      }
    }[h] || X)(h);
    const we = {
      // Generic setters and getters
      enable: { 1: { enums: [0] } },
      disable: { 1: { enums: [0] } },
      getParameter: { 1: { enums: [0] } },
      // Rendering
      drawArrays: { 3: { enums: [0], numbers: [1, 2] } },
      drawElements: { 4: { enums: [0, 2], numbers: [1, 3] } },
      drawArraysInstanced: { 4: { enums: [0], numbers: [1, 2, 3] } },
      drawElementsInstanced: { 5: { enums: [0, 2], numbers: [1, 3, 4] } },
      drawRangeElements: { 6: { enums: [0, 4], numbers: [1, 2, 3, 5] } },
      // Shaders
      createShader: { 1: { enums: [0] } },
      getActiveAttrib: { 2: { numbers: [1] } },
      getActiveUniform: { 2: { numbers: [1] } },
      getShaderParameter: { 2: { enums: [1] } },
      getProgramParameter: { 2: { enums: [1] } },
      getShaderPrecisionFormat: { 2: { enums: [0, 1] } },
      bindAttribLocation: { 3: { numbers: [1] } },
      // Vertex attributes
      getVertexAttrib: { 2: { enums: [1], numbers: [0] } },
      vertexAttribPointer: { 6: { enums: [2], numbers: [0, 1, 4, 5] } },
      vertexAttribIPointer: { 5: { enums: [2], numbers: [0, 1, 3, 4] } },
      // WebGL2
      vertexAttribDivisor: { 2: { numbers: [0, 1] } },
      // WebGL2
      disableVertexAttribArray: { 1: { numbers: [0] } },
      enableVertexAttribArray: { 1: { numbers: [0] } },
      // Textures
      bindTexture: { 2: { enums: [0], undef: [1] } },
      activeTexture: { 1: { enums: [0, 1] } },
      getTexParameter: { 2: { enums: [0, 1] } },
      texParameterf: { 3: { enums: [0, 1] } },
      texParameteri: { 3: { enums: [0, 1, 2] } },
      texImage2D: {
        9: { enums: [0, 2, 6, 7], numbers: [1, 3, 4, 5], arrays: [-8] },
        6: { enums: [0, 2, 3, 4] },
        10: { enums: [0, 2, 6, 7], numbers: [1, 3, 4, 5, 9], arrays: { 8: Ju } }
        // WebGL2
      },
      texImage3D: {
        10: { enums: [0, 2, 7, 8], numbers: [1, 3, 4, 5] },
        // WebGL2
        11: { enums: [0, 2, 7, 8], numbers: [1, 3, 4, 5, 10], arrays: { 9: Hn } }
        // WebGL2
      },
      texSubImage2D: {
        9: { enums: [0, 6, 7], numbers: [1, 2, 3, 4, 5] },
        7: { enums: [0, 4, 5], numbers: [1, 2, 3] },
        10: { enums: [0, 6, 7], numbers: [1, 2, 3, 4, 5, 9], arrays: { 9: Hn } }
        // WebGL2
      },
      texSubImage3D: {
        11: { enums: [0, 8, 9], numbers: [1, 2, 3, 4, 5, 6, 7] },
        // WebGL2
        12: { enums: [0, 8, 9], numbers: [1, 2, 3, 4, 5, 6, 7, 11], arrays: { 10: Hn } }
        // WebGL2
      },
      texStorage2D: { 5: { enums: [0, 2], numbers: [1, 3, 4] } },
      // WebGL2
      texStorage3D: { 6: { enums: [0, 2], numbers: [1, 3, 4, 6] } },
      // WebGL2
      copyTexImage2D: { 8: { enums: [0, 2], numbers: [1, 3, 4, 5, 6, 7] } },
      copyTexSubImage2D: { 8: { enums: [0], numbers: [1, 2, 3, 4, 5, 6, 7] } },
      copyTexSubImage3D: { 9: { enums: [0], numbers: [1, 2, 3, 4, 5, 6, 7, 8] } },
      // WebGL2
      generateMipmap: { 1: { enums: [0] } },
      compressedTexImage2D: {
        7: { enums: [0, 2], numbers: [1, 3, 4, 5] },
        8: { enums: [0, 2], numbers: [1, 3, 4, 5, 7] },
        // WebGL2
        9: { enums: [0, 2], numbers: [1, 3, 4, 5, 7, 8] }
        // WebGL2
      },
      compressedTexSubImage2D: {
        8: { enums: [0, 6], numbers: [1, 2, 3, 4, 5] },
        9: { enums: [0, 6], numbers: [1, 2, 3, 4, 5, 8] },
        // WebGL2
        10: { enums: [0, 6], numbers: [1, 2, 3, 4, 5, 8, 9] }
        // WebGL2
      },
      compressedTexImage3D: {
        8: { enums: [0, 2], numbers: [1, 3, 4, 5, 6] },
        // WebGL2
        9: { enums: [0, 2], numbers: [1, 3, 4, 5, 6, -7, 8] },
        // WebGL2
        10: { enums: [0, 2], numbers: [1, 3, 4, 5, 6, 8, 9] }
        // WebGL2
      },
      compressedTexSubImage3D: {
        12: { enums: [0, 8], numbers: [1, 2, 3, 4, 5, 6, 7, 8, 10, 11] },
        // WebGL2
        11: { enums: [0, 8], numbers: [1, 2, 3, 4, 5, 6, 7, 8, -9, 10] },
        // WebGL2
        10: { enums: [0, 8], numbers: [1, 2, 3, 4, 5, 6, 7, 8] }
        // WebGL2
      },
      // Buffer objects
      bindBuffer: { 2: { enums: [0], undef: [1] } },
      bufferData: {
        3: { enums: [0, 2], numbers: [-1], arrays: [-1] },
        4: { enums: [0, 2], numbers: [-1, 3], arrays: { 1: Oo } },
        // WebGL2
        5: { enums: [0, 2], numbers: [-1, 3, 4], arrays: { 1: Lo } }
        // WebGL2
      },
      bufferSubData: {
        3: { enums: [0], numbers: [1], arrays: { 2: Ku } },
        4: { enums: [0], numbers: [1, 3], arrays: { 2: Oo } },
        // WebGL2
        5: { enums: [0], numbers: [1, 3, 4], arrays: { 2: Lo } }
        // WebGL2
      },
      copyBufferSubData: {
        5: { enums: [0], numbers: [2, 3, 4] }
        // WebGL2
      },
      getBufferParameter: { 2: { enums: [0, 1] } },
      getBufferSubData: {
        3: { enums: [0], numbers: [1] },
        // WebGL2
        4: { enums: [0], numbers: [1, 3] },
        // WebGL2
        5: { enums: [0], numbers: [1, 3, 4] }
        // WebGL2
      },
      // Renderbuffers and framebuffers
      pixelStorei: { 2: { enums: [0, 1], numbers: [1] } },
      readPixels: {
        7: { enums: [4, 5], numbers: [0, 1, 2, 3, -6] },
        8: { enums: [4, 5], numbers: [0, 1, 2, 3, 7] }
        // WebGL2
      },
      bindRenderbuffer: { 2: { enums: [0], undef: [1] } },
      bindFramebuffer: { 2: { enums: [0], undef: [1] } },
      blitFramebuffer: { 10: { enums: { 8: Co, 9: !0 }, numbers: [0, 1, 2, 3, 4, 5, 6, 7] } },
      // WebGL2
      checkFramebufferStatus: { 1: { enums: [0] } },
      framebufferRenderbuffer: { 4: { enums: [0, 1, 2] } },
      framebufferTexture2D: { 5: { enums: [0, 1, 2], numbers: [4] } },
      framebufferTextureLayer: { 5: { enums: [0, 1], numbers: [3, 4] } },
      // WebGL2
      getFramebufferAttachmentParameter: { 3: { enums: [0, 1, 2] } },
      getInternalformatParameter: { 3: { enums: [0, 1, 2] } },
      // WebGL2
      getRenderbufferParameter: { 2: { enums: [0, 1] } },
      invalidateFramebuffer: { 2: { enums: { 0: !0, 1: c } } },
      // WebGL2
      invalidateSubFramebuffer: { 6: { enums: { 0: !0, 1: c }, numbers: [2, 3, 4, 5] } },
      // WebGL2
      readBuffer: { 1: { enums: [0] } },
      // WebGL2
      renderbufferStorage: { 4: { enums: [0, 1], numbers: [2, 3] } },
      renderbufferStorageMultisample: { 5: { enums: [0, 2], numbers: [1, 3, 4] } },
      // WebGL2
      bindVertexBuffer: { 1: { undef: [1] } },
      bindVertexBufferOES: { 1: { undef: [1] } },
      // Frame buffer operations (clear, blend, depth test, stencil)
      lineWidth: { 1: { numbers: [0] } },
      polygonOffset: { 2: { numbers: [0, 1] } },
      scissor: { 4: { numbers: [0, 1, 2, 3] } },
      viewport: { 4: { numbers: [0, 1, 2, 3] } },
      clear: { 1: { enums: { 0: Co } } },
      clearColor: { 4: { numbers: [0, 1, 2, 3] } },
      clearDepth: { 1: { numbers: [0] } },
      clearStencil: { 1: { numbers: [0] } },
      depthFunc: { 1: { enums: [0] } },
      depthRange: { 2: { numbers: [0, 1] } },
      blendColor: { 4: { numbers: [0, 1, 2, 3] } },
      blendFunc: { 2: { enums: [0, 1] } },
      blendFuncSeparate: { 4: { enums: [0, 1, 2, 3] } },
      blendEquation: { 1: { enums: [0] } },
      blendEquationSeparate: { 2: { enums: [0, 1] } },
      stencilFunc: { 3: { enums: [0], numbers: [1, 2] } },
      stencilFuncSeparate: { 4: { enums: [0, 1], numberS: [2, 3] } },
      stencilMask: { 1: { numbers: [0] } },
      stencilMaskSeparate: { 2: { enums: [0], numbers: [1] } },
      stencilOp: { 3: { enums: [0, 1, 2] } },
      stencilOpSeparate: { 4: { enums: [0, 1, 2, 3] } },
      // Culling
      cullFace: { 1: { enums: [0] } },
      frontFace: { 1: { enums: [0] } },
      // ANGLE_instanced_arrays extension
      drawArraysInstancedANGLE: { 4: { enums: [0], numbers: [1, 2, 3] } },
      drawElementsInstancedANGLE: { 5: { enums: [0, 2], numbers: [1, 3, 4] } },
      // EXT_blend_minmax extension
      blendEquationEXT: { 1: { enums: [0] } },
      // Multiple Render Targets
      drawBuffersWebGL: { 1: { enums: { 0: c }, arrays: [0] } },
      // WEBGL_draw_buffers
      drawBuffers: { 1: { enums: { 0: c }, arrays: [0] } },
      // WebGL2
      clearBufferfv: {
        3: { enums: [0], numbers: [1], arrays: [2] },
        // WebGL2
        4: { enums: [0], numbers: [1, 3], arrays: [2] }
        // WebGL2
      },
      clearBufferiv: {
        3: { enums: [0], numbers: [1], arrays: [2] },
        // WebGL2
        4: { enums: [0], numbers: [1, 3], arrays: [2] }
        // WebGL2
      },
      clearBufferuiv: {
        3: { enums: [0], numbers: [1], arrays: [2] },
        // WebGL2
        4: { enums: [0], numbers: [1, 3], arrays: [2] }
        // WebGL2
      },
      clearBufferfi: { 4: { enums: [0], numbers: [1, 2, 3] } },
      // WebGL2
      // uniform value setters
      uniform1f: { 2: { numbers: [1] } },
      uniform2f: { 3: { numbers: [1, 2] } },
      uniform3f: { 4: { numbers: [1, 2, 3] } },
      uniform4f: { 5: { numbers: [1, 2, 3, 4] } },
      uniform1i: { 2: { numbers: [1] } },
      uniform2i: { 3: { numbers: [1, 2] } },
      uniform3i: { 4: { numbers: [1, 2, 3] } },
      uniform4i: { 5: { numbers: [1, 2, 3, 4] } },
      uniform1fv: {
        2: { arrays: { 1: _e(1) } },
        3: { arrays: { 1: me(1) }, numbers: [2] },
        4: { arrays: { 1: de(1) }, numbers: [2, 3] }
      },
      uniform2fv: {
        2: { arrays: { 1: _e(2) } },
        3: { arrays: { 1: me(2) }, numbers: [2] },
        4: { arrays: { 1: de(2) }, numbers: [2, 3] }
      },
      uniform3fv: {
        2: { arrays: { 1: _e(3) } },
        3: { arrays: { 1: me(3) }, numbers: [2] },
        4: { arrays: { 1: de(3) }, numbers: [2, 3] }
      },
      uniform4fv: {
        2: { arrays: { 1: _e(4) } },
        3: { arrays: { 1: me(4) }, numbers: [2] },
        4: { arrays: { 1: de(4) }, numbers: [2, 3] }
      },
      uniform1iv: {
        2: { arrays: { 1: _e(1) } },
        3: { arrays: { 1: me(1) }, numbers: [2] },
        4: { arrays: { 1: de(1) }, numbers: [2, 3] }
      },
      uniform2iv: {
        2: { arrays: { 1: _e(2) } },
        3: { arrays: { 1: me(2) }, numbers: [2] },
        4: { arrays: { 1: de(2) }, numbers: [2, 3] }
      },
      uniform3iv: {
        2: { arrays: { 1: _e(3) } },
        3: { arrays: { 1: me(3) }, numbers: [2] },
        4: { arrays: { 1: de(3) }, numbers: [2, 3] }
      },
      uniform4iv: {
        2: { arrays: { 1: _e(4) } },
        3: { arrays: { 1: me(4) }, numbers: [2] },
        4: { arrays: { 1: de(4) }, numbers: [2, 3] }
      },
      uniformMatrix2fv: {
        3: { arrays: { 2: _e(4) } },
        4: { arrays: { 2: me(4) }, numbers: [3] },
        5: { arrays: { 2: de(4) }, numbers: [3, 4] }
      },
      uniformMatrix3fv: {
        3: { arrays: { 2: _e(9) } },
        4: { arrays: { 2: me(9) }, numbers: [3] },
        5: { arrays: { 2: de(9) }, numbers: [3, 4] }
      },
      uniformMatrix4fv: {
        3: { arrays: { 2: _e(16) } },
        4: { arrays: { 2: me(16) }, numbers: [3] },
        5: { arrays: { 2: de(16) }, numbers: [3, 4] }
      },
      uniform1ui: { 2: { numbers: [1] } },
      // WebGL2
      uniform2ui: { 3: { numbers: [1, 2] } },
      // WebGL2
      uniform3ui: { 4: { numbers: [1, 2, 3] } },
      // WebGL2
      uniform4ui: { 5: { numbers: [1, 2, 3, 4] } },
      // WebGL2
      uniform1uiv: {
        // WebGL2
        2: { arrays: { 1: _e(1) } },
        3: { arrays: { 1: me(1) }, numbers: [2] },
        4: { arrays: { 1: de(1) }, numbers: [2, 3] }
      },
      uniform2uiv: {
        // WebGL2
        2: { arrays: { 1: _e(2) } },
        3: { arrays: { 1: me(2) }, numbers: [2] },
        4: { arrays: { 1: de(2) }, numbers: [2, 3] }
      },
      uniform3uiv: {
        // WebGL2
        2: { arrays: { 1: _e(3) } },
        3: { arrays: { 1: me(3) }, numbers: [2] },
        4: { arrays: { 1: de(3) }, numbers: [2, 3] }
      },
      uniform4uiv: {
        // WebGL2
        2: { arrays: { 1: _e(4) } },
        3: { arrays: { 1: me(4) }, numbers: [2] },
        4: { arrays: { 1: de(4) }, numbers: [2, 3] }
      },
      uniformMatrix3x2fv: {
        // WebGL2
        3: { arrays: { 2: _e(6) } },
        4: { arrays: { 2: me(6) }, numbers: [3] },
        5: { arrays: { 2: de(6) }, numbers: [3, 4] }
      },
      uniformMatrix4x2fv: {
        // WebGL2
        3: { arrays: { 2: _e(8) } },
        4: { arrays: { 2: me(8) }, numbers: [3] },
        5: { arrays: { 2: de(8) }, numbers: [3, 4] }
      },
      uniformMatrix2x3fv: {
        // WebGL2
        3: { arrays: { 2: _e(6) } },
        4: { arrays: { 2: me(6) }, numbers: [3] },
        5: { arrays: { 2: de(6) }, numbers: [3, 4] }
      },
      uniformMatrix4x3fv: {
        // WebGL2
        3: { arrays: { 2: _e(12) } },
        4: { arrays: { 2: me(12) }, numbers: [3] },
        5: { arrays: { 2: de(12) }, numbers: [3, 4] }
      },
      uniformMatrix2x4fv: {
        // WebGL2
        3: { arrays: { 2: _e(8) } },
        4: { arrays: { 2: me(8) }, numbers: [3] },
        5: { arrays: { 2: de(8) }, numbers: [3, 4] }
      },
      uniformMatrix3x4fv: {
        // WebGL2
        3: { arrays: { 2: _e(12) } },
        4: { arrays: { 2: me(12) }, numbers: [3] },
        5: { arrays: { 2: de(12) }, numbers: [3, 4] }
      },
      // attribute value setters
      vertexAttrib1f: { 2: { numbers: [0, 1] } },
      vertexAttrib2f: { 3: { numbers: [0, 1, 2] } },
      vertexAttrib3f: { 4: { numbers: [0, 1, 2, 3] } },
      vertexAttrib4f: { 5: { numbers: [0, 1, 2, 3, 4] } },
      vertexAttrib1fv: { 2: { numbers: [0], arrays: [1] } },
      vertexAttrib2fv: { 2: { numbers: [0], arrays: [1] } },
      vertexAttrib3fv: { 2: { numbers: [0], arrays: [1] } },
      vertexAttrib4fv: { 2: { numbers: [0], arrays: [1] } },
      vertexAttribI4i: { 5: { numbers: [0, 1, 2, 3, 4] } },
      // WebGL2
      vertexAttribI4iv: { 2: { numbers: [0], arrays: [1] } },
      // WebGL2
      vertexAttribI4ui: { 5: { numbers: [0, 1, 2, 3, 4] } },
      // WebGL2
      vertexAttribI4uiv: { 2: { numbers: [0], arrays: [1] } },
      // WebGL2
      // QueryObjects
      beginQuery: { 2: { enums: [0] } },
      // WebGL2
      endQuery: { 1: { enums: [0] } },
      // WebGL2
      getQuery: { 2: { enums: [0, 1] } },
      // WebGL2
      getQueryParameter: { 2: { enums: [1] } },
      // WebGL2
      //  Sampler Objects
      samplerParameteri: { 3: { enums: [1] } },
      // WebGL2
      samplerParameterf: { 3: { enums: [1] } },
      // WebGL2
      getSamplerParameter: { 2: { enums: [1] } },
      // WebGL2
      //  Sync objects
      clientWaitSync: { 3: { enums: { 1: u(["SYNC_FLUSH_COMMANDS_BIT"]) }, numbers: [2] } },
      // WebGL2
      fenceSync: { 2: { enums: [0] } },
      // WebGL2
      getSyncParameter: { 2: { enums: [1] } },
      // WebGL2
      //  Transform Feedback
      bindTransformFeedback: { 2: { enums: [0], undef: [1] } },
      // WebGL2
      beginTransformFeedback: { 1: { enums: [0] } },
      // WebGL2
      // Uniform Buffer Objects and Transform Feedback Buffers
      bindBufferBase: { 3: { enums: [0], numbers: [1] } },
      // WebGL2
      bindBufferRange: { 5: { enums: [0], numbers: [1, 3, 4] } },
      // WebGL2
      getIndexedParameter: { 2: { enums: [0], numbers: [1] } },
      // WebGL2
      getActiveUniforms: { 3: { enums: [2] }, arrays: [1] },
      // WebGL2
      getActiveUniformBlockParameter: { 3: { enums: [2], numbers: [1] } },
      // WebGL2
      getActiveUniformBlockName: { 2: { numbers: [1] } },
      // WebGL2
      transformFeedbackVaryings: { 3: { enums: [2] } },
      // WebGL2
      uniformBlockBinding: { 3: { numbers: [1, 2] } }
      // WebGL2
    };
    for (const [a, l] of Object.entries(we)) {
      for (const f of Object.values(l))
        mn(f, "enums"), mn(f, "numbers"), mn(f, "arrays"), mn(f, "undef");
      /uniform(\d|Matrix)/.test(a) && (l.errorHelper = Vu);
    }
    const P = {}, M = {};
    function w(a) {
      const l = he.get(a);
      l && l.forEach((f) => ae.delete(f)), he.set(a, /* @__PURE__ */ new Set()), Te.delete(a), Ae.delete(a), be.delete(a);
    }
    function R() {
      for (const { ctx: a, origFuncs: l } of Object.values(O))
        Object.assign(a, l), Vn.delete(a);
      D.apis.gman_debug_helper._checksRemoved = !0;
      for (const a of [...Object.keys(D)])
        delete D[a];
    }
    function B(a, l, f) {
      const { vertCount: d, instances: p } = Or(l, f);
      d === 0 && console.warn(pn(a, l, f, `count for ${l} is 0!`)), p === 0 && console.warn(pn(a, l, f, `instanceCount for ${l} is 0!`)), --N.maxDrawCalls, N.maxDrawCalls === 0 && R();
    }
    function X() {
    }
    function $(a) {
      return function(l, f, d, p) {
        if (N.makeDefaultTags) {
          const b = (gt[a] || 0) + 1;
          gt[a] = b, Qe.set(p, `*UNTAGGED:${a}${b}*`);
        }
      };
    }
    function ne(a) {
      const l = Da(new Error().stack), f = l ? `${l.url}:${l.lineNo}: ${a}` : a;
      if (N.throwOnError)
        throw new Error(f);
      console.error(f);
    }
    function J(a, l, f) {
      a ? ne(f) : l && console.warn(f);
    }
    function q(a) {
      return typeof a == "number";
    }
    const ve = 34229;
    function le() {
      const a = U;
      return typeof WebGL2RenderingContext < "u" && a instanceof WebGL2RenderingContext || O.oes_vertex_array_object ? a.getParameter(ve) : null;
    }
    function De(a, l, f) {
      if (!N.failUnsetUniforms)
        return;
      const d = Te.get(K.currentProgram);
      if (d) {
        const p = [];
        for (const [b, { index: g, unset: S }] of d)
          S.has(g) && p.push(b);
        re(a, l, f, `uniforms "${p.join('", "')}" have not been set
See docs at https://github.com/greggman/webgl-lint/ for how to turn off this check using "failUnsetUniforms": false`);
      }
    }
    function Se(a, l, f) {
      return l > 1 || f > 1 ? `${a}[${f}]` : a;
    }
    function lt(a, l, f) {
      if (!N.failUnrenderableTextures)
        return;
      const d = be.get(K.currentProgram), p = fe.numTextureUnits;
      for (const { type: b, values: g, name: S } of d) {
        const F = _a(b);
        for (let C = 0; C < g.length; ++C) {
          const z = g[C];
          if (z >= p) {
            re(a, l, f, `uniform ${Dt(b).name} ${Se(S, g.length, C)} is set to ${z} which is out of range. There are only ${p} texture units`);
            return;
          }
          const te = fe.getTextureUnitUnrenderableReason(b, z, F, We);
          if (te) {
            const oe = fe.getTextureForTextureUnit(z, F);
            re(
              a,
              l,
              f,
              oe ? `texture ${We(oe)} on texture unit ${z} referenced by uniform ${Yr(b)} ${Se(S, g.length, C)} is not renderable: ${te}` : `no texture on texture unit ${z} referenced by uniform ${Se(S, g.length, C)}`
            );
            return;
          }
        }
      }
    }
    function Ze(a, l, f) {
      const d = be.get(K.currentProgram), p = /* @__PURE__ */ new Map();
      for (const { type: b, values: g, name: S } of d) {
        const F = g[0], C = p.get(F);
        if (!C)
          p.set(F, b);
        else if (C !== b) {
          re(a, l, f, `Two textures of different types can't use the same sampler location. uniform ${Dt(b).name} ${Se(S, g.length, 0)} is not ${Dt(C).name}`);
          return;
        }
      }
    }
    function xe(a, l, f) {
      if (!K.currentProgram) {
        re(a, l, f, "no current program");
        return;
      }
      De(a, l, f), lt(a, l, f), Ze(a, l, f);
    }
    function Fe(a, l, f) {
      const [d, p, b, g = 0, S = 0] = f, F = U.getBufferParameter(d, a.BUFFER_SIZE), C = b instanceof DataView || b instanceof ArrayBuffer, z = S || (C ? b.byteLength - g : b.length - g);
      if (F < p + z) {
        const te = Br(d), oe = U.getParameter(te);
        re(
          a,
          l,
          f,
          F === 0 ? `buffer ${We(oe)} has 0 size. You need to call bufferData before calling bufferSubData.` : `buffer ${We(oe)} buffer is too small for data [bufferSize:${F} dstByteOffset(${p}) + copyLength(${z}) = ${p + z}]`
        );
      }
    }
    const qe = {
      bufferSubData: Fe,
      drawArrays: xe,
      drawElements: xe,
      drawArraysInstanced: xe,
      drawElementsInstanced: xe,
      drawArraysInstancedANGLE: xe,
      drawElementsInstancedANGLE: xe,
      drawRangeElements: xe
    };
    function Xe(a, l) {
      if (!a) {
        J(N.failUndefinedUniforms, N.warnUndefinedUniforms, `attempt to set non-existent uniform on ${We(K.currentProgram)}
See docs at https://github.com/greggman/webgl-lint/ for how to turn off this check using "warnUndefinedUniforms: false"`);
        return;
      }
      const f = Te.get(K.currentProgram);
      if (!f)
        return;
      const d = ae.get(a), p = f.get(d);
      if (p) {
        for (let b = 0; b < l; ++b)
          p.unset.delete(p.index + b);
        if (!p.unset.size) {
          for (const [b] of p.altNames)
            f.delete(b);
          f.size || Te.delete(K.currentProgram);
        }
      }
    }
    function ce(a) {
      return function(l, f, d) {
        const [p, b, g = 0, S = 0] = d, F = S || b.length - g;
        Xe(p, F / a | 0);
      };
    }
    function At(a) {
      return G.has(a);
    }
    function dt(a) {
      return At(ae.get(a));
    }
    function Ye(a, l) {
      const [f, d] = l;
      return e(a) && a.getUniformIndices(f, [d])[0] !== a.INVALID_INDEX;
    }
    function it(a) {
      return function(l, f, d) {
        const [p, b, g, S = 0, F = 0] = d, z = (F || g.length - S) / a | 0;
        if (N.failZeroMatrixUniforms && !dt(p))
          for (let te = 0; te < z; ++te) {
            let oe = !0;
            const mt = S + a * te;
            for (let Ne = 0; Ne < a; ++Ne)
              if (g[mt + Ne]) {
                oe = !1;
                break;
              }
            if (oe) {
              re(l, f, [p, b, ...d], `matrix is all zeros
See docs at https://github.com/greggman/webgl-lint/ for how to turn off this check using "failZeroMatrixUniforms": false`);
              return;
            }
          }
        Xe(p, z);
      };
    }
    function Hu(a) {
      const l = ce(a);
      return function(f, d, p) {
        l(f, d, p);
        const [b, g] = p;
        Uo(b, g);
      };
    }
    function $e(a, l, f) {
      const [d] = f;
      Xe(d, 1);
    }
    function Xu(a, l, f) {
      $e(a, l, f);
      const [d, p] = f;
      Uo(d, [p]);
    }
    function Uo(a, l) {
      const f = ae.get(a), d = Ae.get(K.currentProgram), { index: p, type: b, values: g } = d.get(f);
      if (!Zt(b))
        return;
      const S = Math.min(l.length, g.length - p);
      for (let F = 0; F < S; ++F)
        g[F] = l[F];
    }
    function et(a, l, f) {
      const [d] = f;
      Qe.delete(d);
    }
    const Yu = /ERROR:\s*\d+:(\d+)/gi;
    function Mo(a, l = "") {
      const f = [...l.matchAll(Yu)], d = new Map(f.map((p, b) => {
        const g = parseInt(p[1]), S = f[b + 1], F = S ? S.index : l.length, C = l.substring(p.index, F);
        return [g - 1, C];
      }));
      return a.split(`
`).map((p, b) => {
        const g = d.get(b);
        return `${b + 1}: ${p}${g ? `

^^^ ${g}` : ""}`;
      }).join(`
`);
    }
    const Gn = {
      enable(a, l, f) {
        const [d] = f;
        K.enabled[d] ? ++ue.enableDisable : K.enabled[d] = !0;
      },
      disable(a, l, f) {
        const [d] = f;
        K.enabled[d] ? K.enabled[d] = !1 : ++ue.enableDisable;
      },
      bindBuffer(a, l, f) {
        const [d, p] = f;
        switch (d) {
          case a.ELEMENT_ARRAY_BUFFER:
            break;
          default:
            at(K.buffers[d], p) ? ++ue.bindBuffer : K.buffers[d] = st(p);
        }
      },
      bindFramebuffer(a, l, f) {
        const [d, p] = f;
        switch (d) {
          case a.READ_FRAMEBUFFER:
            at(K.currentReadFramebuffer, p) ? ++ue.bindFramebuffer : K.currentReadFramebuffer = st(p);
            break;
          case a.DRAW_FRAMEBUFFER:
            at(K.currentDrawFramebuffer, p) ? ++ue.bindFramebuffer : K.currentDrawFramebuffer = st(p);
            break;
          case a.FRAMEBUFFER:
            at(K.currentDrawFramebuffer, p) && at(K.currentDrawFramebuffer, p) ? ++ue.bindFramebuffer : (K.currentDrawFramebuffer = st(p), K.currentReadFramebuffer = st(p));
        }
      },
      bindRenderbuffer(a, l, f) {
        const [, d] = f;
        at(K.currentRenderbuffer, d) ? ++ue.bindRenderbuffer : K.currentRenderbuffer = st(d);
      },
      // WebGL1
      //   void bufferData(GLenum target, GLsizeiptr size, GLenum usage);
      //   void bufferData(GLenum target, [AllowShared] BufferSource? srcData, GLenum usage);
      // WebGL2:
      //   void bufferData(GLenum target, [AllowShared] ArrayBufferView srcData, GLenum usage, GLuint srcOffset,
      //                   optional GLuint length = 0);
      bufferData(a, l, f) {
        const [
          d,
          p,
          /* usage */
          ,
          b = 0,
          g = 0
        ] = f;
        if (d !== a.ELEMENT_ARRAY_BUFFER)
          return;
        const S = U.getParameter(a.ELEMENT_ARRAY_BUFFER_BINDING);
        if (q(p))
          L.set(S, new ArrayBuffer(p));
        else {
          const F = p instanceof DataView, C = g || (F ? p.byteLength - b : p.length - b), z = F ? 1 : p.BYTES_PER_ELEMENT, te = C * z, oe = p.buffer ? p.buffer : p, Ne = (p.byteOffset || 0) + b * z;
          L.set(S, oe.slice(Ne, Ne + te));
        }
      },
      // WebGL1
      //   void bufferSubData(GLenum target, GLintptr dstByteOffset, [AllowShared] BufferSource srcData);
      // WebGL2
      //   void bufferSubData(GLenum target, GLintptr dstByteOffset, [AllowShared] ArrayBufferView srcData,
      //                      GLuint srcOffset, optional GLuint length = 0);
      bufferSubData(a, l, f) {
        const [d, p, b, g = 0, S = 0] = f;
        if (d !== a.ELEMENT_ARRAY_BUFFER)
          return;
        const F = U.getParameter(a.ELEMENT_ARRAY_BUFFER_BINDING), C = L.get(F), z = new Uint8Array(C), te = b instanceof DataView, oe = S || (te ? b.byteLength - g : b.length - g), mt = te ? 1 : b.BYTES_PER_ELEMENT, Ne = oe * mt, Lt = b.buffer ? b.buffer : b, kt = (b.byteOffset || 0) + g * mt, _t = new Uint8Array(Lt, kt, Ne);
        z.set(_t, p);
      },
      compileShader(a, l, f) {
        if (!N.failBadShadersAndPrograms)
          return;
        const [d] = f;
        if (!U.getShaderParameter(d, a.COMPILE_STATUS)) {
          const b = U.getShaderInfoLog(d), g = Mo(U.getShaderSource(d), b), S = U.getShaderParameter(d, a.SHADER_TYPE), F = `failed to compile ${A(S)}: ${b}
------[ shader source ]------
${g}`;
          re(a, l, f, F);
        }
      },
      createBuffer: $("Buffer"),
      createFramebuffer: $("Framebuffer"),
      createProgram: $("Program"),
      createQuery: $("Query"),
      createRenderbuffer: $("Renderbuffer"),
      createShader: $("Shader"),
      createTexture: $("Texture"),
      createTransformFeedback: $("TransformFeedback"),
      createSampler: $("Sampler"),
      createVertexArray: $("VertexArray"),
      createVertexArrayOES: $("VertexArray"),
      drawArrays: B,
      drawElements: B,
      drawArraysInstanced: B,
      drawElementsInstanced: B,
      drawArraysInstancedANGLE: B,
      drawElementsInstancedANGLE: B,
      drawRangeElements: B,
      fenceSync: $("Sync"),
      uniform1f: $e,
      uniform2f: $e,
      uniform3f: $e,
      uniform4f: $e,
      uniform1i: Xu,
      uniform2i: $e,
      uniform3i: $e,
      uniform4i: $e,
      uniform1fv: ce(1),
      uniform2fv: ce(2),
      uniform3fv: ce(3),
      uniform4fv: ce(4),
      uniform1iv: Hu(1),
      uniform2iv: ce(2),
      uniform3iv: ce(3),
      uniform4iv: ce(4),
      uniformMatrix2fv: it(4),
      uniformMatrix3fv: it(9),
      uniformMatrix4fv: it(16),
      uniform1ui: $e,
      uniform2ui: $e,
      uniform3ui: $e,
      uniform4ui: $e,
      uniform1uiv: ce(1),
      uniform2uiv: ce(2),
      uniform3uiv: ce(3),
      uniform4uiv: ce(4),
      uniformMatrix3x2fv: it(6),
      uniformMatrix4x2fv: it(8),
      uniformMatrix2x3fv: it(6),
      uniformMatrix4x3fv: it(12),
      uniformMatrix2x4fv: it(8),
      uniformMatrix3x4fv: it(12),
      getSupportedExtensions(a, l, f, d) {
        d.push("GMAN_debug_helper");
      },
      getUniformLocation(a, l, f, d) {
        const [p, b] = f;
        d ? (ae.set(d, b), he.get(p).add(d)) : !At(b) && !Ye(a, f) && Zu(
          a,
          l,
          f,
          `uniform '${b}' does not exist in ${We(p)}`,
          N.failUndefinedUniforms,
          N.warnUndefinedUniforms
        );
      },
      linkProgram(a, l, f) {
        const [d] = f;
        if (U.getProgramParameter(d, a.LINK_STATUS)) {
          w(d);
          const b = /* @__PURE__ */ new Map(), g = /* @__PURE__ */ new Map(), S = [], F = U.getProgramParameter(d, a.ACTIVE_UNIFORMS);
          for (let C = 0; C < F; ++C) {
            const { name: z, type: te, size: oe } = s.getActiveUniform(d, C);
            if (t(z) || !U.getUniformLocation(d, z))
              continue;
            const Ne = /* @__PURE__ */ new Map([[z, 0]]), Lt = z.endsWith("[0]");
            let It = z;
            if (Lt && (It = z.substr(0, z.length - 3), Ne.set(It, 0)), oe > 1)
              for (let Ie = 0; Ie < oe; ++Ie)
                Ne.set(`${It}[${Ie}]`, Ie);
            const kt = (!Zt(te) || N.failUnsetSamplerUniforms) && !G.has(z), _t = Zt(te) ? new Array(oe).fill(0) : void 0;
            _t && S.push({ type: te, values: _t, name: It });
            const Yn = new Set(rc(0, oe));
            for (const [Ie, ko] of Ne)
              kt && b.set(Ie, {
                index: ko,
                unset: Yn,
                altNames: Ne
              }), g.set(Ie, {
                index: ko,
                type: te,
                size: oe,
                ..._t && { values: _t }
              });
          }
          be.set(d, S), Ae.set(d, g), b.size && Te.set(d, b);
        } else if (N.failBadShadersAndPrograms) {
          const g = U.getAttachedShaders(d).map((C) => {
            const z = Mo(U.getShaderSource(C)), te = U.getShaderParameter(C, a.SHADER_TYPE);
            return `-------[ ${A(te)} ${We(C)} ]-------
${z}`;
          }).join(`
`), F = `failed to link program: ${U.getProgramInfoLog(d)}
${g}`;
          re(a, l, f, F);
        }
      },
      useProgram(a, l, f) {
        const [d] = f;
        K.currentProgram === d ? ++ue.useProgram : K.currentProgram = d;
      },
      deleteProgram(a, l, f) {
        const [d] = f;
        K.currentProgram === d && (K.currentProgram = void 0), w(d);
      },
      deleteBuffer(a, l, f) {
        const [d] = f;
        L.delete(d);
      },
      deleteFramebuffer: et,
      deleteRenderbuffer: et,
      deleteTexture: et,
      deleteShader: et,
      deleteQuery: et,
      deleteSampler: et,
      deleteSync: et,
      deleteTransformFeedback: et,
      deleteVertexArray: et,
      deleteVertexArrayOES: et
    };
    [fe, ot].forEach((a) => {
      Object.entries(a.postChecks).forEach(([l, f]) => {
        const d = Gn[l] || X;
        Gn[l] = function(...p) {
          d(...p), N.failUnrenderableTextures && f(...p);
        };
      });
    });
    function We(a) {
      const l = Qe.get(a) || "*unnamed*";
      return `${a.constructor.name}(${r(l)})`;
    }
    function Wu(a) {
      return L.get(a);
    }
    function ju(a, l, f, d, p) {
      const b = Qe.get(p);
      if (b)
        return `${p.constructor.name}("${b}")`;
      if (p instanceof WebGLUniformLocation)
        return `WebGLUniformLocation("${ae.get(p)}")`;
      const g = we[l];
      if (g !== void 0) {
        const S = g[f];
        if (S !== void 0) {
          const F = S.enums;
          if (F) {
            const C = F[d];
            if (C !== void 0) {
              if (typeof C == "function")
                return C(a, p);
              if (!l.startsWith("bind") && d === 0) {
                const z = Br(p);
                if (z) {
                  const te = U.getParameter(z);
                  if (te)
                    return `${A(p)}{${We(te)}}`;
                }
              }
              return A(p);
            }
          }
        }
      }
      return p === null ? "null" : p === void 0 ? "undefined" : Array.isArray(p) || n(p) ? p.length <= 32 ? `[${Array.from(p.slice(0, 32)).join(", ")}]` : `${p.constructor.name}(${p.length !== void 0 ? p.length : p.byteLength})` : p.toString();
    }
    function Ot(a, l, f, d, p, b, g) {
      if (!n(d)) {
        re(a, l, f, `argument ${p} must be a TypedArray`);
        return;
      }
      if (!o(d))
        return;
      const S = b, F = b + g;
      for (let C = S; C < F; ++C)
        if (d[C] === void 0) {
          re(a, l, f, `element ${C} of argument ${p} is undefined`);
          return;
        } else if (isNaN(d[C])) {
          re(a, l, f, `element ${C} of argument ${p} is NaN`);
          return;
        }
    }
    function Hn(a, l, f, d, p) {
      const b = f[f.length - 1], g = d.length - b;
      Ot(a, l, f, d, p, b, g);
    }
    function Ku(a, l, f, d, p) {
      if (n(d) && o(d)) {
        const g = d.length - 0;
        Ot(a, l, f, d, p, 0, g);
      } else
        Array.isArray(d) && re(a, l, f, `argument ${p} is not an ArrayBufferView or ArrayBuffer`);
    }
    function Oo(a, l, f, d, p) {
      if (n(d) && o(d)) {
        const b = f[f.length - 1], g = d.length - b;
        Ot(a, l, f, d, p, b, g);
      } else
        Array.isArray(d) && re(a, l, f, `argument ${p} is not an ArrayBufferView or ArrayBuffer`);
    }
    function Lo(a, l, f, d, p) {
      if (n(d) && o(d)) {
        const b = f[f.length - 2], g = f[f.length - 1];
        Ot(a, l, f, d, p, b, g);
      } else
        Array.isArray(d) && re(a, l, f, `argument ${p} is not an ArrayBufferView or ArrayBuffer`);
    }
    function Ju(a, l, f, d, p) {
      if (Array.isArray(d) || n(d)) {
        const b = f[f.length - 1], g = d.length - b;
        Ot(a, l, f, d, p, b, g);
      }
    }
    function Xn(a, l, f, d, p, b, g, S) {
      const F = f[0];
      if (!F)
        return;
      const C = Ae.get(K.currentProgram);
      if (!C)
        return;
      const z = ae.get(F), { type: te, size: oe, index: mt } = C.get(z), Ne = Dt(te).size;
      S !== Ne && re(a, l, f, `uniform "${z}" is ${Dt(te).name} which is wrong for ${l}`);
      const Lt = oe - mt, kt = Math.min(g / S | 0, Lt) * S, _t = b, Yn = b + kt;
      for (let Ie = _t; Ie < Yn; ++Ie)
        if (d[Ie] === void 0) {
          re(a, l, f, `element ${Ie} of argument ${p} is undefined`);
          return;
        } else if (qu(d[Ie])) {
          re(a, l, f, `element ${Ie} of argument ${p} is an array. WebGL expects flat arrays`);
          return;
        } else if (isNaN(d[Ie])) {
          re(a, l, f, `element ${Ie} of argument ${p} is NaN`);
          return;
        }
    }
    function de(a) {
      return function(l, f, d, p, b) {
        const g = d[d.length - 2], S = d[d.length - 1];
        Xn(l, f, d, p, b, g, S, a);
      };
    }
    function me(a) {
      return function(l, f, d, p, b) {
        const g = d[d.length - 1], S = p.length - g;
        Xn(l, f, d, p, b, g, S, a);
      };
    }
    function _e(a) {
      return function(l, f, d, p, b) {
        const S = p.length;
        Xn(l, f, d, p, b, 0, S, a);
      };
    }
    function Qu(a, l, f) {
      const d = f.length;
      return f.map(function(b, g) {
        let S = ju(a, l, d, g, b);
        return S.length > 200 && (S = S.substring(0, 200) + "..."), S;
      }).join(", ");
    }
    function pn(a, l, f, d) {
      const p = U, b = [d], g = we[l];
      if (g && g.errorHelper && b.push(g.errorHelper(a, l, f, D)), l.includes("draw")) {
        const F = p.getParameter(p.CURRENT_PROGRAM);
        F ? b.push(`with ${We(F)} as current program`) : b.push("no shader program in use!");
      }
      if (l.includes("vertexAttrib") || Dn(l)) {
        const F = le(), C = Qe.get(F), z = `WebGLVertexArrayObject(${r(C || "*unnamed*")})`;
        b.push(`with ${F ? z : "the default vertex array"} bound`);
      }
      const S = Qu(a, l, f);
      return `error in ${l}(${S}): ${b.join(`
`)}`;
    }
    function Zu(a, l, f, d, p, b) {
      J(p, b, pn(a, l, f, d));
    }
    function re(a, l, f, d) {
      ne(pn(a, l, f, d));
    }
    const qu = (a) => Array.isArray(a) || n(a);
    function ec(a, l, f) {
      const d = we[l];
      if (d) {
        const p = d[f.length];
        if (p) {
          const { numbers: b = {}, arrays: g = {}, undef: S = {} } = p;
          for (let F = 0; F < f.length; ++F) {
            const C = f[F];
            if (C === void 0 && !S[F]) {
              re(a, l, f, `argument ${F} is undefined`);
              return;
            }
            if (b[F] !== void 0) {
              if (b[F] >= 0) {
                if (typeof C != "number" && !(C instanceof Number) && C !== !1 && C !== !0 || isNaN(C)) {
                  re(a, l, f, `argument ${F} is not a number`);
                  return;
                }
              } else if (!(C instanceof Object) && isNaN(C)) {
                re(a, l, f, `argument ${F} is NaN`);
                return;
              }
            }
            const z = g[F];
            if (z !== void 0) {
              const te = Array.isArray(C) || n(C);
              if (z >= 0 && !te) {
                re(a, l, f, `argument ${F} is not an array or typedarray`);
                return;
              }
              if (te && o(C)) {
                if (typeof z == "function")
                  z(a, l, f, C, F);
                else
                  for (let oe = 0; oe < C.length; ++oe)
                    if (C[oe] === void 0) {
                      re(a, l, f, `element ${oe} of argument ${F} is undefined`);
                      return;
                    } else if (isNaN(C[oe])) {
                      re(a, l, f, `element ${oe} of argument ${F} is NaN`);
                      return;
                    }
              }
            }
          }
        } else {
          re(a, l, f, `no version of function '${l}' takes ${f.length} arguments`);
          return;
        }
      }
    }
    const tc = {
      getExtension(a, l) {
        const f = a[l];
        a[l] = function(...d) {
          const p = d[0].toLowerCase(), b = O[p];
          if (b)
            return b.ctx;
          const g = f.call(a, ...d);
          return g && Po(g, p, { ...E, origGLErrorFn: v }), g;
        };
      }
    };
    function nc(a, l) {
      const f = a[l], d = qe[l] || X, p = Gn[l] || X;
      a[l] = function(...g) {
        if (d(a, l, g), ec(a, l, g), K.currentProgram && Dn(l)) {
          const z = ia(U, l, g, We, Wu);
          z.length && re(a, l, g, z.join(`
`));
        }
        const S = f.call(a, ...g), F = U, C = v.call(F);
        if (C !== 0) {
          P[C] = !0;
          const z = [A(C)];
          Dn(l) && K.currentProgram && z.push(...Ba(F, We)), re(a, l, g, z.join(`
`));
        } else
          p(a, l, g, S);
        return S;
      };
      const b = tc[l];
      b && b(a, l, v);
    }
    function rc(a, l) {
      const f = [];
      for (let d = a; d < l; ++d)
        f.push(d);
      return f;
    }
    for (const a in s)
      typeof s[a] == "function" && (M[a] = s[a], nc(s, a));
    s.getError && (s.getError = function() {
      for (const a of Object.keys(P))
        if (P[a])
          return P[a] = !1, a;
      return s.NO_ERROR;
    }), O[h.toLowerCase()] = { ctx: s, origFuncs: M };
  }
  console.log("webgl-lint running");
  function Do(s) {
    const h = s.prototype.getContext;
    s.prototype.getContext = function(E, ...v) {
      const I = h.call(this, E, ...v);
      if (I && I.bindTexture) {
        Po(I, E, {
          maxDrawCalls: 1e3,
          throwOnError: !0,
          failBadShadersAndPrograms: !0,
          failUnsetUniforms: !0,
          failUnsetSamplerUniforms: !1,
          failZeroMatrixUniforms: !0,
          failUnrenderableTextures: !0,
          failUndefinedUniforms: !1,
          warnUndefinedUniforms: !0,
          makeDefaultTags: !0,
          ignoreUniforms: []
        });
        const O = I.getExtension("GMAN_debug_helper");
        document.querySelectorAll("[data-gman-debug-helper]").forEach((U) => {
          const L = U.dataset.gmanDebugHelper;
          let N;
          try {
            N = JSON.parse(L);
          } catch (G) {
            throw G.message += `
${L}
failed to parse data-gman-debug-helper as JSON in: ${U.outerHTML}`, G;
          }
          N && O.setConfiguration(N);
        });
      }
      return I;
    };
  }
  typeof HTMLCanvasElement < "u" && Do(HTMLCanvasElement), typeof OffscreenCanvas < "u" && Do(OffscreenCanvas);
});
/* @license twgl.js 5.5.4 Copyright (c) 2015, Gregg Tavares All Rights Reserved.
Available via the MIT license.
see: http://github.com/greggman/twgl.js for details */
const ar = 5120, Yt = 5121, ur = 5122, cr = 5123, fr = 5124, lr = 5125, dr = 5126, oc = 32819, ic = 32820, sc = 33635, ac = 5131, uc = 33640, cc = 35899, fc = 35902, lc = 36269, dc = 34042, ci = {};
{
  const t = ci;
  t[ar] = Int8Array, t[Yt] = Uint8Array, t[ur] = Int16Array, t[cr] = Uint16Array, t[fr] = Int32Array, t[lr] = Uint32Array, t[dr] = Float32Array, t[oc] = Uint16Array, t[ic] = Uint16Array, t[sc] = Uint16Array, t[ac] = Uint16Array, t[uc] = Uint32Array, t[cc] = Uint32Array, t[fc] = Uint32Array, t[lc] = Uint32Array, t[dc] = Uint32Array;
}
function fi(t) {
  if (t instanceof Int8Array)
    return ar;
  if (t instanceof Uint8Array || t instanceof Uint8ClampedArray)
    return Yt;
  if (t instanceof Int16Array)
    return ur;
  if (t instanceof Uint16Array)
    return cr;
  if (t instanceof Int32Array)
    return fr;
  if (t instanceof Uint32Array)
    return lr;
  if (t instanceof Float32Array)
    return dr;
  throw new Error("unsupported typed array type");
}
function li(t) {
  if (t === Int8Array)
    return ar;
  if (t === Uint8Array || t === Uint8ClampedArray)
    return Yt;
  if (t === Int16Array)
    return ur;
  if (t === Uint16Array)
    return cr;
  if (t === Int32Array)
    return fr;
  if (t === Uint32Array)
    return lr;
  if (t === Float32Array)
    return dr;
  throw new Error("unsupported typed array type");
}
function mc(t) {
  const e = ci[t];
  if (!e)
    throw new Error("unknown gl type");
  return e;
}
const Zn = typeof SharedArrayBuffer < "u" ? function(e) {
  return e && e.buffer && (e.buffer instanceof ArrayBuffer || e.buffer instanceof SharedArrayBuffer);
} : function(e) {
  return e && e.buffer && e.buffer instanceof ArrayBuffer;
};
function _c(...t) {
  console.error(...t);
}
const $o = /* @__PURE__ */ new Map();
function di(t, e) {
  if (!t || typeof t != "object")
    return !1;
  let n = $o.get(e);
  n || (n = /* @__PURE__ */ new WeakMap(), $o.set(e, n));
  let o = n.get(t);
  if (o === void 0) {
    const r = Object.prototype.toString.call(t);
    o = r.substring(8, r.length - 1) === e, n.set(t, o);
  }
  return o;
}
function pc(t, e) {
  return typeof WebGLBuffer < "u" && di(e, "WebGLBuffer");
}
function mi(t, e) {
  return typeof WebGLTexture < "u" && di(e, "WebGLTexture");
}
const _i = 35044, nt = 34962, hc = 34963, bc = 34660, xc = 5120, yc = 5121, Ec = 5122, gc = 5123, Ac = 5124, Tc = 5125, pi = 5126, hi = {
  attribPrefix: ""
};
function bi(t, e, n, o, r) {
  t.bindBuffer(e, n), t.bufferData(e, o, r || _i);
}
function xi(t, e, n, o) {
  if (pc(t, e))
    return e;
  n = n || nt;
  const r = t.createBuffer();
  return bi(t, n, r, e, o), r;
}
function yi(t) {
  return t === "indices";
}
function vc(t) {
  return t === Int8Array || t === Uint8Array;
}
function Sc(t) {
  return t.length ? t : t.data;
}
const Rc = /coord|texture/i, wc = /color|colour/i;
function Fc(t, e) {
  let n;
  if (Rc.test(t) ? n = 2 : wc.test(t) ? n = 4 : n = 3, e % n > 0)
    throw new Error(`Can not guess numComponents for attribute '${t}'. Tried ${n} but ${e} values is not evenly divisible by ${n}. You should specify it.`);
  return n;
}
function Ic(t, e, n) {
  return t.numComponents || t.size || Fc(e, n || Sc(t).length);
}
function mr(t, e) {
  if (Zn(t))
    return t;
  if (Zn(t.data))
    return t.data;
  Array.isArray(t) && (t = {
    data: t
  });
  let n = t.type ? _r(t.type) : void 0;
  return n || (yi(e) ? n = Uint16Array : n = Float32Array), new n(t.data);
}
function Cc(t) {
  return typeof t == "number" ? t : t ? li(t) : pi;
}
function _r(t) {
  return typeof t == "number" ? mc(t) : t || Float32Array;
}
function Nc(t, e) {
  return {
    buffer: e.buffer,
    numValues: 2 * 3 * 4,
    // safely divided by 2, 3, 4
    type: Cc(e.type),
    arrayType: _r(e.type)
  };
}
function Bc(t, e) {
  const n = e.data || e, o = _r(e.type), r = n * o.BYTES_PER_ELEMENT, i = t.createBuffer();
  return t.bindBuffer(nt, i), t.bufferData(nt, r, e.drawType || _i), {
    buffer: i,
    numValues: n,
    type: li(o),
    arrayType: o
  };
}
function Pc(t, e, n) {
  const o = mr(e, n);
  return {
    arrayType: o.constructor,
    buffer: xi(t, o, void 0, e.drawType),
    type: fi(o),
    numValues: 0
  };
}
function Dc(t, e) {
  const n = {};
  return Object.keys(e).forEach(function(o) {
    if (!yi(o)) {
      const r = e[o], i = r.attrib || r.name || r.attribName || hi.attribPrefix + o;
      if (r.value) {
        if (!Array.isArray(r.value) && !Zn(r.value))
          throw new Error("array.value is not array or typedarray");
        n[i] = {
          value: r.value
        };
      } else {
        let c;
        r.buffer && r.buffer instanceof WebGLBuffer ? c = Nc : typeof r == "number" || typeof r.data == "number" ? c = Bc : c = Pc;
        const { buffer: u, type: _, numValues: x, arrayType: A } = c(t, r, o), T = r.normalize !== void 0 ? r.normalize : vc(A), k = Ic(r, o, x);
        n[i] = {
          buffer: u,
          numComponents: k,
          type: _,
          normalize: T,
          stride: r.stride || 0,
          offset: r.offset || 0,
          divisor: r.divisor === void 0 ? void 0 : r.divisor,
          drawType: r.drawType
        };
      }
    }
  }), t.bindBuffer(nt, null), n;
}
function zo(t, e, n, o) {
  n = mr(n), o !== void 0 ? (t.bindBuffer(nt, e.buffer), t.bufferSubData(nt, o, n)) : bi(t, nt, e.buffer, n, e.drawType);
}
function Uc(t, e) {
  return e === xc || e === yc ? 1 : e === Ec || e === gc ? 2 : e === Ac || e === Tc || e === pi ? 4 : 0;
}
const Wn = ["position", "positions", "a_position"];
function Mc(t, e) {
  let n, o;
  for (o = 0; o < Wn.length && (n = Wn[o], !(n in e || (n = hi.attribPrefix + n, n in e))); ++o)
    ;
  o === Wn.length && (n = Object.keys(e)[0]);
  const r = e[n];
  if (!r.buffer)
    return 1;
  t.bindBuffer(nt, r.buffer);
  const i = t.getBufferParameter(nt, bc);
  t.bindBuffer(nt, null);
  const c = Uc(t, r.type), u = i / c, _ = r.numComponents || r.size, x = u / _;
  if (x % 1 !== 0)
    throw new Error(`numComponents ${_} not correct for length ${length}`);
  return x;
}
function jn(t, e, n) {
  const o = Dc(t, e), r = Object.assign({}, n || {});
  r.attribs = Object.assign({}, n ? n.attribs : {}, o);
  const i = e.indices;
  if (i) {
    const c = mr(i, "indices");
    r.indices = xi(t, c, hc), r.numElements = c.length, r.elementType = fi(c);
  } else r.numElements || (r.numElements = Mc(t, r.attribs));
  return r;
}
function pr(t) {
  return !!t.texStorage2D;
}
const Oc = /* @__PURE__ */ function() {
  const t = {}, e = {};
  function n(o) {
    const r = o.constructor.name;
    if (!t[r]) {
      for (const i in o)
        if (typeof o[i] == "number") {
          const c = e[o[i]];
          e[o[i]] = c ? `${c} | ${i}` : i;
        }
      t[r] = !0;
    }
  }
  return function(r, i) {
    return n(r), e[i] || (typeof i == "number" ? `0x${i.toString(16)}` : i);
  };
}(), hr = _c;
function Ei(t) {
  return typeof document < "u" && document.getElementById ? document.getElementById(t) : null;
}
const An = 33984, wn = 34962, Lc = 34963, kc = 35713, $c = 35714, zc = 35632, Vc = 35633, Gc = 35981, gi = 35718, Hc = 35721, Xc = 35971, Yc = 35382, Wc = 35396, jc = 35398, Kc = 35392, Jc = 35395, Fn = 5126, Ai = 35664, Ti = 35665, vi = 35666, br = 5124, Si = 35667, Ri = 35668, wi = 35669, Fi = 35670, Ii = 35671, Ci = 35672, Ni = 35673, Bi = 35674, Pi = 35675, Di = 35676, Qc = 35678, Zc = 35680, qc = 35679, ef = 35682, tf = 35685, nf = 35686, rf = 35687, of = 35688, sf = 35689, af = 35690, uf = 36289, cf = 36292, ff = 36293, xr = 5125, Ui = 36294, Mi = 36295, Oi = 36296, lf = 36298, df = 36299, mf = 36300, _f = 36303, pf = 36306, hf = 36307, bf = 36308, xf = 36311, In = 3553, Cn = 34067, yr = 32879, Nn = 35866, Y = {};
function Li(t, e) {
  return Y[e].bindPoint;
}
function yf(t, e) {
  return function(n) {
    t.uniform1f(e, n);
  };
}
function Ef(t, e) {
  return function(n) {
    t.uniform1fv(e, n);
  };
}
function gf(t, e) {
  return function(n) {
    t.uniform2fv(e, n);
  };
}
function Af(t, e) {
  return function(n) {
    t.uniform3fv(e, n);
  };
}
function Tf(t, e) {
  return function(n) {
    t.uniform4fv(e, n);
  };
}
function ki(t, e) {
  return function(n) {
    t.uniform1i(e, n);
  };
}
function $i(t, e) {
  return function(n) {
    t.uniform1iv(e, n);
  };
}
function zi(t, e) {
  return function(n) {
    t.uniform2iv(e, n);
  };
}
function Vi(t, e) {
  return function(n) {
    t.uniform3iv(e, n);
  };
}
function Gi(t, e) {
  return function(n) {
    t.uniform4iv(e, n);
  };
}
function vf(t, e) {
  return function(n) {
    t.uniform1ui(e, n);
  };
}
function Sf(t, e) {
  return function(n) {
    t.uniform1uiv(e, n);
  };
}
function Rf(t, e) {
  return function(n) {
    t.uniform2uiv(e, n);
  };
}
function wf(t, e) {
  return function(n) {
    t.uniform3uiv(e, n);
  };
}
function Ff(t, e) {
  return function(n) {
    t.uniform4uiv(e, n);
  };
}
function If(t, e) {
  return function(n) {
    t.uniformMatrix2fv(e, !1, n);
  };
}
function Cf(t, e) {
  return function(n) {
    t.uniformMatrix3fv(e, !1, n);
  };
}
function Nf(t, e) {
  return function(n) {
    t.uniformMatrix4fv(e, !1, n);
  };
}
function Bf(t, e) {
  return function(n) {
    t.uniformMatrix2x3fv(e, !1, n);
  };
}
function Pf(t, e) {
  return function(n) {
    t.uniformMatrix3x2fv(e, !1, n);
  };
}
function Df(t, e) {
  return function(n) {
    t.uniformMatrix2x4fv(e, !1, n);
  };
}
function Uf(t, e) {
  return function(n) {
    t.uniformMatrix4x2fv(e, !1, n);
  };
}
function Mf(t, e) {
  return function(n) {
    t.uniformMatrix3x4fv(e, !1, n);
  };
}
function Of(t, e) {
  return function(n) {
    t.uniformMatrix4x3fv(e, !1, n);
  };
}
function Be(t, e, n, o) {
  const r = Li(t, e);
  return pr(t) ? function(i) {
    let c, u;
    !i || mi(t, i) ? (c = i, u = null) : (c = i.texture, u = i.sampler), t.uniform1i(o, n), t.activeTexture(An + n), t.bindTexture(r, c), t.bindSampler(n, u);
  } : function(i) {
    t.uniform1i(o, n), t.activeTexture(An + n), t.bindTexture(r, i);
  };
}
function Pe(t, e, n, o, r) {
  const i = Li(t, e), c = new Int32Array(r);
  for (let u = 0; u < r; ++u)
    c[u] = n + u;
  return pr(t) ? function(u) {
    t.uniform1iv(o, c), u.forEach(function(_, x) {
      t.activeTexture(An + c[x]);
      let A, T;
      !_ || mi(t, _) ? (A = _, T = null) : (A = _.texture, T = _.sampler), t.bindSampler(n, T), t.bindTexture(i, A);
    });
  } : function(u) {
    t.uniform1iv(o, c), u.forEach(function(_, x) {
      t.activeTexture(An + c[x]), t.bindTexture(i, _);
    });
  };
}
Y[Fn] = { Type: Float32Array, size: 4, setter: yf, arraySetter: Ef };
Y[Ai] = { Type: Float32Array, size: 8, setter: gf, cols: 2 };
Y[Ti] = { Type: Float32Array, size: 12, setter: Af, cols: 3 };
Y[vi] = { Type: Float32Array, size: 16, setter: Tf, cols: 4 };
Y[br] = { Type: Int32Array, size: 4, setter: ki, arraySetter: $i };
Y[Si] = { Type: Int32Array, size: 8, setter: zi, cols: 2 };
Y[Ri] = { Type: Int32Array, size: 12, setter: Vi, cols: 3 };
Y[wi] = { Type: Int32Array, size: 16, setter: Gi, cols: 4 };
Y[xr] = { Type: Uint32Array, size: 4, setter: vf, arraySetter: Sf };
Y[Ui] = { Type: Uint32Array, size: 8, setter: Rf, cols: 2 };
Y[Mi] = { Type: Uint32Array, size: 12, setter: wf, cols: 3 };
Y[Oi] = { Type: Uint32Array, size: 16, setter: Ff, cols: 4 };
Y[Fi] = { Type: Uint32Array, size: 4, setter: ki, arraySetter: $i };
Y[Ii] = { Type: Uint32Array, size: 8, setter: zi, cols: 2 };
Y[Ci] = { Type: Uint32Array, size: 12, setter: Vi, cols: 3 };
Y[Ni] = { Type: Uint32Array, size: 16, setter: Gi, cols: 4 };
Y[Bi] = { Type: Float32Array, size: 32, setter: If, rows: 2, cols: 2 };
Y[Pi] = { Type: Float32Array, size: 48, setter: Cf, rows: 3, cols: 3 };
Y[Di] = { Type: Float32Array, size: 64, setter: Nf, rows: 4, cols: 4 };
Y[tf] = { Type: Float32Array, size: 32, setter: Bf, rows: 2, cols: 3 };
Y[nf] = { Type: Float32Array, size: 32, setter: Df, rows: 2, cols: 4 };
Y[rf] = { Type: Float32Array, size: 48, setter: Pf, rows: 3, cols: 2 };
Y[of] = { Type: Float32Array, size: 48, setter: Mf, rows: 3, cols: 4 };
Y[sf] = { Type: Float32Array, size: 64, setter: Uf, rows: 4, cols: 2 };
Y[af] = { Type: Float32Array, size: 64, setter: Of, rows: 4, cols: 3 };
Y[Qc] = { Type: null, size: 0, setter: Be, arraySetter: Pe, bindPoint: In };
Y[Zc] = { Type: null, size: 0, setter: Be, arraySetter: Pe, bindPoint: Cn };
Y[qc] = { Type: null, size: 0, setter: Be, arraySetter: Pe, bindPoint: yr };
Y[ef] = { Type: null, size: 0, setter: Be, arraySetter: Pe, bindPoint: In };
Y[uf] = { Type: null, size: 0, setter: Be, arraySetter: Pe, bindPoint: Nn };
Y[cf] = { Type: null, size: 0, setter: Be, arraySetter: Pe, bindPoint: Nn };
Y[ff] = { Type: null, size: 0, setter: Be, arraySetter: Pe, bindPoint: Cn };
Y[lf] = { Type: null, size: 0, setter: Be, arraySetter: Pe, bindPoint: In };
Y[df] = { Type: null, size: 0, setter: Be, arraySetter: Pe, bindPoint: yr };
Y[mf] = { Type: null, size: 0, setter: Be, arraySetter: Pe, bindPoint: Cn };
Y[_f] = { Type: null, size: 0, setter: Be, arraySetter: Pe, bindPoint: Nn };
Y[pf] = { Type: null, size: 0, setter: Be, arraySetter: Pe, bindPoint: In };
Y[hf] = { Type: null, size: 0, setter: Be, arraySetter: Pe, bindPoint: yr };
Y[bf] = { Type: null, size: 0, setter: Be, arraySetter: Pe, bindPoint: Cn };
Y[xf] = { Type: null, size: 0, setter: Be, arraySetter: Pe, bindPoint: Nn };
function Bn(t, e) {
  return function(n) {
    if (n.value)
      switch (t.disableVertexAttribArray(e), n.value.length) {
        case 4:
          t.vertexAttrib4fv(e, n.value);
          break;
        case 3:
          t.vertexAttrib3fv(e, n.value);
          break;
        case 2:
          t.vertexAttrib2fv(e, n.value);
          break;
        case 1:
          t.vertexAttrib1fv(e, n.value);
          break;
        default:
          throw new Error("the length of a float constant value must be between 1 and 4!");
      }
    else
      t.bindBuffer(wn, n.buffer), t.enableVertexAttribArray(e), t.vertexAttribPointer(
        e,
        n.numComponents || n.size,
        n.type || Fn,
        n.normalize || !1,
        n.stride || 0,
        n.offset || 0
      ), t.vertexAttribDivisor && t.vertexAttribDivisor(e, n.divisor || 0);
  };
}
function ht(t, e) {
  return function(n) {
    if (n.value)
      if (t.disableVertexAttribArray(e), n.value.length === 4)
        t.vertexAttrib4iv(e, n.value);
      else
        throw new Error("The length of an integer constant value must be 4!");
    else
      t.bindBuffer(wn, n.buffer), t.enableVertexAttribArray(e), t.vertexAttribIPointer(
        e,
        n.numComponents || n.size,
        n.type || br,
        n.stride || 0,
        n.offset || 0
      ), t.vertexAttribDivisor && t.vertexAttribDivisor(e, n.divisor || 0);
  };
}
function Pn(t, e) {
  return function(n) {
    if (n.value)
      if (t.disableVertexAttribArray(e), n.value.length === 4)
        t.vertexAttrib4uiv(e, n.value);
      else
        throw new Error("The length of an unsigned integer constant value must be 4!");
    else
      t.bindBuffer(wn, n.buffer), t.enableVertexAttribArray(e), t.vertexAttribIPointer(
        e,
        n.numComponents || n.size,
        n.type || xr,
        n.stride || 0,
        n.offset || 0
      ), t.vertexAttribDivisor && t.vertexAttribDivisor(e, n.divisor || 0);
  };
}
function Er(t, e, n) {
  const o = n.size, r = n.count;
  return function(i) {
    t.bindBuffer(wn, i.buffer);
    const c = i.size || i.numComponents || o, u = c / r, _ = i.type || Fn, A = Y[_].size * c, T = i.normalize || !1, k = i.offset || 0, j = A / r;
    for (let W = 0; W < r; ++W)
      t.enableVertexAttribArray(e + W), t.vertexAttribPointer(
        e + W,
        u,
        _,
        T,
        A,
        k + j * W
      ), t.vertexAttribDivisor && t.vertexAttribDivisor(e + W, i.divisor || 0);
  };
}
const ye = {};
ye[Fn] = { size: 4, setter: Bn };
ye[Ai] = { size: 8, setter: Bn };
ye[Ti] = { size: 12, setter: Bn };
ye[vi] = { size: 16, setter: Bn };
ye[br] = { size: 4, setter: ht };
ye[Si] = { size: 8, setter: ht };
ye[Ri] = { size: 12, setter: ht };
ye[wi] = { size: 16, setter: ht };
ye[xr] = { size: 4, setter: Pn };
ye[Ui] = { size: 8, setter: Pn };
ye[Mi] = { size: 12, setter: Pn };
ye[Oi] = { size: 16, setter: Pn };
ye[Fi] = { size: 4, setter: ht };
ye[Ii] = { size: 8, setter: ht };
ye[Ci] = { size: 12, setter: ht };
ye[Ni] = { size: 16, setter: ht };
ye[Bi] = { size: 4, setter: Er, count: 2 };
ye[Pi] = { size: 9, setter: Er, count: 3 };
ye[Di] = { size: 16, setter: Er, count: 4 };
const Lf = /ERROR:\s*\d+:(\d+)/gi;
function kf(t, e = "", n = 0) {
  const o = [...e.matchAll(Lf)], r = new Map(o.map((i, c) => {
    const u = parseInt(i[1]), _ = o[c + 1], x = _ ? _.index : e.length, A = e.substring(i.index, x);
    return [u - 1, A];
  }));
  return t.split(`
`).map((i, c) => {
    const u = r.get(c);
    return `${c + 1 + n}: ${i}${u ? `

^^^ ${u}` : ""}`;
  }).join(`
`);
}
const Vo = /^[ \t]*\n/;
function Hi(t) {
  let e = 0;
  return Vo.test(t) && (e = 1, t = t.replace(Vo, "")), { lineOffset: e, shaderSource: t };
}
function $f(t, e) {
  return t.errorCallback(e), t.callback && setTimeout(() => {
    t.callback(`${e}
${t.errors.join(`
`)}`);
  }), null;
}
function zf(t, e, n, o) {
  if (o = o || hr, !t.getShaderParameter(n, kc)) {
    const i = t.getShaderInfoLog(n), { lineOffset: c, shaderSource: u } = Hi(t.getShaderSource(n)), _ = `${kf(u, i, c)}
Error compiling ${Oc(t, e)}: ${i}`;
    return o(_), _;
  }
  return "";
}
function gr(t, e, n) {
  let o, r, i;
  if (typeof e == "function" && (n = e, e = void 0), typeof t == "function")
    n = t, t = void 0;
  else if (t && !Array.isArray(t)) {
    const x = t;
    n = x.errorCallback, t = x.attribLocations, o = x.transformFeedbackVaryings, r = x.transformFeedbackMode, i = x.callback;
  }
  const c = n || hr, u = [], _ = {
    errorCallback(x, ...A) {
      u.push(x), c(x, ...A);
    },
    transformFeedbackVaryings: o,
    transformFeedbackMode: r,
    callback: i,
    errors: u
  };
  {
    let x = {};
    Array.isArray(t) ? t.forEach(function(A, T) {
      x[A] = e ? e[T] : T;
    }) : x = t || {}, _.attribLocations = x;
  }
  return _;
}
const Vf = [
  "VERTEX_SHADER",
  "FRAGMENT_SHADER"
];
function Gf(t, e) {
  if (e.indexOf("frag") >= 0)
    return zc;
  if (e.indexOf("vert") >= 0)
    return Vc;
}
function Hf(t, e, n) {
  const o = t.getAttachedShaders(e);
  for (const r of o)
    n.has(r) && t.deleteShader(r);
  t.deleteProgram(e);
}
const Xf = (t = 0) => new Promise((e) => setTimeout(e, t));
function Yf(t, e, n) {
  const o = t.createProgram(), {
    attribLocations: r,
    transformFeedbackVaryings: i,
    transformFeedbackMode: c
  } = gr(n);
  for (let u = 0; u < e.length; ++u) {
    let _ = e[u];
    if (typeof _ == "string") {
      const x = Ei(_), A = x ? x.text : _;
      let T = t[Vf[u]];
      x && x.type && (T = Gf(t, x.type) || T), _ = t.createShader(T), t.shaderSource(_, Hi(A).shaderSource), t.compileShader(_), t.attachShader(o, _);
    }
  }
  Object.entries(r).forEach(([u, _]) => t.bindAttribLocation(o, _, u));
  {
    let u = i;
    u && (u.attribs && (u = u.attribs), Array.isArray(u) || (u = Object.keys(u)), t.transformFeedbackVaryings(o, u, c || Gc));
  }
  return t.linkProgram(o), o;
}
function Wf(t, e, n, o, r) {
  const i = gr(n, o, r), c = new Set(e), u = Yf(t, e, i);
  function _(x, A) {
    const T = Kf(x, A, i.errorCallback);
    return T && Hf(x, A, c), T;
  }
  if (i.callback) {
    jf(t, u).then(() => {
      const x = _(t, u);
      i.callback(x, x ? void 0 : u);
    });
    return;
  }
  return _(t, u) ? void 0 : u;
}
async function jf(t, e) {
  const n = t.getExtension("KHR_parallel_shader_compile"), o = n ? (i, c) => i.getProgramParameter(c, n.COMPLETION_STATUS_KHR) : () => !0;
  let r = 0;
  do
    await Xf(r), r = 1e3 / 60;
  while (!o(t, e));
}
function Kf(t, e, n) {
  if (n = n || hr, !t.getProgramParameter(e, $c)) {
    const r = t.getProgramInfoLog(e);
    n(`Error in program linking: ${r}`);
    const c = t.getAttachedShaders(e).map((u) => zf(t, t.getShaderParameter(u, t.SHADER_TYPE), u, n));
    return `${r}
${c.filter((u) => u).join(`
`)}`;
  }
}
function Jf(t, e, n, o, r) {
  return Wf(t, e, n, o, r);
}
function Xi(t) {
  const e = t.name;
  return e.startsWith("gl_") || e.startsWith("webgl_");
}
const Qf = /(\.|\[|]|\w+)/g, Zf = (t) => t >= "0" && t <= "9";
function qf(t, e, n, o) {
  const r = t.split(Qf).filter((u) => u !== "");
  let i = 0, c = "";
  for (; ; ) {
    const u = r[i++];
    c += u;
    const _ = Zf(u[0]), x = _ ? parseInt(u) : u;
    if (_ && (c += r[i++]), i === r.length) {
      n[x] = e;
      break;
    } else {
      const T = r[i++], k = T === "[", j = n[x] || (k ? [] : {});
      n[x] = j, n = j, o[c] = o[c] || /* @__PURE__ */ function(W) {
        return function(H) {
          Yi(W, H);
        };
      }(j), c += T;
    }
  }
}
function el(t, e) {
  let n = 0;
  function o(u, _, x) {
    const A = _.name.endsWith("[0]"), T = _.type, k = Y[T];
    if (!k)
      throw new Error(`unknown type: 0x${T.toString(16)}`);
    let j;
    if (k.bindPoint) {
      const W = n;
      n += _.size, A ? j = k.arraySetter(t, T, W, x, _.size) : j = k.setter(t, T, W, x, _.size);
    } else
      k.arraySetter && A ? j = k.arraySetter(t, x) : j = k.setter(t, x);
    return j.location = x, j;
  }
  const r = {}, i = {}, c = t.getProgramParameter(e, gi);
  for (let u = 0; u < c; ++u) {
    const _ = t.getActiveUniform(e, u);
    if (Xi(_))
      continue;
    let x = _.name;
    x.endsWith("[0]") && (x = x.substr(0, x.length - 3));
    const A = t.getUniformLocation(e, _.name);
    if (A) {
      const T = o(e, _, A);
      r[x] = T, qf(x, T, i, r);
    }
  }
  return r;
}
function tl(t, e) {
  const n = {}, o = t.getProgramParameter(e, Xc);
  for (let r = 0; r < o; ++r) {
    const i = t.getTransformFeedbackVarying(e, r);
    n[i.name] = {
      index: r,
      type: i.type,
      size: i.size
    };
  }
  return n;
}
function nl(t, e) {
  const n = t.getProgramParameter(e, gi), o = [], r = [];
  for (let u = 0; u < n; ++u) {
    r.push(u), o.push({});
    const _ = t.getActiveUniform(e, u);
    o[u].name = _.name;
  }
  [
    ["UNIFORM_TYPE", "type"],
    ["UNIFORM_SIZE", "size"],
    // num elements
    ["UNIFORM_BLOCK_INDEX", "blockNdx"],
    ["UNIFORM_OFFSET", "offset"]
  ].forEach(function(u) {
    const _ = u[0], x = u[1];
    t.getActiveUniforms(e, r, t[_]).forEach(function(A, T) {
      o[T][x] = A;
    });
  });
  const i = {}, c = t.getProgramParameter(e, Yc);
  for (let u = 0; u < c; ++u) {
    const _ = t.getActiveUniformBlockName(e, u), x = {
      index: t.getUniformBlockIndex(e, _),
      usedByVertexShader: t.getActiveUniformBlockParameter(e, u, Wc),
      usedByFragmentShader: t.getActiveUniformBlockParameter(e, u, jc),
      size: t.getActiveUniformBlockParameter(e, u, Kc),
      uniformIndices: t.getActiveUniformBlockParameter(e, u, Jc)
    };
    x.used = x.usedByVertexShader || x.usedByFragmentShader, i[_] = x;
  }
  return {
    blockSpecs: i,
    uniformData: o
  };
}
function Yi(t, e) {
  for (const n in e) {
    const o = t[n];
    typeof o == "function" ? o(e[n]) : Yi(t[n], e[n]);
  }
}
function yn(t, ...e) {
  const n = t.uniformSetters || t, o = e.length;
  for (let r = 0; r < o; ++r) {
    const i = e[r];
    if (Array.isArray(i)) {
      const c = i.length;
      for (let u = 0; u < c; ++u)
        yn(n, i[u]);
    } else
      for (const c in i) {
        const u = n[c];
        u && u(i[c]);
      }
  }
}
function rl(t, e) {
  const n = {}, o = t.getProgramParameter(e, Hc);
  for (let r = 0; r < o; ++r) {
    const i = t.getActiveAttrib(e, r);
    if (Xi(i))
      continue;
    const c = t.getAttribLocation(e, i.name), u = ye[i.type], _ = u.setter(t, c, u);
    _.location = c, n[i.name] = _;
  }
  return n;
}
function ol(t, e) {
  for (const n in e) {
    const o = t[n];
    o && o(e[n]);
  }
}
function hn(t, e, n) {
  n.vertexArrayObject ? t.bindVertexArray(n.vertexArrayObject) : (ol(e.attribSetters || e, n.attribs), n.indices && t.bindBuffer(Lc, n.indices));
}
function Go(t, e) {
  const n = el(t, e), o = rl(t, e), r = {
    program: e,
    uniformSetters: n,
    attribSetters: o
  };
  return pr(t) && (r.uniformBlockSpec = nl(t, e), r.transformFeedbackInfo = tl(t, e)), r;
}
const il = /\s|{|}|;/;
function Kn(t, e, n, o, r) {
  const i = gr(n, o, r), c = [];
  if (e = e.map(function(x) {
    if (!il.test(x)) {
      const A = Ei(x);
      if (A)
        x = A.text;
      else {
        const T = `no element with id: ${x}`;
        i.errorCallback(T), c.push(T);
      }
    }
    return x;
  }), c.length)
    return $f(i, "");
  const u = i.callback;
  u && (i.callback = (x, A) => {
    u(x, x ? void 0 : Go(t, A));
  });
  const _ = Jf(t, e, i);
  return _ ? Go(t, _) : null;
}
const sl = 4, Ho = 5123;
function $t(t, e, n, o, r, i) {
  n = n === void 0 ? sl : n;
  const c = e.indices, u = e.elementType, _ = o === void 0 ? e.numElements : o;
  r = r === void 0 ? 0 : r, u || c ? i !== void 0 ? t.drawElementsInstanced(n, _, u === void 0 ? Ho : e.elementType, r, i) : t.drawElements(n, _, u === void 0 ? Ho : e.elementType, r) : i !== void 0 ? t.drawArraysInstanced(n, r, _, i) : t.drawArrays(n, r, _);
}
function al(t, e) {
  e = e || 1, e = Math.max(0, e);
  const n = t.clientWidth * e | 0, o = t.clientHeight * e | 0;
  return t.width !== n || t.height !== o ? (t.width = n, t.height = o, !0) : !1;
}
function ul(t) {
  if (!(typeof window > "u")) {
    var e = document.createElement("style");
    return e.setAttribute("type", "text/css"), e.innerHTML = t, document.head.appendChild(e), t;
  }
}
function Bt(t, e) {
  var n = t.__state.conversionName.toString(), o = Math.round(t.r), r = Math.round(t.g), i = Math.round(t.b), c = t.a, u = Math.round(t.h), _ = t.s.toFixed(1), x = t.v.toFixed(1);
  if (e || n === "THREE_CHAR_HEX" || n === "SIX_CHAR_HEX") {
    for (var A = t.hex.toString(16); A.length < 6; )
      A = "0" + A;
    return "#" + A;
  } else {
    if (n === "CSS_RGB")
      return "rgb(" + o + "," + r + "," + i + ")";
    if (n === "CSS_RGBA")
      return "rgba(" + o + "," + r + "," + i + "," + c + ")";
    if (n === "HEX")
      return "0x" + t.hex.toString(16);
    if (n === "RGB_ARRAY")
      return "[" + o + "," + r + "," + i + "]";
    if (n === "RGBA_ARRAY")
      return "[" + o + "," + r + "," + i + "," + c + "]";
    if (n === "RGB_OBJ")
      return "{r:" + o + ",g:" + r + ",b:" + i + "}";
    if (n === "RGBA_OBJ")
      return "{r:" + o + ",g:" + r + ",b:" + i + ",a:" + c + "}";
    if (n === "HSV_OBJ")
      return "{h:" + u + ",s:" + _ + ",v:" + x + "}";
    if (n === "HSVA_OBJ")
      return "{h:" + u + ",s:" + _ + ",v:" + x + ",a:" + c + "}";
  }
  return "unknown format";
}
var Xo = Array.prototype.forEach, zt = Array.prototype.slice, y = {
  BREAK: {},
  extend: function(e) {
    return this.each(zt.call(arguments, 1), function(n) {
      var o = this.isObject(n) ? Object.keys(n) : [];
      o.forEach((function(r) {
        this.isUndefined(n[r]) || (e[r] = n[r]);
      }).bind(this));
    }, this), e;
  },
  defaults: function(e) {
    return this.each(zt.call(arguments, 1), function(n) {
      var o = this.isObject(n) ? Object.keys(n) : [];
      o.forEach((function(r) {
        this.isUndefined(e[r]) && (e[r] = n[r]);
      }).bind(this));
    }, this), e;
  },
  compose: function() {
    var e = zt.call(arguments);
    return function() {
      for (var n = zt.call(arguments), o = e.length - 1; o >= 0; o--)
        n = [e[o].apply(this, n)];
      return n[0];
    };
  },
  each: function(e, n, o) {
    if (e) {
      if (Xo && e.forEach && e.forEach === Xo)
        e.forEach(n, o);
      else if (e.length === e.length + 0) {
        var r = void 0, i = void 0;
        for (r = 0, i = e.length; r < i; r++)
          if (r in e && n.call(o, e[r], r) === this.BREAK)
            return;
      } else
        for (var c in e)
          if (n.call(o, e[c], c) === this.BREAK)
            return;
    }
  },
  defer: function(e) {
    setTimeout(e, 0);
  },
  debounce: function(e, n, o) {
    var r = void 0;
    return function() {
      var i = this, c = arguments;
      function u() {
        r = null, o || e.apply(i, c);
      }
      var _ = o || !r;
      clearTimeout(r), r = setTimeout(u, n), _ && e.apply(i, c);
    };
  },
  toArray: function(e) {
    return e.toArray ? e.toArray() : zt.call(e);
  },
  isUndefined: function(e) {
    return e === void 0;
  },
  isNull: function(e) {
    return e === null;
  },
  isNaN: function(t) {
    function e(n) {
      return t.apply(this, arguments);
    }
    return e.toString = function() {
      return t.toString();
    }, e;
  }(function(t) {
    return isNaN(t);
  }),
  isArray: Array.isArray || function(t) {
    return t.constructor === Array;
  },
  isObject: function(e) {
    return e === Object(e);
  },
  isNumber: function(e) {
    return e === e + 0;
  },
  isString: function(e) {
    return e === e + "";
  },
  isBoolean: function(e) {
    return e === !1 || e === !0;
  },
  isFunction: function(e) {
    return e instanceof Function;
  }
}, cl = [
  {
    litmus: y.isString,
    conversions: {
      THREE_CHAR_HEX: {
        read: function(e) {
          var n = e.match(/^#([A-F0-9])([A-F0-9])([A-F0-9])$/i);
          return n === null ? !1 : {
            space: "HEX",
            hex: parseInt("0x" + n[1].toString() + n[1].toString() + n[2].toString() + n[2].toString() + n[3].toString() + n[3].toString(), 0)
          };
        },
        write: Bt
      },
      SIX_CHAR_HEX: {
        read: function(e) {
          var n = e.match(/^#([A-F0-9]{6})$/i);
          return n === null ? !1 : {
            space: "HEX",
            hex: parseInt("0x" + n[1].toString(), 0)
          };
        },
        write: Bt
      },
      CSS_RGB: {
        read: function(e) {
          var n = e.match(/^rgb\(\s*(\S+)\s*,\s*(\S+)\s*,\s*(\S+)\s*\)/);
          return n === null ? !1 : {
            space: "RGB",
            r: parseFloat(n[1]),
            g: parseFloat(n[2]),
            b: parseFloat(n[3])
          };
        },
        write: Bt
      },
      CSS_RGBA: {
        read: function(e) {
          var n = e.match(/^rgba\(\s*(\S+)\s*,\s*(\S+)\s*,\s*(\S+)\s*,\s*(\S+)\s*\)/);
          return n === null ? !1 : {
            space: "RGB",
            r: parseFloat(n[1]),
            g: parseFloat(n[2]),
            b: parseFloat(n[3]),
            a: parseFloat(n[4])
          };
        },
        write: Bt
      }
    }
  },
  {
    litmus: y.isNumber,
    conversions: {
      HEX: {
        read: function(e) {
          return {
            space: "HEX",
            hex: e,
            conversionName: "HEX"
          };
        },
        write: function(e) {
          return e.hex;
        }
      }
    }
  },
  {
    litmus: y.isArray,
    conversions: {
      RGB_ARRAY: {
        read: function(e) {
          return e.length !== 3 ? !1 : {
            space: "RGB",
            r: e[0],
            g: e[1],
            b: e[2]
          };
        },
        write: function(e) {
          return [e.r, e.g, e.b];
        }
      },
      RGBA_ARRAY: {
        read: function(e) {
          return e.length !== 4 ? !1 : {
            space: "RGB",
            r: e[0],
            g: e[1],
            b: e[2],
            a: e[3]
          };
        },
        write: function(e) {
          return [e.r, e.g, e.b, e.a];
        }
      }
    }
  },
  {
    litmus: y.isObject,
    conversions: {
      RGBA_OBJ: {
        read: function(e) {
          return y.isNumber(e.r) && y.isNumber(e.g) && y.isNumber(e.b) && y.isNumber(e.a) ? {
            space: "RGB",
            r: e.r,
            g: e.g,
            b: e.b,
            a: e.a
          } : !1;
        },
        write: function(e) {
          return {
            r: e.r,
            g: e.g,
            b: e.b,
            a: e.a
          };
        }
      },
      RGB_OBJ: {
        read: function(e) {
          return y.isNumber(e.r) && y.isNumber(e.g) && y.isNumber(e.b) ? {
            space: "RGB",
            r: e.r,
            g: e.g,
            b: e.b
          } : !1;
        },
        write: function(e) {
          return {
            r: e.r,
            g: e.g,
            b: e.b
          };
        }
      },
      HSVA_OBJ: {
        read: function(e) {
          return y.isNumber(e.h) && y.isNumber(e.s) && y.isNumber(e.v) && y.isNumber(e.a) ? {
            space: "HSV",
            h: e.h,
            s: e.s,
            v: e.v,
            a: e.a
          } : !1;
        },
        write: function(e) {
          return {
            h: e.h,
            s: e.s,
            v: e.v,
            a: e.a
          };
        }
      },
      HSV_OBJ: {
        read: function(e) {
          return y.isNumber(e.h) && y.isNumber(e.s) && y.isNumber(e.v) ? {
            space: "HSV",
            h: e.h,
            s: e.s,
            v: e.v
          } : !1;
        },
        write: function(e) {
          return {
            h: e.h,
            s: e.s,
            v: e.v
          };
        }
      }
    }
  }
], Vt = void 0, bn = void 0, qn = function() {
  bn = !1;
  var e = arguments.length > 1 ? y.toArray(arguments) : arguments[0];
  return y.each(cl, function(n) {
    if (n.litmus(e))
      return y.each(n.conversions, function(o, r) {
        if (Vt = o.read(e), bn === !1 && Vt !== !1)
          return bn = Vt, Vt.conversionName = r, Vt.conversion = o, y.BREAK;
      }), y.BREAK;
  }), bn;
}, Yo = void 0, Tn = {
  hsv_to_rgb: function(e, n, o) {
    var r = Math.floor(e / 60) % 6, i = e / 60 - Math.floor(e / 60), c = o * (1 - n), u = o * (1 - i * n), _ = o * (1 - (1 - i) * n), x = [[o, _, c], [u, o, c], [c, o, _], [c, u, o], [_, c, o], [o, c, u]][r];
    return {
      r: x[0] * 255,
      g: x[1] * 255,
      b: x[2] * 255
    };
  },
  rgb_to_hsv: function(e, n, o) {
    var r = Math.min(e, n, o), i = Math.max(e, n, o), c = i - r, u = void 0, _ = void 0;
    if (i !== 0)
      _ = c / i;
    else
      return {
        h: NaN,
        s: 0,
        v: 0
      };
    return e === i ? u = (n - o) / c : n === i ? u = 2 + (o - e) / c : u = 4 + (e - n) / c, u /= 6, u < 0 && (u += 1), {
      h: u * 360,
      s: _,
      v: i / 255
    };
  },
  rgb_to_hex: function(e, n, o) {
    var r = this.hex_with_component(0, 2, e);
    return r = this.hex_with_component(r, 1, n), r = this.hex_with_component(r, 0, o), r;
  },
  component_from_hex: function(e, n) {
    return e >> n * 8 & 255;
  },
  hex_with_component: function(e, n, o) {
    return o << (Yo = n * 8) | e & ~(255 << Yo);
  }
}, fl = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
  return typeof t;
} : function(t) {
  return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
}, je = function(t, e) {
  if (!(t instanceof e))
    throw new TypeError("Cannot call a class as a function");
}, Ke = /* @__PURE__ */ function() {
  function t(e, n) {
    for (var o = 0; o < n.length; o++) {
      var r = n[o];
      r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r);
    }
  }
  return function(e, n, o) {
    return n && t(e.prototype, n), o && t(e, o), e;
  };
}(), pt = function t(e, n, o) {
  e === null && (e = Function.prototype);
  var r = Object.getOwnPropertyDescriptor(e, n);
  if (r === void 0) {
    var i = Object.getPrototypeOf(e);
    return i === null ? void 0 : t(i, n, o);
  } else {
    if ("value" in r)
      return r.value;
    var c = r.get;
    return c === void 0 ? void 0 : c.call(o);
  }
}, bt = function(t, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof e);
  t.prototype = Object.create(e && e.prototype, {
    constructor: {
      value: t,
      enumerable: !1,
      writable: !0,
      configurable: !0
    }
  }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
}, xt = function(t, e) {
  if (!t)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e && (typeof e == "object" || typeof e == "function") ? e : t;
}, Re = function() {
  function t() {
    if (je(this, t), this.__state = qn.apply(this, arguments), this.__state === !1)
      throw new Error("Failed to interpret color arguments");
    this.__state.a = this.__state.a || 1;
  }
  return Ke(t, [{
    key: "toString",
    value: function() {
      return Bt(this);
    }
  }, {
    key: "toHexString",
    value: function() {
      return Bt(this, !0);
    }
  }, {
    key: "toOriginal",
    value: function() {
      return this.__state.conversion.write(this);
    }
  }]), t;
}();
function Ar(t, e, n) {
  Object.defineProperty(t, e, {
    get: function() {
      return this.__state.space === "RGB" ? this.__state[e] : (Re.recalculateRGB(this, e, n), this.__state[e]);
    },
    set: function(r) {
      this.__state.space !== "RGB" && (Re.recalculateRGB(this, e, n), this.__state.space = "RGB"), this.__state[e] = r;
    }
  });
}
function Tr(t, e) {
  Object.defineProperty(t, e, {
    get: function() {
      return this.__state.space === "HSV" ? this.__state[e] : (Re.recalculateHSV(this), this.__state[e]);
    },
    set: function(o) {
      this.__state.space !== "HSV" && (Re.recalculateHSV(this), this.__state.space = "HSV"), this.__state[e] = o;
    }
  });
}
Re.recalculateRGB = function(t, e, n) {
  if (t.__state.space === "HEX")
    t.__state[e] = Tn.component_from_hex(t.__state.hex, n);
  else if (t.__state.space === "HSV")
    y.extend(t.__state, Tn.hsv_to_rgb(t.__state.h, t.__state.s, t.__state.v));
  else
    throw new Error("Corrupted color state");
};
Re.recalculateHSV = function(t) {
  var e = Tn.rgb_to_hsv(t.r, t.g, t.b);
  y.extend(t.__state, {
    s: e.s,
    v: e.v
  }), y.isNaN(e.h) ? y.isUndefined(t.__state.h) && (t.__state.h = 0) : t.__state.h = e.h;
};
Re.COMPONENTS = ["r", "g", "b", "h", "s", "v", "hex", "a"];
Ar(Re.prototype, "r", 2);
Ar(Re.prototype, "g", 1);
Ar(Re.prototype, "b", 0);
Tr(Re.prototype, "h");
Tr(Re.prototype, "s");
Tr(Re.prototype, "v");
Object.defineProperty(Re.prototype, "a", {
  get: function() {
    return this.__state.a;
  },
  set: function(e) {
    this.__state.a = e;
  }
});
Object.defineProperty(Re.prototype, "hex", {
  get: function() {
    return this.__state.space !== "HEX" && (this.__state.hex = Tn.rgb_to_hex(this.r, this.g, this.b), this.__state.space = "HEX"), this.__state.hex;
  },
  set: function(e) {
    this.__state.space = "HEX", this.__state.hex = e;
  }
});
var vt = function() {
  function t(e, n) {
    je(this, t), this.initialValue = e[n], this.domElement = document.createElement("div"), this.object = e, this.property = n, this.__onChange = void 0, this.__onFinishChange = void 0;
  }
  return Ke(t, [{
    key: "onChange",
    value: function(n) {
      return this.__onChange = n, this;
    }
  }, {
    key: "onFinishChange",
    value: function(n) {
      return this.__onFinishChange = n, this;
    }
  }, {
    key: "setValue",
    value: function(n) {
      return this.object[this.property] = n, this.__onChange && this.__onChange.call(this, n), this.updateDisplay(), this;
    }
  }, {
    key: "getValue",
    value: function() {
      return this.object[this.property];
    }
  }, {
    key: "updateDisplay",
    value: function() {
      return this;
    }
  }, {
    key: "isModified",
    value: function() {
      return this.initialValue !== this.getValue();
    }
  }]), t;
}(), ll = {
  HTMLEvents: ["change"],
  MouseEvents: ["click", "mousemove", "mousedown", "mouseup", "mouseover"],
  KeyboardEvents: ["keydown"]
}, Wi = {};
y.each(ll, function(t, e) {
  y.each(t, function(n) {
    Wi[n] = e;
  });
});
var dl = /(\d+(\.\d+)?)px/;
function tt(t) {
  if (t === "0" || y.isUndefined(t))
    return 0;
  var e = t.match(dl);
  return y.isNull(e) ? 0 : parseFloat(e[1]);
}
var m = {
  makeSelectable: function(e, n) {
    e === void 0 || e.style === void 0 || (e.onselectstart = n ? function() {
      return !1;
    } : function() {
    }, e.style.MozUserSelect = n ? "auto" : "none", e.style.KhtmlUserSelect = n ? "auto" : "none", e.unselectable = n ? "on" : "off");
  },
  makeFullscreen: function(e, n, o) {
    var r = o, i = n;
    y.isUndefined(i) && (i = !0), y.isUndefined(r) && (r = !0), e.style.position = "absolute", i && (e.style.left = 0, e.style.right = 0), r && (e.style.top = 0, e.style.bottom = 0);
  },
  fakeEvent: function(e, n, o, r) {
    var i = o || {}, c = Wi[n];
    if (!c)
      throw new Error("Event type " + n + " not supported.");
    var u = document.createEvent(c);
    switch (c) {
      case "MouseEvents": {
        var _ = i.x || i.clientX || 0, x = i.y || i.clientY || 0;
        u.initMouseEvent(
          n,
          i.bubbles || !1,
          i.cancelable || !0,
          window,
          i.clickCount || 1,
          0,
          0,
          _,
          x,
          !1,
          !1,
          !1,
          !1,
          0,
          null
        );
        break;
      }
      case "KeyboardEvents": {
        var A = u.initKeyboardEvent || u.initKeyEvent;
        y.defaults(i, {
          cancelable: !0,
          ctrlKey: !1,
          altKey: !1,
          shiftKey: !1,
          metaKey: !1,
          keyCode: void 0,
          charCode: void 0
        }), A(n, i.bubbles || !1, i.cancelable, window, i.ctrlKey, i.altKey, i.shiftKey, i.metaKey, i.keyCode, i.charCode);
        break;
      }
      default: {
        u.initEvent(n, i.bubbles || !1, i.cancelable || !0);
        break;
      }
    }
    y.defaults(u, r), e.dispatchEvent(u);
  },
  bind: function(e, n, o, r) {
    var i = r || !1;
    return e.addEventListener ? e.addEventListener(n, o, i) : e.attachEvent && e.attachEvent("on" + n, o), m;
  },
  unbind: function(e, n, o, r) {
    var i = r || !1;
    return e.removeEventListener ? e.removeEventListener(n, o, i) : e.detachEvent && e.detachEvent("on" + n, o), m;
  },
  addClass: function(e, n) {
    if (e.className === void 0)
      e.className = n;
    else if (e.className !== n) {
      var o = e.className.split(/ +/);
      o.indexOf(n) === -1 && (o.push(n), e.className = o.join(" ").replace(/^\s+/, "").replace(/\s+$/, ""));
    }
    return m;
  },
  removeClass: function(e, n) {
    if (n)
      if (e.className === n)
        e.removeAttribute("class");
      else {
        var o = e.className.split(/ +/), r = o.indexOf(n);
        r !== -1 && (o.splice(r, 1), e.className = o.join(" "));
      }
    else
      e.className = void 0;
    return m;
  },
  hasClass: function(e, n) {
    return new RegExp("(?:^|\\s+)" + n + "(?:\\s+|$)").test(e.className) || !1;
  },
  getWidth: function(e) {
    var n = getComputedStyle(e);
    return tt(n["border-left-width"]) + tt(n["border-right-width"]) + tt(n["padding-left"]) + tt(n["padding-right"]) + tt(n.width);
  },
  getHeight: function(e) {
    var n = getComputedStyle(e);
    return tt(n["border-top-width"]) + tt(n["border-bottom-width"]) + tt(n["padding-top"]) + tt(n["padding-bottom"]) + tt(n.height);
  },
  getOffset: function(e) {
    var n = e, o = { left: 0, top: 0 };
    if (n.offsetParent)
      do
        o.left += n.offsetLeft, o.top += n.offsetTop, n = n.offsetParent;
      while (n);
    return o;
  },
  isActive: function(e) {
    return e === document.activeElement && (e.type || e.href);
  }
}, ji = function(t) {
  bt(e, t);
  function e(n, o) {
    je(this, e);
    var r = xt(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, n, o)), i = r;
    r.__prev = r.getValue(), r.__checkbox = document.createElement("input"), r.__checkbox.setAttribute("type", "checkbox");
    function c() {
      i.setValue(!i.__prev);
    }
    return m.bind(r.__checkbox, "change", c, !1), r.domElement.appendChild(r.__checkbox), r.updateDisplay(), r;
  }
  return Ke(e, [{
    key: "setValue",
    value: function(o) {
      var r = pt(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "setValue", this).call(this, o);
      return this.__onFinishChange && this.__onFinishChange.call(this, this.getValue()), this.__prev = this.getValue(), r;
    }
  }, {
    key: "updateDisplay",
    value: function() {
      return this.getValue() === !0 ? (this.__checkbox.setAttribute("checked", "checked"), this.__checkbox.checked = !0, this.__prev = !0) : (this.__checkbox.checked = !1, this.__prev = !1), pt(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "updateDisplay", this).call(this);
    }
  }]), e;
}(vt), ml = function(t) {
  bt(e, t);
  function e(n, o, r) {
    je(this, e);
    var i = xt(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, n, o)), c = r, u = i;
    if (i.__select = document.createElement("select"), y.isArray(c)) {
      var _ = {};
      y.each(c, function(x) {
        _[x] = x;
      }), c = _;
    }
    return y.each(c, function(x, A) {
      var T = document.createElement("option");
      T.innerHTML = A, T.setAttribute("value", x), u.__select.appendChild(T);
    }), i.updateDisplay(), m.bind(i.__select, "change", function() {
      var x = this.options[this.selectedIndex].value;
      u.setValue(x);
    }), i.domElement.appendChild(i.__select), i;
  }
  return Ke(e, [{
    key: "setValue",
    value: function(o) {
      var r = pt(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "setValue", this).call(this, o);
      return this.__onFinishChange && this.__onFinishChange.call(this, this.getValue()), r;
    }
  }, {
    key: "updateDisplay",
    value: function() {
      return m.isActive(this.__select) ? this : (this.__select.value = this.getValue(), pt(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "updateDisplay", this).call(this));
    }
  }]), e;
}(vt), _l = function(t) {
  bt(e, t);
  function e(n, o) {
    je(this, e);
    var r = xt(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, n, o)), i = r;
    function c() {
      i.setValue(i.__input.value);
    }
    function u() {
      i.__onFinishChange && i.__onFinishChange.call(i, i.getValue());
    }
    return r.__input = document.createElement("input"), r.__input.setAttribute("type", "text"), m.bind(r.__input, "keyup", c), m.bind(r.__input, "change", c), m.bind(r.__input, "blur", u), m.bind(r.__input, "keydown", function(_) {
      _.keyCode === 13 && this.blur();
    }), r.updateDisplay(), r.domElement.appendChild(r.__input), r;
  }
  return Ke(e, [{
    key: "updateDisplay",
    value: function() {
      return m.isActive(this.__input) || (this.__input.value = this.getValue()), pt(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "updateDisplay", this).call(this);
    }
  }]), e;
}(vt);
function Wo(t) {
  var e = t.toString();
  return e.indexOf(".") > -1 ? e.length - e.indexOf(".") - 1 : 0;
}
var Ki = function(t) {
  bt(e, t);
  function e(n, o, r) {
    je(this, e);
    var i = xt(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, n, o)), c = r || {};
    return i.__min = c.min, i.__max = c.max, i.__step = c.step, y.isUndefined(i.__step) ? i.initialValue === 0 ? i.__impliedStep = 1 : i.__impliedStep = Math.pow(10, Math.floor(Math.log(Math.abs(i.initialValue)) / Math.LN10)) / 10 : i.__impliedStep = i.__step, i.__precision = Wo(i.__impliedStep), i;
  }
  return Ke(e, [{
    key: "setValue",
    value: function(o) {
      var r = o;
      return this.__min !== void 0 && r < this.__min ? r = this.__min : this.__max !== void 0 && r > this.__max && (r = this.__max), this.__step !== void 0 && r % this.__step !== 0 && (r = Math.round(r / this.__step) * this.__step), pt(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "setValue", this).call(this, r);
    }
  }, {
    key: "min",
    value: function(o) {
      return this.__min = o, this;
    }
  }, {
    key: "max",
    value: function(o) {
      return this.__max = o, this;
    }
  }, {
    key: "step",
    value: function(o) {
      return this.__step = o, this.__impliedStep = o, this.__precision = Wo(o), this;
    }
  }]), e;
}(vt);
function pl(t, e) {
  var n = Math.pow(10, e);
  return Math.round(t * n) / n;
}
var vn = function(t) {
  bt(e, t);
  function e(n, o, r) {
    je(this, e);
    var i = xt(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, n, o, r));
    i.__truncationSuspended = !1;
    var c = i, u = void 0;
    function _() {
      var W = parseFloat(c.__input.value);
      y.isNaN(W) || c.setValue(W);
    }
    function x() {
      c.__onFinishChange && c.__onFinishChange.call(c, c.getValue());
    }
    function A() {
      x();
    }
    function T(W) {
      var H = u - W.clientY;
      c.setValue(c.getValue() + H * c.__impliedStep), u = W.clientY;
    }
    function k() {
      m.unbind(window, "mousemove", T), m.unbind(window, "mouseup", k), x();
    }
    function j(W) {
      m.bind(window, "mousemove", T), m.bind(window, "mouseup", k), u = W.clientY;
    }
    return i.__input = document.createElement("input"), i.__input.setAttribute("type", "text"), m.bind(i.__input, "change", _), m.bind(i.__input, "blur", A), m.bind(i.__input, "mousedown", j), m.bind(i.__input, "keydown", function(W) {
      W.keyCode === 13 && (c.__truncationSuspended = !0, this.blur(), c.__truncationSuspended = !1, x());
    }), i.updateDisplay(), i.domElement.appendChild(i.__input), i;
  }
  return Ke(e, [{
    key: "updateDisplay",
    value: function() {
      return this.__input.value = this.__truncationSuspended ? this.getValue() : pl(this.getValue(), this.__precision), pt(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "updateDisplay", this).call(this);
    }
  }]), e;
}(Ki);
function jo(t, e, n, o, r) {
  return o + (r - o) * ((t - e) / (n - e));
}
var er = function(t) {
  bt(e, t);
  function e(n, o, r, i, c) {
    je(this, e);
    var u = xt(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, n, o, { min: r, max: i, step: c })), _ = u;
    u.__background = document.createElement("div"), u.__foreground = document.createElement("div"), m.bind(u.__background, "mousedown", x), m.bind(u.__background, "touchstart", k), m.addClass(u.__background, "slider"), m.addClass(u.__foreground, "slider-fg");
    function x(H) {
      document.activeElement.blur(), m.bind(window, "mousemove", A), m.bind(window, "mouseup", T), A(H);
    }
    function A(H) {
      H.preventDefault();
      var ee = _.__background.getBoundingClientRect();
      return _.setValue(jo(H.clientX, ee.left, ee.right, _.__min, _.__max)), !1;
    }
    function T() {
      m.unbind(window, "mousemove", A), m.unbind(window, "mouseup", T), _.__onFinishChange && _.__onFinishChange.call(_, _.getValue());
    }
    function k(H) {
      H.touches.length === 1 && (m.bind(window, "touchmove", j), m.bind(window, "touchend", W), j(H));
    }
    function j(H) {
      var ee = H.touches[0].clientX, V = _.__background.getBoundingClientRect();
      _.setValue(jo(ee, V.left, V.right, _.__min, _.__max));
    }
    function W() {
      m.unbind(window, "touchmove", j), m.unbind(window, "touchend", W), _.__onFinishChange && _.__onFinishChange.call(_, _.getValue());
    }
    return u.updateDisplay(), u.__background.appendChild(u.__foreground), u.domElement.appendChild(u.__background), u;
  }
  return Ke(e, [{
    key: "updateDisplay",
    value: function() {
      var o = (this.getValue() - this.__min) / (this.__max - this.__min);
      return this.__foreground.style.width = o * 100 + "%", pt(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "updateDisplay", this).call(this);
    }
  }]), e;
}(Ki), Ji = function(t) {
  bt(e, t);
  function e(n, o, r) {
    je(this, e);
    var i = xt(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, n, o)), c = i;
    return i.__button = document.createElement("div"), i.__button.innerHTML = r === void 0 ? "Fire" : r, m.bind(i.__button, "click", function(u) {
      return u.preventDefault(), c.fire(), !1;
    }), m.addClass(i.__button, "button"), i.domElement.appendChild(i.__button), i;
  }
  return Ke(e, [{
    key: "fire",
    value: function() {
      this.__onChange && this.__onChange.call(this), this.getValue().call(this.object), this.__onFinishChange && this.__onFinishChange.call(this, this.getValue());
    }
  }]), e;
}(vt), tr = function(t) {
  bt(e, t);
  function e(n, o) {
    je(this, e);
    var r = xt(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, n, o));
    r.__color = new Re(r.getValue()), r.__temp = new Re(0);
    var i = r;
    r.domElement = document.createElement("div"), m.makeSelectable(r.domElement, !1), r.__selector = document.createElement("div"), r.__selector.className = "selector", r.__saturation_field = document.createElement("div"), r.__saturation_field.className = "saturation-field", r.__field_knob = document.createElement("div"), r.__field_knob.className = "field-knob", r.__field_knob_border = "2px solid ", r.__hue_knob = document.createElement("div"), r.__hue_knob.className = "hue-knob", r.__hue_field = document.createElement("div"), r.__hue_field.className = "hue-field", r.__input = document.createElement("input"), r.__input.type = "text", r.__input_textShadow = "0 1px 1px ", m.bind(r.__input, "keydown", function(H) {
      H.keyCode === 13 && T.call(this);
    }), m.bind(r.__input, "blur", T), m.bind(r.__selector, "mousedown", function() {
      m.addClass(this, "drag").bind(window, "mouseup", function() {
        m.removeClass(i.__selector, "drag");
      });
    }), m.bind(r.__selector, "touchstart", function() {
      m.addClass(this, "drag").bind(window, "touchend", function() {
        m.removeClass(i.__selector, "drag");
      });
    });
    var c = document.createElement("div");
    y.extend(r.__selector.style, {
      width: "122px",
      height: "102px",
      padding: "3px",
      backgroundColor: "#222",
      boxShadow: "0px 1px 3px rgba(0,0,0,0.3)"
    }), y.extend(r.__field_knob.style, {
      position: "absolute",
      width: "12px",
      height: "12px",
      border: r.__field_knob_border + (r.__color.v < 0.5 ? "#fff" : "#000"),
      boxShadow: "0px 1px 3px rgba(0,0,0,0.5)",
      borderRadius: "12px",
      zIndex: 1
    }), y.extend(r.__hue_knob.style, {
      position: "absolute",
      width: "15px",
      height: "2px",
      borderRight: "4px solid #fff",
      zIndex: 1
    }), y.extend(r.__saturation_field.style, {
      width: "100px",
      height: "100px",
      border: "1px solid #555",
      marginRight: "3px",
      display: "inline-block",
      cursor: "pointer"
    }), y.extend(c.style, {
      width: "100%",
      height: "100%",
      background: "none"
    }), Ko(c, "top", "rgba(0,0,0,0)", "#000"), y.extend(r.__hue_field.style, {
      width: "15px",
      height: "100px",
      border: "1px solid #555",
      cursor: "ns-resize",
      position: "absolute",
      top: "3px",
      right: "3px"
    }), bl(r.__hue_field), y.extend(r.__input.style, {
      outline: "none",
      textAlign: "center",
      color: "#fff",
      border: 0,
      fontWeight: "bold",
      textShadow: r.__input_textShadow + "rgba(0,0,0,0.7)"
    }), m.bind(r.__saturation_field, "mousedown", u), m.bind(r.__saturation_field, "touchstart", u), m.bind(r.__field_knob, "mousedown", u), m.bind(r.__field_knob, "touchstart", u), m.bind(r.__hue_field, "mousedown", _), m.bind(r.__hue_field, "touchstart", _);
    function u(H) {
      j(H), m.bind(window, "mousemove", j), m.bind(window, "touchmove", j), m.bind(window, "mouseup", x), m.bind(window, "touchend", x);
    }
    function _(H) {
      W(H), m.bind(window, "mousemove", W), m.bind(window, "touchmove", W), m.bind(window, "mouseup", A), m.bind(window, "touchend", A);
    }
    function x() {
      m.unbind(window, "mousemove", j), m.unbind(window, "touchmove", j), m.unbind(window, "mouseup", x), m.unbind(window, "touchend", x), k();
    }
    function A() {
      m.unbind(window, "mousemove", W), m.unbind(window, "touchmove", W), m.unbind(window, "mouseup", A), m.unbind(window, "touchend", A), k();
    }
    function T() {
      var H = qn(this.value);
      H !== !1 ? (i.__color.__state = H, i.setValue(i.__color.toOriginal())) : this.value = i.__color.toString();
    }
    function k() {
      i.__onFinishChange && i.__onFinishChange.call(i, i.__color.toOriginal());
    }
    r.__saturation_field.appendChild(c), r.__selector.appendChild(r.__field_knob), r.__selector.appendChild(r.__saturation_field), r.__selector.appendChild(r.__hue_field), r.__hue_field.appendChild(r.__hue_knob), r.domElement.appendChild(r.__input), r.domElement.appendChild(r.__selector), r.updateDisplay();
    function j(H) {
      H.type.indexOf("touch") === -1 && H.preventDefault();
      var ee = i.__saturation_field.getBoundingClientRect(), V = H.touches && H.touches[0] || H, pe = V.clientX, Z = V.clientY, ie = (pe - ee.left) / (ee.right - ee.left), Ee = 1 - (Z - ee.top) / (ee.bottom - ee.top);
      return Ee > 1 ? Ee = 1 : Ee < 0 && (Ee = 0), ie > 1 ? ie = 1 : ie < 0 && (ie = 0), i.__color.v = Ee, i.__color.s = ie, i.setValue(i.__color.toOriginal()), !1;
    }
    function W(H) {
      H.type.indexOf("touch") === -1 && H.preventDefault();
      var ee = i.__hue_field.getBoundingClientRect(), V = H.touches && H.touches[0] || H, pe = V.clientY, Z = 1 - (pe - ee.top) / (ee.bottom - ee.top);
      return Z > 1 ? Z = 1 : Z < 0 && (Z = 0), i.__color.h = Z * 360, i.setValue(i.__color.toOriginal()), !1;
    }
    return r;
  }
  return Ke(e, [{
    key: "updateDisplay",
    value: function() {
      var o = qn(this.getValue());
      if (o !== !1) {
        var r = !1;
        y.each(Re.COMPONENTS, function(u) {
          if (!y.isUndefined(o[u]) && !y.isUndefined(this.__color.__state[u]) && o[u] !== this.__color.__state[u])
            return r = !0, {};
        }, this), r && y.extend(this.__color.__state, o);
      }
      y.extend(this.__temp.__state, this.__color.__state), this.__temp.a = 1;
      var i = this.__color.v < 0.5 || this.__color.s > 0.5 ? 255 : 0, c = 255 - i;
      y.extend(this.__field_knob.style, {
        marginLeft: 100 * this.__color.s - 7 + "px",
        marginTop: 100 * (1 - this.__color.v) - 7 + "px",
        backgroundColor: this.__temp.toHexString(),
        border: this.__field_knob_border + "rgb(" + i + "," + i + "," + i + ")"
      }), this.__hue_knob.style.marginTop = (1 - this.__color.h / 360) * 100 + "px", this.__temp.s = 1, this.__temp.v = 1, Ko(this.__saturation_field, "left", "#fff", this.__temp.toHexString()), this.__input.value = this.__color.toString(), y.extend(this.__input.style, {
        backgroundColor: this.__color.toHexString(),
        color: "rgb(" + i + "," + i + "," + i + ")",
        textShadow: this.__input_textShadow + "rgba(" + c + "," + c + "," + c + ",.7)"
      });
    }
  }]), e;
}(vt), hl = ["-moz-", "-o-", "-webkit-", "-ms-", ""];
function Ko(t, e, n, o) {
  t.style.background = "", y.each(hl, function(r) {
    t.style.cssText += "background: " + r + "linear-gradient(" + e + ", " + n + " 0%, " + o + " 100%); ";
  });
}
function bl(t) {
  t.style.background = "", t.style.cssText += "background: -moz-linear-gradient(top,  #ff0000 0%, #ff00ff 17%, #0000ff 34%, #00ffff 50%, #00ff00 67%, #ffff00 84%, #ff0000 100%);", t.style.cssText += "background: -webkit-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);", t.style.cssText += "background: -o-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);", t.style.cssText += "background: -ms-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);", t.style.cssText += "background: linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);";
}
var xl = {
  load: function(e, n) {
    var o = n || document, r = o.createElement("link");
    r.type = "text/css", r.rel = "stylesheet", r.href = e, o.getElementsByTagName("head")[0].appendChild(r);
  },
  inject: function(e, n) {
    var o = n || document, r = document.createElement("style");
    r.type = "text/css", r.innerHTML = e;
    var i = o.getElementsByTagName("head")[0];
    try {
      i.appendChild(r);
    } catch {
    }
  }
}, yl = `<div id="dg-save" class="dg dialogue">

  Here's the new load parameter for your <code>GUI</code>'s constructor:

  <textarea id="dg-new-constructor"></textarea>

  <div id="dg-save-locally">

    <input id="dg-local-storage" type="checkbox"/> Automatically save
    values to <code>localStorage</code> on exit.

    <div id="dg-local-explain">The values saved to <code>localStorage</code> will
      override those passed to <code>dat.GUI</code>'s constructor. This makes it
      easier to work incrementally, but <code>localStorage</code> is fragile,
      and your friends may not see the same values you do.

    </div>

  </div>

</div>`, El = function(e, n) {
  var o = e[n];
  return y.isArray(arguments[2]) || y.isObject(arguments[2]) ? new ml(e, n, arguments[2]) : y.isNumber(o) ? y.isNumber(arguments[2]) && y.isNumber(arguments[3]) ? y.isNumber(arguments[4]) ? new er(e, n, arguments[2], arguments[3], arguments[4]) : new er(e, n, arguments[2], arguments[3]) : y.isNumber(arguments[4]) ? new vn(e, n, { min: arguments[2], max: arguments[3], step: arguments[4] }) : new vn(e, n, { min: arguments[2], max: arguments[3] }) : y.isString(o) ? new _l(e, n) : y.isFunction(o) ? new Ji(e, n, "") : y.isBoolean(o) ? new ji(e, n) : null;
};
function gl(t) {
  setTimeout(t, 1e3 / 60);
}
var Al = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || gl, Tl = function() {
  function t() {
    je(this, t), this.backgroundElement = document.createElement("div"), y.extend(this.backgroundElement.style, {
      backgroundColor: "rgba(0,0,0,0.8)",
      top: 0,
      left: 0,
      display: "none",
      zIndex: "1000",
      opacity: 0,
      WebkitTransition: "opacity 0.2s linear",
      transition: "opacity 0.2s linear"
    }), m.makeFullscreen(this.backgroundElement), this.backgroundElement.style.position = "fixed", this.domElement = document.createElement("div"), y.extend(this.domElement.style, {
      position: "fixed",
      display: "none",
      zIndex: "1001",
      opacity: 0,
      WebkitTransition: "-webkit-transform 0.2s ease-out, opacity 0.2s linear",
      transition: "transform 0.2s ease-out, opacity 0.2s linear"
    }), document.body.appendChild(this.backgroundElement), document.body.appendChild(this.domElement);
    var e = this;
    m.bind(this.backgroundElement, "click", function() {
      e.hide();
    });
  }
  return Ke(t, [{
    key: "show",
    value: function() {
      var n = this;
      this.backgroundElement.style.display = "block", this.domElement.style.display = "block", this.domElement.style.opacity = 0, this.domElement.style.webkitTransform = "scale(1.1)", this.layout(), y.defer(function() {
        n.backgroundElement.style.opacity = 1, n.domElement.style.opacity = 1, n.domElement.style.webkitTransform = "scale(1)";
      });
    }
  }, {
    key: "hide",
    value: function() {
      var n = this, o = function r() {
        n.domElement.style.display = "none", n.backgroundElement.style.display = "none", m.unbind(n.domElement, "webkitTransitionEnd", r), m.unbind(n.domElement, "transitionend", r), m.unbind(n.domElement, "oTransitionEnd", r);
      };
      m.bind(this.domElement, "webkitTransitionEnd", o), m.bind(this.domElement, "transitionend", o), m.bind(this.domElement, "oTransitionEnd", o), this.backgroundElement.style.opacity = 0, this.domElement.style.opacity = 0, this.domElement.style.webkitTransform = "scale(1.1)";
    }
  }, {
    key: "layout",
    value: function() {
      this.domElement.style.left = window.innerWidth / 2 - m.getWidth(this.domElement) / 2 + "px", this.domElement.style.top = window.innerHeight / 2 - m.getHeight(this.domElement) / 2 + "px";
    }
  }]), t;
}(), vl = ul(`.dg ul{list-style:none;margin:0;padding:0;width:100%;clear:both}.dg.ac{position:fixed;top:0;left:0;right:0;height:0;z-index:0}.dg:not(.ac) .main{overflow:hidden}.dg.main{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear}.dg.main.taller-than-window{overflow-y:auto}.dg.main.taller-than-window .close-button{opacity:1;margin-top:-1px;border-top:1px solid #2c2c2c}.dg.main ul.closed .close-button{opacity:1 !important}.dg.main:hover .close-button,.dg.main .close-button.drag{opacity:1}.dg.main .close-button{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear;border:0;line-height:19px;height:20px;cursor:pointer;text-align:center;background-color:#000}.dg.main .close-button.close-top{position:relative}.dg.main .close-button.close-bottom{position:absolute}.dg.main .close-button:hover{background-color:#111}.dg.a{float:right;margin-right:15px;overflow-y:visible}.dg.a.has-save>ul.close-top{margin-top:0}.dg.a.has-save>ul.close-bottom{margin-top:27px}.dg.a.has-save>ul.closed{margin-top:0}.dg.a .save-row{top:0;z-index:1002}.dg.a .save-row.close-top{position:relative}.dg.a .save-row.close-bottom{position:fixed}.dg li{-webkit-transition:height .1s ease-out;-o-transition:height .1s ease-out;-moz-transition:height .1s ease-out;transition:height .1s ease-out;-webkit-transition:overflow .1s linear;-o-transition:overflow .1s linear;-moz-transition:overflow .1s linear;transition:overflow .1s linear}.dg li:not(.folder){cursor:auto;height:27px;line-height:27px;padding:0 4px 0 5px}.dg li.folder{padding:0;border-left:4px solid rgba(0,0,0,0)}.dg li.title{cursor:pointer;margin-left:-4px}.dg .closed li:not(.title),.dg .closed ul li,.dg .closed ul li>*{height:0;overflow:hidden;border:0}.dg .cr{clear:both;padding-left:3px;height:27px;overflow:hidden}.dg .property-name{cursor:default;float:left;clear:left;width:40%;overflow:hidden;text-overflow:ellipsis}.dg .cr.function .property-name{width:100%}.dg .c{float:left;width:60%;position:relative}.dg .c input[type=text]{border:0;margin-top:4px;padding:3px;width:100%;float:right}.dg .has-slider input[type=text]{width:30%;margin-left:0}.dg .slider{float:left;width:66%;margin-left:-5px;margin-right:0;height:19px;margin-top:4px}.dg .slider-fg{height:100%}.dg .c input[type=checkbox]{margin-top:7px}.dg .c select{margin-top:5px}.dg .cr.function,.dg .cr.function .property-name,.dg .cr.function *,.dg .cr.boolean,.dg .cr.boolean *{cursor:pointer}.dg .cr.color{overflow:visible}.dg .selector{display:none;position:absolute;margin-left:-9px;margin-top:23px;z-index:10}.dg .c:hover .selector,.dg .selector.drag{display:block}.dg li.save-row{padding:0}.dg li.save-row .button{display:inline-block;padding:0px 6px}.dg.dialogue{background-color:#222;width:460px;padding:15px;font-size:13px;line-height:15px}#dg-new-constructor{padding:10px;color:#222;font-family:Monaco, monospace;font-size:10px;border:0;resize:none;box-shadow:inset 1px 1px 1px #888;word-wrap:break-word;margin:12px 0;display:block;width:440px;overflow-y:scroll;height:100px;position:relative}#dg-local-explain{display:none;font-size:11px;line-height:17px;border-radius:3px;background-color:#333;padding:8px;margin-top:10px}#dg-local-explain code{font-size:10px}#dat-gui-save-locally{display:none}.dg{color:#eee;font:11px 'Lucida Grande', sans-serif;text-shadow:0 -1px 0 #111}.dg.main::-webkit-scrollbar{width:5px;background:#1a1a1a}.dg.main::-webkit-scrollbar-corner{height:0;display:none}.dg.main::-webkit-scrollbar-thumb{border-radius:5px;background:#676767}.dg li:not(.folder){background:#1a1a1a;border-bottom:1px solid #2c2c2c}.dg li.save-row{line-height:25px;background:#dad5cb;border:0}.dg li.save-row select{margin-left:5px;width:108px}.dg li.save-row .button{margin-left:5px;margin-top:1px;border-radius:2px;font-size:9px;line-height:7px;padding:4px 4px 5px 4px;background:#c5bdad;color:#fff;text-shadow:0 1px 0 #b0a58f;box-shadow:0 -1px 0 #b0a58f;cursor:pointer}.dg li.save-row .button.gears{background:#c5bdad url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAANCAYAAAB/9ZQ7AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQJJREFUeNpiYKAU/P//PwGIC/ApCABiBSAW+I8AClAcgKxQ4T9hoMAEUrxx2QSGN6+egDX+/vWT4e7N82AMYoPAx/evwWoYoSYbACX2s7KxCxzcsezDh3evFoDEBYTEEqycggWAzA9AuUSQQgeYPa9fPv6/YWm/Acx5IPb7ty/fw+QZblw67vDs8R0YHyQhgObx+yAJkBqmG5dPPDh1aPOGR/eugW0G4vlIoTIfyFcA+QekhhHJhPdQxbiAIguMBTQZrPD7108M6roWYDFQiIAAv6Aow/1bFwXgis+f2LUAynwoIaNcz8XNx3Dl7MEJUDGQpx9gtQ8YCueB+D26OECAAQDadt7e46D42QAAAABJRU5ErkJggg==) 2px 1px no-repeat;height:7px;width:8px}.dg li.save-row .button:hover{background-color:#bab19e;box-shadow:0 -1px 0 #b0a58f}.dg li.folder{border-bottom:0}.dg li.title{padding-left:16px;background:#000 url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlI+hKgFxoCgAOw==) 6px 10px no-repeat;cursor:pointer;border-bottom:1px solid rgba(255,255,255,0.2)}.dg .closed li.title{background-image:url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlGIWqMCbWAEAOw==)}.dg .cr.boolean{border-left:3px solid #806787}.dg .cr.color{border-left:3px solid}.dg .cr.function{border-left:3px solid #e61d5f}.dg .cr.number{border-left:3px solid #2FA1D6}.dg .cr.number input[type=text]{color:#2FA1D6}.dg .cr.string{border-left:3px solid #1ed36f}.dg .cr.string input[type=text]{color:#1ed36f}.dg .cr.function:hover,.dg .cr.boolean:hover{background:#111}.dg .c input[type=text]{background:#303030;outline:none}.dg .c input[type=text]:hover{background:#3c3c3c}.dg .c input[type=text]:focus{background:#494949;color:#fff}.dg .c .slider{background:#303030;cursor:ew-resize}.dg .c .slider-fg{background:#2FA1D6;max-width:100%}.dg .c .slider:hover{background:#3c3c3c}.dg .c .slider:hover .slider-fg{background:#44abda}
`);
xl.inject(vl);
var Jo = "dg", Qo = 72, Zo = 20, Wt = "Default", Gt = function() {
  try {
    return !!window.localStorage;
  } catch {
    return !1;
  }
}(), Ht = void 0, qo = !0, Ct = void 0, Jn = !1, Qi = [], se = function t(e) {
  var n = this, o = e || {};
  this.domElement = document.createElement("div"), this.__ul = document.createElement("ul"), this.domElement.appendChild(this.__ul), m.addClass(this.domElement, Jo), this.__folders = {}, this.__controllers = [], this.__rememberedObjects = [], this.__rememberedObjectIndecesToControllers = [], this.__listening = [], o = y.defaults(o, {
    closeOnTop: !1,
    autoPlace: !0,
    width: t.DEFAULT_WIDTH
  }), o = y.defaults(o, {
    resizable: o.autoPlace,
    hideable: o.autoPlace
  }), y.isUndefined(o.load) ? o.load = { preset: Wt } : o.preset && (o.load.preset = o.preset), y.isUndefined(o.parent) && o.hideable && Qi.push(this), o.resizable = y.isUndefined(o.parent) && o.resizable, o.autoPlace && y.isUndefined(o.scrollable) && (o.scrollable = !0);
  var r = Gt && localStorage.getItem(Nt(this, "isLocal")) === "true", i = void 0, c = void 0;
  if (Object.defineProperties(
    this,
    {
      parent: {
        get: function() {
          return o.parent;
        }
      },
      scrollable: {
        get: function() {
          return o.scrollable;
        }
      },
      autoPlace: {
        get: function() {
          return o.autoPlace;
        }
      },
      closeOnTop: {
        get: function() {
          return o.closeOnTop;
        }
      },
      preset: {
        get: function() {
          return n.parent ? n.getRoot().preset : o.load.preset;
        },
        set: function(k) {
          n.parent ? n.getRoot().preset = k : o.load.preset = k, Fl(this), n.revert();
        }
      },
      width: {
        get: function() {
          return o.width;
        },
        set: function(k) {
          o.width = k, or(n, k);
        }
      },
      name: {
        get: function() {
          return o.name;
        },
        set: function(k) {
          o.name = k, c && (c.innerHTML = o.name);
        }
      },
      closed: {
        get: function() {
          return o.closed;
        },
        set: function(k) {
          o.closed = k, o.closed ? m.addClass(n.__ul, t.CLASS_CLOSED) : m.removeClass(n.__ul, t.CLASS_CLOSED), this.onResize(), n.__closeButton && (n.__closeButton.innerHTML = k ? t.TEXT_OPEN : t.TEXT_CLOSED);
        }
      },
      load: {
        get: function() {
          return o.load;
        }
      },
      useLocalStorage: {
        get: function() {
          return r;
        },
        set: function(k) {
          Gt && (r = k, k ? m.bind(window, "unload", i) : m.unbind(window, "unload", i), localStorage.setItem(Nt(n, "isLocal"), k));
        }
      }
    }
  ), y.isUndefined(o.parent)) {
    if (this.closed = o.closed || !1, m.addClass(this.domElement, t.CLASS_MAIN), m.makeSelectable(this.domElement, !1), Gt && r) {
      n.useLocalStorage = !0;
      var u = localStorage.getItem(Nt(this, "gui"));
      u && (o.load = JSON.parse(u));
    }
    this.__closeButton = document.createElement("div"), this.__closeButton.innerHTML = t.TEXT_CLOSED, m.addClass(this.__closeButton, t.CLASS_CLOSE_BUTTON), o.closeOnTop ? (m.addClass(this.__closeButton, t.CLASS_CLOSE_TOP), this.domElement.insertBefore(this.__closeButton, this.domElement.childNodes[0])) : (m.addClass(this.__closeButton, t.CLASS_CLOSE_BOTTOM), this.domElement.appendChild(this.__closeButton)), m.bind(this.__closeButton, "click", function() {
      n.closed = !n.closed;
    });
  } else {
    o.closed === void 0 && (o.closed = !0);
    var _ = document.createTextNode(o.name);
    m.addClass(_, "controller-name"), c = vr(n, _);
    var x = function(k) {
      return k.preventDefault(), n.closed = !n.closed, !1;
    };
    m.addClass(this.__ul, t.CLASS_CLOSED), m.addClass(c, "title"), m.bind(c, "click", x), o.closed || (this.closed = !1);
  }
  o.autoPlace && (y.isUndefined(o.parent) && (qo && (Ct = document.createElement("div"), m.addClass(Ct, Jo), m.addClass(Ct, t.CLASS_AUTO_PLACE_CONTAINER), document.body.appendChild(Ct), qo = !1), Ct.appendChild(this.domElement), m.addClass(this.domElement, t.CLASS_AUTO_PLACE)), this.parent || or(n, o.width)), this.__resizeHandler = function() {
    n.onResizeDebounced();
  }, m.bind(window, "resize", this.__resizeHandler), m.bind(this.__ul, "webkitTransitionEnd", this.__resizeHandler), m.bind(this.__ul, "transitionend", this.__resizeHandler), m.bind(this.__ul, "oTransitionEnd", this.__resizeHandler), this.onResize(), o.resizable && wl(this), i = function() {
    Gt && localStorage.getItem(Nt(n, "isLocal")) === "true" && localStorage.setItem(Nt(n, "gui"), JSON.stringify(n.getSaveObject()));
  }, this.saveToLocalStorageIfPossible = i;
  function A() {
    var T = n.getRoot();
    T.width += 1, y.defer(function() {
      T.width -= 1;
    });
  }
  o.parent || A();
};
se.toggleHide = function() {
  Jn = !Jn, y.each(Qi, function(t) {
    t.domElement.style.display = Jn ? "none" : "";
  });
};
se.CLASS_AUTO_PLACE = "a";
se.CLASS_AUTO_PLACE_CONTAINER = "ac";
se.CLASS_MAIN = "main";
se.CLASS_CONTROLLER_ROW = "cr";
se.CLASS_TOO_TALL = "taller-than-window";
se.CLASS_CLOSED = "closed";
se.CLASS_CLOSE_BUTTON = "close-button";
se.CLASS_CLOSE_TOP = "close-top";
se.CLASS_CLOSE_BOTTOM = "close-bottom";
se.CLASS_DRAG = "drag";
se.DEFAULT_WIDTH = 245;
se.TEXT_CLOSED = "Close Controls";
se.TEXT_OPEN = "Open Controls";
se._keydownHandler = function(t) {
  document.activeElement.type !== "text" && (t.which === Qo || t.keyCode === Qo) && se.toggleHide();
};
m.bind(window, "keydown", se._keydownHandler, !1);
y.extend(
  se.prototype,
  {
    add: function(e, n) {
      return Xt(this, e, n, {
        factoryArgs: Array.prototype.slice.call(arguments, 2)
      });
    },
    addColor: function(e, n) {
      return Xt(this, e, n, {
        color: !0
      });
    },
    remove: function(e) {
      this.__ul.removeChild(e.__li), this.__controllers.splice(this.__controllers.indexOf(e), 1);
      var n = this;
      y.defer(function() {
        n.onResize();
      });
    },
    destroy: function() {
      if (this.parent)
        throw new Error("Only the root GUI should be removed with .destroy(). For subfolders, use gui.removeFolder(folder) instead.");
      this.autoPlace && Ct.removeChild(this.domElement);
      var e = this;
      y.each(this.__folders, function(n) {
        e.removeFolder(n);
      }), m.unbind(window, "keydown", se._keydownHandler, !1), ei(this);
    },
    addFolder: function(e) {
      if (this.__folders[e] !== void 0)
        throw new Error('You already have a folder in this GUI by the name "' + e + '"');
      var n = { name: e, parent: this };
      n.autoPlace = this.autoPlace, this.load && this.load.folders && this.load.folders[e] && (n.closed = this.load.folders[e].closed, n.load = this.load.folders[e]);
      var o = new se(n);
      this.__folders[e] = o;
      var r = vr(this, o.domElement);
      return m.addClass(r, "folder"), o;
    },
    removeFolder: function(e) {
      this.__ul.removeChild(e.domElement.parentElement), delete this.__folders[e.name], this.load && this.load.folders && this.load.folders[e.name] && delete this.load.folders[e.name], ei(e);
      var n = this;
      y.each(e.__folders, function(o) {
        e.removeFolder(o);
      }), y.defer(function() {
        n.onResize();
      });
    },
    open: function() {
      this.closed = !1;
    },
    close: function() {
      this.closed = !0;
    },
    hide: function() {
      this.domElement.style.display = "none";
    },
    show: function() {
      this.domElement.style.display = "";
    },
    onResize: function() {
      var e = this.getRoot();
      if (e.scrollable) {
        var n = m.getOffset(e.__ul).top, o = 0;
        y.each(e.__ul.childNodes, function(r) {
          e.autoPlace && r === e.__save_row || (o += m.getHeight(r));
        }), window.innerHeight - n - Zo < o ? (m.addClass(e.domElement, se.CLASS_TOO_TALL), e.__ul.style.height = window.innerHeight - n - Zo + "px") : (m.removeClass(e.domElement, se.CLASS_TOO_TALL), e.__ul.style.height = "auto");
      }
      e.__resize_handle && y.defer(function() {
        e.__resize_handle.style.height = e.__ul.offsetHeight + "px";
      }), e.__closeButton && (e.__closeButton.style.width = e.width + "px");
    },
    onResizeDebounced: y.debounce(function() {
      this.onResize();
    }, 50),
    remember: function() {
      if (y.isUndefined(Ht) && (Ht = new Tl(), Ht.domElement.innerHTML = yl), this.parent)
        throw new Error("You can only call remember on a top level GUI.");
      var e = this;
      y.each(Array.prototype.slice.call(arguments), function(n) {
        e.__rememberedObjects.length === 0 && Rl(e), e.__rememberedObjects.indexOf(n) === -1 && e.__rememberedObjects.push(n);
      }), this.autoPlace && or(this, this.width);
    },
    getRoot: function() {
      for (var e = this; e.parent; )
        e = e.parent;
      return e;
    },
    getSaveObject: function() {
      var e = this.load;
      return e.closed = this.closed, this.__rememberedObjects.length > 0 && (e.preset = this.preset, e.remembered || (e.remembered = {}), e.remembered[this.preset] = xn(this)), e.folders = {}, y.each(this.__folders, function(n, o) {
        e.folders[o] = n.getSaveObject();
      }), e;
    },
    save: function() {
      this.load.remembered || (this.load.remembered = {}), this.load.remembered[this.preset] = xn(this), nr(this, !1), this.saveToLocalStorageIfPossible();
    },
    saveAs: function(e) {
      this.load.remembered || (this.load.remembered = {}, this.load.remembered[Wt] = xn(this, !0)), this.load.remembered[e] = xn(this), this.preset = e, rr(this, e, !0), this.saveToLocalStorageIfPossible();
    },
    revert: function(e) {
      y.each(this.__controllers, function(n) {
        this.getRoot().load.remembered ? Zi(e || this.getRoot(), n) : n.setValue(n.initialValue), n.__onFinishChange && n.__onFinishChange.call(n, n.getValue());
      }, this), y.each(this.__folders, function(n) {
        n.revert(n);
      }), e || nr(this.getRoot(), !1);
    },
    listen: function(e) {
      var n = this.__listening.length === 0;
      this.__listening.push(e), n && qi(this.__listening);
    },
    updateDisplay: function() {
      y.each(this.__controllers, function(e) {
        e.updateDisplay();
      }), y.each(this.__folders, function(e) {
        e.updateDisplay();
      });
    }
  }
);
function vr(t, e, n) {
  var o = document.createElement("li");
  return e && o.appendChild(e), n ? t.__ul.insertBefore(o, n) : t.__ul.appendChild(o), t.onResize(), o;
}
function ei(t) {
  m.unbind(window, "resize", t.__resizeHandler), t.saveToLocalStorageIfPossible && m.unbind(window, "unload", t.saveToLocalStorageIfPossible);
}
function nr(t, e) {
  var n = t.__preset_select[t.__preset_select.selectedIndex];
  e ? n.innerHTML = n.value + "*" : n.innerHTML = n.value;
}
function Sl(t, e, n) {
  if (n.__li = e, n.__gui = t, y.extend(n, {
    options: function(c) {
      if (arguments.length > 1) {
        var u = n.__li.nextElementSibling;
        return n.remove(), Xt(t, n.object, n.property, {
          before: u,
          factoryArgs: [y.toArray(arguments)]
        });
      }
      if (y.isArray(c) || y.isObject(c)) {
        var _ = n.__li.nextElementSibling;
        return n.remove(), Xt(t, n.object, n.property, {
          before: _,
          factoryArgs: [c]
        });
      }
    },
    name: function(c) {
      return n.__li.firstElementChild.firstElementChild.innerHTML = c, n;
    },
    listen: function() {
      return n.__gui.listen(n), n;
    },
    remove: function() {
      return n.__gui.remove(n), n;
    }
  }), n instanceof er) {
    var o = new vn(n.object, n.property, { min: n.__min, max: n.__max, step: n.__step });
    y.each(["updateDisplay", "onChange", "onFinishChange", "step", "min", "max"], function(i) {
      var c = n[i], u = o[i];
      n[i] = o[i] = function() {
        var _ = Array.prototype.slice.call(arguments);
        return u.apply(o, _), c.apply(n, _);
      };
    }), m.addClass(e, "has-slider"), n.domElement.insertBefore(o.domElement, n.domElement.firstElementChild);
  } else if (n instanceof vn) {
    var r = function(c) {
      if (y.isNumber(n.__min) && y.isNumber(n.__max)) {
        var u = n.__li.firstElementChild.firstElementChild.innerHTML, _ = n.__gui.__listening.indexOf(n) > -1;
        n.remove();
        var x = Xt(t, n.object, n.property, {
          before: n.__li.nextElementSibling,
          factoryArgs: [n.__min, n.__max, n.__step]
        });
        return x.name(u), _ && x.listen(), x;
      }
      return c;
    };
    n.min = y.compose(r, n.min), n.max = y.compose(r, n.max);
  } else n instanceof ji ? (m.bind(e, "click", function() {
    m.fakeEvent(n.__checkbox, "click");
  }), m.bind(n.__checkbox, "click", function(i) {
    i.stopPropagation();
  })) : n instanceof Ji ? (m.bind(e, "click", function() {
    m.fakeEvent(n.__button, "click");
  }), m.bind(e, "mouseover", function() {
    m.addClass(n.__button, "hover");
  }), m.bind(e, "mouseout", function() {
    m.removeClass(n.__button, "hover");
  })) : n instanceof tr && (m.addClass(e, "color"), n.updateDisplay = y.compose(function(i) {
    return e.style.borderLeftColor = n.__color.toString(), i;
  }, n.updateDisplay), n.updateDisplay());
  n.setValue = y.compose(function(i) {
    return t.getRoot().__preset_select && n.isModified() && nr(t.getRoot(), !0), i;
  }, n.setValue);
}
function Zi(t, e) {
  var n = t.getRoot(), o = n.__rememberedObjects.indexOf(e.object);
  if (o !== -1) {
    var r = n.__rememberedObjectIndecesToControllers[o];
    if (r === void 0 && (r = {}, n.__rememberedObjectIndecesToControllers[o] = r), r[e.property] = e, n.load && n.load.remembered) {
      var i = n.load.remembered, c = void 0;
      if (i[t.preset])
        c = i[t.preset];
      else if (i[Wt])
        c = i[Wt];
      else
        return;
      if (c[o] && c[o][e.property] !== void 0) {
        var u = c[o][e.property];
        e.initialValue = u, e.setValue(u);
      }
    }
  }
}
function Xt(t, e, n, o) {
  if (e[n] === void 0)
    throw new Error('Object "' + e + '" has no property "' + n + '"');
  var r = void 0;
  if (o.color)
    r = new tr(e, n);
  else {
    var i = [e, n].concat(o.factoryArgs);
    r = El.apply(t, i);
  }
  o.before instanceof vt && (o.before = o.before.__li), Zi(t, r), m.addClass(r.domElement, "c");
  var c = document.createElement("span");
  m.addClass(c, "property-name"), c.innerHTML = r.property;
  var u = document.createElement("div");
  u.appendChild(c), u.appendChild(r.domElement);
  var _ = vr(t, u, o.before);
  return m.addClass(_, se.CLASS_CONTROLLER_ROW), r instanceof tr ? m.addClass(_, "color") : m.addClass(_, fl(r.getValue())), Sl(t, _, r), t.__controllers.push(r), r;
}
function Nt(t, e) {
  return document.location.href + "." + e;
}
function rr(t, e, n) {
  var o = document.createElement("option");
  o.innerHTML = e, o.value = e, t.__preset_select.appendChild(o), n && (t.__preset_select.selectedIndex = t.__preset_select.length - 1);
}
function ti(t, e) {
  e.style.display = t.useLocalStorage ? "block" : "none";
}
function Rl(t) {
  var e = t.__save_row = document.createElement("li");
  m.addClass(t.domElement, "has-save"), t.__ul.insertBefore(e, t.__ul.firstChild), m.addClass(e, "save-row");
  var n = document.createElement("span");
  n.innerHTML = "&nbsp;", m.addClass(n, "button gears");
  var o = document.createElement("span");
  o.innerHTML = "Save", m.addClass(o, "button"), m.addClass(o, "save");
  var r = document.createElement("span");
  r.innerHTML = "New", m.addClass(r, "button"), m.addClass(r, "save-as");
  var i = document.createElement("span");
  i.innerHTML = "Revert", m.addClass(i, "button"), m.addClass(i, "revert");
  var c = t.__preset_select = document.createElement("select");
  if (t.load && t.load.remembered ? y.each(t.load.remembered, function(T, k) {
    rr(t, k, k === t.preset);
  }) : rr(t, Wt, !1), m.bind(c, "change", function() {
    for (var T = 0; T < t.__preset_select.length; T++)
      t.__preset_select[T].innerHTML = t.__preset_select[T].value;
    t.preset = this.value;
  }), e.appendChild(c), e.appendChild(n), e.appendChild(o), e.appendChild(r), e.appendChild(i), Gt) {
    var u = document.getElementById("dg-local-explain"), _ = document.getElementById("dg-local-storage"), x = document.getElementById("dg-save-locally");
    x.style.display = "block", localStorage.getItem(Nt(t, "isLocal")) === "true" && _.setAttribute("checked", "checked"), ti(t, u), m.bind(_, "change", function() {
      t.useLocalStorage = !t.useLocalStorage, ti(t, u);
    });
  }
  var A = document.getElementById("dg-new-constructor");
  m.bind(A, "keydown", function(T) {
    T.metaKey && (T.which === 67 || T.keyCode === 67) && Ht.hide();
  }), m.bind(n, "click", function() {
    A.innerHTML = JSON.stringify(t.getSaveObject(), void 0, 2), Ht.show(), A.focus(), A.select();
  }), m.bind(o, "click", function() {
    t.save();
  }), m.bind(r, "click", function() {
    var T = prompt("Enter a new preset name.");
    T && t.saveAs(T);
  }), m.bind(i, "click", function() {
    t.revert();
  });
}
function wl(t) {
  var e = void 0;
  t.__resize_handle = document.createElement("div"), y.extend(t.__resize_handle.style, {
    width: "6px",
    marginLeft: "-3px",
    height: "200px",
    cursor: "ew-resize",
    position: "absolute"
  });
  function n(i) {
    return i.preventDefault(), t.width += e - i.clientX, t.onResize(), e = i.clientX, !1;
  }
  function o() {
    m.removeClass(t.__closeButton, se.CLASS_DRAG), m.unbind(window, "mousemove", n), m.unbind(window, "mouseup", o);
  }
  function r(i) {
    return i.preventDefault(), e = i.clientX, m.addClass(t.__closeButton, se.CLASS_DRAG), m.bind(window, "mousemove", n), m.bind(window, "mouseup", o), !1;
  }
  m.bind(t.__resize_handle, "mousedown", r), m.bind(t.__closeButton, "mousedown", r), t.domElement.insertBefore(t.__resize_handle, t.domElement.firstElementChild);
}
function or(t, e) {
  t.domElement.style.width = e + "px", t.__save_row && t.autoPlace && (t.__save_row.style.width = e + "px"), t.__closeButton && (t.__closeButton.style.width = e + "px");
}
function xn(t, e) {
  var n = {};
  return y.each(t.__rememberedObjects, function(o, r) {
    var i = {}, c = t.__rememberedObjectIndecesToControllers[r];
    y.each(c, function(u, _) {
      i[_] = e ? u.initialValue : u.getValue();
    }), n[r] = i;
  }), n;
}
function Fl(t) {
  for (var e = 0; e < t.__preset_select.length; e++)
    t.__preset_select[e].value === t.preset && (t.__preset_select.selectedIndex = e);
}
function qi(t) {
  t.length !== 0 && Al.call(window, function() {
    qi(t);
  }), y.each(t, function(e) {
    e.updateDisplay();
  });
}
var Il = se, ui;
const Cl = (ui = window.webkit) == null ? void 0 : ui.messageHandlers, Nl = window.webkit != null;
function ni(t, e = t) {
  Nl && Cl[t].postMessage(e);
}
const ri = {
  debug: !1,
  console: !1,
  flicker: !0,
  baseAlphaMultiplier: 1.5,
  lineWidth: 3.5,
  autoSolve: !1,
  minWorthwhileErrorImprovement: 0.05,
  masterSideAttacherColor: "rgb(255,165,0)",
  instanceSideAttacherColor: "rgb(255,222,33)",
  showControlPoints: !0,
  controlPointColor: "rgba(255,222,33,.2)",
  axisColor: "rgba(255,222,33,0.125)",
  handleRadius: 7,
  closeEnough: 7,
  crosshairsSize: 15,
  fontScale: 10,
  kerning: 0.75,
  showGuideLines: !1,
  guideLineColor: "rgba(255,255,255,.125)",
  statusTimeMillis: 4e3,
  usePredictedEvents: !1,
  weight: 25,
  distanceConstraintTextScale: 0.3,
  distanceConstraintLabelPct: 0.25,
  showImplicitConstraints: !1,
  highlightReferents: !0,
  maxDepth: 10,
  tabletButtonWidth: 100,
  lefty: !1,
  onionSkinAlpha: 0
};
let En;
function Bl() {
  En = JSON.parse(localStorage.getItem("config") ?? JSON.stringify(ri));
  for (const [t, e] of Object.entries(ri))
    Object.hasOwn(En, t) || (En[t] = e);
}
function Pt() {
  return En;
}
Bl();
window.config = Pt;
let jt = [], Qn = !1;
function Pl() {
  const t = jt;
  return jt = [], t;
}
function oi(t) {
  for (const e of t)
    (!e.predicted || Pt().usePredictedEvents) && jt.push(e);
}
function Sr(t, e) {
  const n = t.pointerType == "touch" ? "finger" : "pencil";
  e === "began" && (Qn = !0), e === "ended" && (Qn = !1), !(e === "moved" && !Qn) && jt.push({
    id: t.pointerId,
    type: n,
    phase: e,
    predicted: !1,
    position: { x: t.clientX, y: t.clientY },
    pressure: t.pointerType == "mouse" ? 1 : t.pressure * 5,
    altitude: 0,
    azimuth: 0,
    rollAngle: 0,
    radius: 0,
    timestamp: performance.now()
  });
}
function Dl() {
  window.onpointerdown = null, window.onpointermove = null, window.onpointerup = null, window.removeEventListener("touchstart", es), jt = [];
}
window.onpointerdown = (t) => Sr(t, "began");
window.onpointermove = (t) => Sr(t, "moved");
window.onpointerup = (t) => Sr(t, "ended");
const es = (t) => t.preventDefault();
window.addEventListener("touchstart", es, { passive: !1 });
window.wrapperEvents = (t) => {
  window.wrapperEvents = oi, Dl(), oi(t);
};
const Ul = {
  log: console.log,
  warn: console.warn,
  error: console.error
};
let Ve = null, gn = [];
function ir() {
  if (Pt().console) {
    if (!Ve) {
      Ve = Ml();
      for (const e of gn) ts(e);
    }
    Ve.style.display = "block";
  } else Ve && (Ve.style.display = "none");
}
function Ml() {
  const t = document.createElement("div");
  t.innerHTML = `<div style="position: absolute; right: 0; bottom: 0; padding: 5px; width: fit-content; white-space: pre; font-family: monospace; background: rgba(0,0,0,0.5); max-width: 50%;
    white-space: break-spaces; pointer-events: none"></div>`;
  const e = t.children[0];
  return document.body.appendChild(e), e;
}
function Rr(t) {
  return function(...e) {
    Ul[t](...e);
    const n = e.map((c) => typeof c == "string" ? c : JSON.stringify(c, null, 2)).join(" "), o = document.createElement("div"), r = t === "error" ? "#F33" : t === "warn" ? "#FD4" : "#CCC", i = new Date(Date.now() - (/* @__PURE__ */ new Date()).getTimezoneOffset() * 6e4).toISOString().slice(11, 23);
    o.innerHTML = `<span style="color: #999">${i}:</span> <span style="color: ${r}">${n}</span>`, gn.length > 100 && gn.shift(), gn.push(o), ts(o);
  };
}
function ts(t) {
  if (Ve) {
    for (Ve.appendChild(t); Ve.getBoundingClientRect().height > window.innerHeight * 2 && Ve.children[1]; )
      Ve.children[0].remove();
    Ve.scrollTop = Ve.scrollHeight;
  }
}
console.log = Rr("log");
console.warn = Rr("warn");
console.error = Rr("error");
addEventListener("error", (t) => console.error("Error:", t.error.message || t.error));
addEventListener("unhandledrejection", (t) => console.error("Unhandled Rejection:", t.reason.message || t.reason));
console.log("Back to 1963!");
ir();
const Sn = 16348;
let Oe = new Int32Array(Sn * 2 + 64), Ge = 0, Tt = 0, ii = [], ze = 0, Rn = !1;
function Ol(t, e) {
  return e && si(e), Hl(t), { clearSpots: ns, addSpot: Kt, setParams: si, demo: sr };
}
function ns() {
  Ge = 0, Tt = 0, Rn = !0;
}
function Kt(t, e, n) {
  if (typeof t == "object") {
    const i = t;
    return Kt(i.x, i.y, i.id);
  }
  if (typeof t != "number" || typeof e != "number") throw Error("addSpot(x, y, id?) expects x, y as numbers");
  if (n || (n = 0), Ge >= Sn) {
    console.warn(`MAX_SPOTS (${Sn}) reached`);
    return;
  }
  const o = Ge;
  let r = o;
  if (Q.twinkle) {
    const i = Math.random() * Ge | 0;
    Oe[2 * r] = Oe[2 * i], Oe[2 * r + 1] = Oe[2 * i + 1], r = i;
  }
  Oe[2 * r] = t << 16 | n & 65535, Oe[2 * r + 1] = e << 16 | o & 65535, Ge++, Rn = !0;
}
function si(t) {
  Object.assign(Q, t);
}
const Q = {
  interlace: !1,
  // interlaced rendering
  twinkle: !1,
  // scramble spots for less flicker
  penTracker: !0,
  // draw pen tracking cross
  scissor: !1,
  // only draw within 1024x1024 square
  spotsPerSec: 5e4,
  // draw speed in spots per second
  demo: !1,
  // run demo
  demoSpots: 4e3,
  demoMulX: 3,
  demoMulY: 4,
  demoPhaseX: 1,
  demoPhaseY: 0,
  colorizeByIndex: !1,
  // colorize spots by ID
  showGui: !1,
  // show GUI
  openGui: !1,
  // open controls at start
  showConsole: Pt().console,
  fullscreen: !1
}, Ue = {
  spotSize: 12,
  fadeAmount: 0.3,
  phosphorAmbient: 0.3,
  phosphorSmoothness: 0.95,
  phosphorGrain: 400,
  screenScale: [0, 0],
  // set in resize()
  colorIdx: 0
};
function sr() {
  ns(), t(400, 400, Q.demoPhaseX, Q.demoPhaseY, Q.demoMulX | 0, Q.demoMulY | 0, Q.demoSpots);
  function t(e, n, o, r, i, c, u) {
    for (let _ = 0; _ < u; _++) {
      const x = _ * Math.PI * 2 / u;
      Kt(
        Math.sin(i * x + o) * e,
        Math.cos(c * x + r) * n
      );
    }
  }
}
const Ll = `#version 300 es
in vec2 pos;
out vec2 uv;
void main() {
    gl_Position = vec4(pos, 0.0, 1.0);
    uv = pos * 0.5 + 0.5;
}`, kl = `#version 300 es
precision mediump float;
uniform float fadeAmount;
uniform float phosphorAmbient;
uniform float phosphorSmoothness;
uniform float phosphorGrain;
in vec2 uv;
out vec4 photons;

// Simplex Noise Function
vec2 mod289(vec2 x) {
    return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec3 mod289(vec3 x) {
    return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec3 permute(vec3 x) {
    return mod289(((x*34.0)+1.0)*x);
}

float simplexNoise(vec2 v) {
    const vec4 C = vec4(0.211324865405187, 0.366025403784439, -0.577350269189626, 0.024390243902439);
    vec2 i  = floor(v + dot(v, C.yy) );
    vec2 x0 = v -   i + dot(i, C.xx);
    vec2 i1;
    i1.x = step( x0.y, x0.x );
    i1.y = 1.0 - i1.x;
    vec4 x12 = x0.xyxy + C.xxzz;
    x12.xy -= i1;
    i = mod289(i);
    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))
            + i.x + vec3(0.0, i1.x, 1.0 ));
    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);
    m = m*m ;
    m = m*m ;
    vec3 x = 2.0 * fract(p * C.www) - 1.0;
    vec3 h = abs(x) - 0.5;
    vec3 ox = floor(x + 0.5);
    vec3 a0 = x - ox;
    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );
    vec3 g;
    g.x  = a0.x  * x0.x  + h.x  * x0.y;
    g.yz = a0.yz * x12.xz + h.yz * x12.yw;
    return 130.0 * dot(m, g);
}

void main() {
    // noise to simulate phosphor roughness
    float p = phosphorAmbient * mix(simplexNoise(uv * phosphorGrain) * 2.0, 1.0, phosphorSmoothness);
    // used with src * src.a + dst*(1-src.a)) blending to fade out
    photons = vec4(p, p, p, fadeAmount);
}`, $l = `#version 300 es
in      ivec2 xyIdIx;          // position in upper 16 bits, id in lower 16 bits
uniform vec2  screenScale;     // half width/height of screen
uniform float spotSize;        // size of spot

void main() {
    ivec2 pos = xyIdIx >> ivec2(16, 16);                   // sign extend 16 bits to 32
    gl_Position = vec4(vec2(pos) / screenScale, 0.0, 1.0);
    gl_PointSize = spotSize;
}`, zl = `#version 300 es
precision mediump float;
out vec4 photons;
void main() {
    float dist = distance(gl_PointCoord, vec2(0.5));
    float gauss = exp(-15.0 * dist*dist);                  // -15 works well for 8 bit color components
    if (gauss < 0.01) discard;
    // src+dst blending to accumulate photons
    photons = vec4(gauss, gauss, gauss, 1.0);
}`, Vl = `#version 300 es
in      ivec2 xyIdIx;          // position in upper 16 bits, id and index in lower 16 bits
uniform vec2  screenScale;     // half width/height of screen
uniform float spotSize;        // size of spot
uniform uint  colorIdx;        // start of spots in display table
out     vec3  v_color;         // color of spot

vec3 hue(float h) {
    h = mod(h, 1.0);
    float r = abs(h * 6.0 - 3.0) - 1.0;
    float g = 2.0 - abs(h * 6.0 - 2.0);
    float b = 2.0 - abs(h * 6.0 - 4.0);
    return clamp(vec3(r, g, b), 0.0, 1.0);
}

void main() {
    ivec2 pos = xyIdIx >> ivec2(16, 16);                   // sign extend 16 bits to 32
    uint idx = uint(xyIdIx.y & 65535);                     // 16 bit index
    if (idx < colorIdx) {
        float fraction = float(idx) / float(colorIdx);     // map to [0, 1)
        v_color = hue(float(idx) / float(colorIdx));       // color by table index
    } else {
        v_color = vec3(1.0);                               // default: white
    }
    gl_Position = vec4(vec2(pos) / screenScale, 0.0, 1.0);
    gl_PointSize = spotSize * 512.0 / max(screenScale.x, screenScale.y);
}`, Gl = `#version 300 es
precision mediump float;
in vec3 v_color;
out vec4 photons;
void main() {
    float dist = distance(gl_PointCoord, vec2(0.5));
    float gauss = exp(-15.0 * dist*dist);                  // -15 works well for 8 bit color components
    if (gauss < 0.01) discard;
    // src+dst blending to accumulate photons
    photons = gauss * vec4(v_color, 1.0);
}`;
function Hl(t) {
  const e = t.getContext("webgl2", { preserveDrawingBuffer: !0 });
  if (!e) throw new Error("No WebGL2 context found");
  function n() {
    al(t, devicePixelRatio), e.viewport(0, 0, t.width, t.height);
    const V = Math.min(t.width / 512, t.height / 512);
    if (Ue.screenScale = [t.width / V, t.height / V], Q.scissor) {
      const pe = t.width / t.height, Z = pe > 1 ? (t.width - t.height) / 2 : 0, ie = pe < 1 ? (t.height - t.width) / 2 : 0;
      e.enable(e.SCISSOR_TEST), e.scissor(Z, ie, t.width - 2 * Z, t.height - 2 * ie);
    } else
      e.disable(e.SCISSOR_TEST);
  }
  onresize = () => n(), n();
  const o = new Il();
  o.add(Q, "spotsPerSec", 1e3, 5e5), o.add(Ue, "spotSize", 1, 256), o.add(Ue, "fadeAmount", 0, 1), o.add(Ue, "phosphorAmbient", 0, 0.5), o.add(Ue, "phosphorSmoothness", 0, 1), o.add(Ue, "phosphorGrain", 100, 2e3), o.add(Q, "interlace"), o.add(Q, "twinkle"), o.add(Q, "penTracker").onChange((V) => {
    t.style.cursor = V ? "none" : "default", V || rs();
  }), Q.demo && (sr(), o.add(Q, "demoSpots", 1, Sn - 348), o.add(Q, "demoMulX", 1, 10), o.add(Q, "demoMulY", 1, 10)), o.add(Q, "colorizeByIndex"), o.add(Q, "showConsole").onChange((V) => {
    Pt().console = V, ir();
  }), o.add(Q, "scissor").onChange(() => n()), o.add(Q, "fullscreen").onChange((V) => {
    V ? document.body.requestFullscreen() : document.exitFullscreen();
  }), Q.showGui || o.hide(), Q.openGui || o.close(), Pt().console = Q.showConsole, ir(), t.style.cursor = Q.penTracker ? "none" : "default";
  const r = {
    pos: { x: 0, y: 0 }
  };
  function i(V, pe) {
    const Z = t.getBoundingClientRect();
    r.pos.x = (V - Z.left - Z.width / 2) / Z.width * 2 * Ue.screenScale[0] | 0, r.pos.y = (pe - Z.top - Z.height / 2) / Z.height * -2 * Ue.screenScale[1] | 0, r.downPos && (Q.demoPhaseX = r.downPhase.x + (r.pos.x - r.downPos.x) / 500, Q.demoPhaseY = r.downPhase.y + (r.pos.y - r.downPos.y) / 500, Q.demo && sr());
  }
  t.onpointermove = (V) => i(V.clientX, V.clientY);
  function c() {
    for (const V of Pl())
      if (V.type === "pencil")
        switch (i(V.position.x, V.position.y), V.phase) {
          case "began":
            r.downPos = { ...r.pos }, r.downPhase = { x: Q.demoPhaseX, y: Q.demoPhaseY };
            break;
          case "ended":
            r.downPos = void 0;
            break;
        }
  }
  const u = Kn(e, [Ll, kl]), x = jn(e, {
    pos: {
      numComponents: 2,
      data: [
        -1,
        -1,
        1,
        -1,
        1,
        1,
        -1,
        1
      ]
    }
  });
  let A = Kn(e, [$l, zl]), T = Kn(e, [Vl, Gl]);
  const j = jn(e, {
    xyIdIx: {
      numComponents: 2,
      data: Oe
    }
  }), W = [];
  for (let V = 0; V < 8; V++) {
    const pe = {
      xyIdIx: {
        numComponents: 2,
        data: Oe,
        stride: 64,
        // every 8th spot, 8 bytes per spot
        offset: 8 * V
        // staggered by 8 bytes
      }
    };
    W.push(jn(e, pe));
  }
  let H = 0;
  function ee(V) {
    const pe = V - H;
    H = V;
    let Z = Math.max(8, Math.min(pe, 30)) * Q.spotsPerSec / 1e3 | 0;
    if (c(), Q.penTracker && Xl(r.pos), e.enable(e.BLEND), e.blendFunc(e.SRC_ALPHA, e.ONE_MINUS_SRC_ALPHA), e.useProgram(u.program), hn(e, u, x), yn(u, Ue), $t(e, x, e.TRIANGLE_FAN), Rn) {
      zo(
        e,
        j.attribs.xyIdIx,
        new Int32Array(Oe.buffer, 0, Ge * 2)
      );
      for (let Je = 0; Je < 8; Je++)
        zo(
          e,
          W[Je].attribs.xyIdIx,
          new Int32Array(Oe.buffer, 0, Ge * 2)
        );
      Rn = !1;
    }
    const ie = Ge - Tt;
    ze >= ie && (ze = 0);
    let Ee = Q.colorizeByIndex ? T : A;
    if (e.enable(e.BLEND), e.blendFunc(e.ONE, e.ONE), e.useProgram(Ee.program), Ue.colorIdx = ie, yn(Ee, Ue), Q.interlace && ie > 8) {
      const Je = ie >> 3;
      let rt = 0, Ce = ze >> 3, He = ze & 7;
      for (; Z > 0 && ie > rt; ) {
        hn(e, Ee, W[He]);
        const yt = Math.min(Ce + Z, Je) - Ce;
        if (yt <= 0) break;
        $t(e, W[He], e.POINTS, yt, Ce), rt += yt, Z -= yt, Ce += yt, Ce === Je && (Ce = 0, He++ === 7 && (He = 0));
      }
      ze = (Ce << 3) + He;
    } else {
      hn(e, Ee, j);
      const rt = Math.min(ze + Z, ie) - ze;
      rt > 0 && $t(e, j, e.POINTS, rt, ze);
      const Ce = rt;
      if (Z -= Ce, ze = (ze + Ce) % ie, Z > 0 && ie > Ce) {
        const He = Math.min(Z, ie - Ce);
        $t(e, j, e.POINTS, He), ze = (ze + He) % ie;
      }
    }
    Tt > 0 && (Ue.colorIdx = 0, yn(Ee, Ue), hn(e, Ee, j), $t(e, j, e.POINTS, Tt, ie)), requestAnimationFrame(ee);
  }
  requestAnimationFrame(ee);
}
function rs() {
  Ge -= Tt, Tt = 0;
}
let ai = !1;
function Xl({ x: t, y: e }) {
  rs();
  const n = Ge, o = Q.twinkle;
  Q.twinkle = !1;
  const r = 6, i = 2.5, c = 0.25, u = 5, _ = 0.4, x = Math.max(10, Ue.spotSize) / 5, A = x * u;
  ii.length = 0;
  let T = t, k = e, j = 1 / 0;
  for (let ee = 0; ee < Ge; ee++) {
    const V = Oe[2 * ee] >> 16, pe = Math.abs(t - V);
    if (pe > A) continue;
    const Z = Oe[2 * ee + 1] >> 16, ie = Math.abs(e - Z);
    if (ie > A) continue;
    ii.push({ x: V, y: Z, id: Oe[2 * ee] & 65535 });
    const Ee = Math.min(pe, ie);
    Ee < j && (T = V, k = Z, j = Ee);
  }
  const W = j < 1 / 0;
  W !== ai && (W && (ni("prepareHaptics"), ni("hapticImpact")), ai = W);
  const H = x * _;
  for (const [ee, V] of [[-2, -2], [-3, 0], [-2, 2], [0, -3], [0, 0], [0, 3], [2, -2], [3, 0], [2, 2]])
    Kt(T + ee * H, k + V * H);
  for (let ee = 0; ee < r; ee++) {
    const V = Math.log(i + ee) / c * x;
    for (const [pe, Z] of [[-1, 0], [1, 0], [0, -1], [0, 1]])
      Kt(t + pe * V, e + Z * V);
  }
  Tt = Ge - n, Q.twinkle = o;
}
Ol(
  document.getElementById("canvas"),
  { showGui: !0, openGui: !0, showConsole: !0, demo: !0 }
);
    </script>
  </body>
</html>
